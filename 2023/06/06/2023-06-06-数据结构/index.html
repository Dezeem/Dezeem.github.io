<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>数据结构 | 少先队长</title>
  <meta name="description" content="数据结构线性表链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#x2F;&#x2F; define element typetypedef int ElemType;&#x2F;&#x2F; define struct of linked listtypedef struct LNode &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://dezeem.github.io/2023/06/06/2023-06-06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="少先队长的Blog">
<meta property="og:description" content="数据结构线性表链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#x2F;&#x2F; define element typetypedef int ElemType;&#x2F;&#x2F; define struct of linked listtypedef struct LNode &amp;#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131014059.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131019717.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131021410.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131023406.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210221013239.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181007848.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181111010.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181129919.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181155170.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181328092.png">
<meta property="article:published_time" content="2023-06-06T09:14:13.000Z">
<meta property="article:modified_time" content="2023-06-06T02:44:21.060Z">
<meta property="article:author" content="Dezeem">
<meta property="article:tag" content="手册">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131014059.webp">
  <!-- Canonical links -->
  <link rel="canonical" href="http://dezeem.github.io/2023/06/06/2023-06-06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
  
    <link rel="alternate" href="/atom.xml" title="少先队长的Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/Dezeem" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">少先队长</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Student &amp; Designer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shanghai, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Dezeem" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <h3>欢迎光临！</h3>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Wireshark/">Wireshark</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%BD%91/">计网</a><span class="category-list-count">7</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%8B%E5%86%8C/" rel="tag">手册</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%BD%91/" rel="tag">计网</a><span class="tag-list-count">11</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/%E6%89%8B%E5%86%8C/" style="font-size: 13px;">手册</a> <a href="/tags/%E8%AE%A1%E7%BD%91/" style="font-size: 14px;">计网</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/C/">C++</a>
              </p>
              <p class="item-title">
                <a href="/2024/01/16/2024-01-15-C++%E8%BF%9B%E9%98%B6/" class="title">Effectivate C++</a>
              </p>
              <p class="item-date">
                <time datetime="2024-01-15T20:30:00.000Z" itemprop="datePublished">2024-01-16</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
              </p>
              <p class="item-title">
                <a href="/2023/06/06/2023-06-06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="title">数据结构</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-06T09:14:13.000Z" itemprop="datePublished">2023-06-06</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
              </p>
              <p class="item-title">
                <a href="/2022/10/05/2022-10-04-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" class="title">刷题笔记</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-04T20:24:00.000Z" itemprop="datePublished">2022-10-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%AE%A1%E7%BD%91/">计网</a>
              </p>
              <p class="item-title">
                <a href="/2022/07/30/2022-07-29-%E5%B1%80%E5%9F%9F%E7%BD%91/" class="title">局域网</a>
              </p>
              <p class="item-date">
                <time datetime="2022-07-29T16:10:00.000Z" itemprop="datePublished">2022-07-30</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%AE%A1%E7%BD%91/">计网</a>
              </p>
              <p class="item-title">
                <a href="/2022/07/29/2022-07-29-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="title">数据链路层</a>
              </p>
              <p class="item-date">
                <time datetime="2022-07-29T10:25:00.000Z" itemprop="datePublished">2022-07-29</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.2.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.3.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="toc-number">1.3.1.</span> <span class="toc-text">顺序队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.3.2.</span> <span class="toc-text">循环队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">动态数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">树和二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.1.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#avl-tree"><span class="toc-number">1.5.3.</span> <span class="toc-text">AVL Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">平衡化操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ll%E5%9E%8B"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text">LL型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rr%E5%9E%8B"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text">RR型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lr%E5%9E%8B"><span class="toc-number">1.5.3.1.3.</span> <span class="toc-text">LR型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rl%E5%9E%8B"><span class="toc-number">1.5.3.1.4.</span> <span class="toc-text">RL型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">1.5.4.</span> <span class="toc-text">二叉查找树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.5.5.</span> <span class="toc-text">红黑树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">1.6.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.6.2.</span> <span class="toc-text">邻接矩阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">1.7.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bubble-sort"><span class="toc-number">1.8.1.</span> <span class="toc-text">Bubble sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selection-sort"><span class="toc-number">1.8.2.</span> <span class="toc-text">Selection sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insertion-sort"><span class="toc-number">1.8.3.</span> <span class="toc-text">Insertion sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell-sort"><span class="toc-number">1.8.4.</span> <span class="toc-text">Shell sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge-sort"><span class="toc-number">1.8.5.</span> <span class="toc-text">Merge sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quick-sort"><span class="toc-number">1.8.6.</span> <span class="toc-text">Quick sort</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#time-complexity"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">Time complexity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#optimization"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">Optimization</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#one-sided-recursive-optimization"><span class="toc-number">1.8.6.2.1.</span> <span class="toc-text">One-sided recursive optimization</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#optimization-of-benchmark-value-selection"><span class="toc-number">1.8.6.2.2.</span> <span class="toc-text">Optimization of benchmark value selection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#partition-operation-optimization"><span class="toc-number">1.8.6.2.3.</span> <span class="toc-text">Partition Operation Optimization</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#heapsort"><span class="toc-number">1.8.7.</span> <span class="toc-text">Heapsort</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E9%A1%B6%E5%A0%86"><span class="toc-number">1.8.7.1.</span> <span class="toc-text">大顶堆</span></a></li></ol></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-2023-06-06-数据结构" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      数据结构
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/06/06/2023-06-06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
	  <time datetime="2023-06-06T09:14:13.000Z" itemprop="datePublished">2023-06-06</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/%E6%89%8B%E5%86%8C/" rel="tag">手册</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/06/06/2023-06-06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 5k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 26(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define element type</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define struct of linked list</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define Status</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    ERROR,</span><br><span class="line">    SUCCESS</span><br><span class="line">&#125; Status;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">CreateList_Head</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));     <span class="comment">//创建头结点</span></span><br><span class="line">    L-&gt;next  =<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=s;                          <span class="comment">//插入结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    L = <span class="keyword">new</span> LNode;</span><br><span class="line">    <span class="built_in">CreateList_Head</span>(L);</span><br><span class="line">    <span class="built_in">TraverseList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKSIZE 10;              <span class="comment">//存储空间分配增量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100;    <span class="comment">//存储空间初始分配量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType* base;    <span class="comment">//栈底</span></span><br><span class="line">    ElemType* top;     <span class="comment">//栈顶</span></span><br><span class="line">    <span class="type">int</span> stacksize;          <span class="comment">//当前已分配的空间</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line">Status <span class="title function_">initStack</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S.base = (ElemType *)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!S.base)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack&amp; S, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top - S.base &gt;= S.stacksize)   <span class="comment">//如果栈满就追加空间</span></span><br><span class="line">    &#123;                           <span class="comment">//新增内存空间</span></span><br><span class="line">        S.base = (ElemType*)<span class="built_in">realloc</span>(S.base, (S.stacksize + <span class="number">10</span>) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!S.base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        S.top = S.base + S.stacksize;</span><br><span class="line">        S.stacksize += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++ = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack&amp; S, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote>
<p><strong>根据存储结构划分：1.链式队列	2.循环队列	3.单向队列	4.双端队列</strong></p>
</blockquote>
<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line">&#125;Sequeue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeueInit</span><span class="params">(Sequeue &amp;Top)</span>&#123;<span class="comment">//队列的初始化</span></span><br><span class="line">    Top.front=<span class="number">0</span>;</span><br><span class="line">    Top.rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeueEmpty</span><span class="params">(Sequeue &amp;Top)</span>&#123;<span class="comment">//判队列为空</span></span><br><span class="line">    <span class="keyword">if</span>(Top.rear==Top.front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;队列不为空\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeuePush</span><span class="params">(Sequeue &amp;Top,<span class="type">int</span> m)</span>&#123;<span class="comment">//循环入队列</span></span><br><span class="line">   <span class="keyword">if</span>((Top.rear+<span class="number">1</span>)%MAXSIZE==Top.front)</span><br><span class="line">        &#123;<span class="built_in">printf</span>(<span class="string">&quot;队列已满&quot;</span>);&#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       Top.data[Top.rear]=m;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d已入队\n&quot;</span>,m);</span><br><span class="line">       Top.rear=(Top.rear+<span class="number">1</span>)%MAXSIZE;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeueTop</span><span class="params">(Sequeue &amp;Top)</span><span class="comment">//求队列头部元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列头部元素为%d\n&quot;</span>,Top.data[Top.front]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeuePop</span><span class="params">(Sequeue &amp;Top)</span>&#123;<span class="comment">//循环出队列</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Top.rear==Top.front)</span><br><span class="line">     &#123;<span class="built_in">printf</span>(<span class="string">&quot;队列为空&quot;</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (Top.rear!=Top.front) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;队第%d元素为%d\n&quot;</span>,i,Top.data[Top.front]);</span><br><span class="line">            Top.front=(Top.front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SequeueTopp</span><span class="params">(Sequeue &amp;Top)</span><span class="comment">//求队列头部元素( 返回值)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Top.data[Top.front];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeuePushh</span><span class="params">(Sequeue &amp;Top,<span class="type">int</span> m)</span>&#123;<span class="comment">//不循环入队列</span></span><br><span class="line">    Top.data[Top.rear]=m;</span><br><span class="line">    Top.rear++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">SequeuePopp</span><span class="params">(Sequeue &amp;Top)</span>&#123;<span class="comment">//不循环出队列</span></span><br><span class="line">    <span class="type">int</span> m=Top.data[Top.front];</span><br><span class="line">        Top.front++;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote>
<p><strong>C++：nullptr 专用于初始化空类型指针</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiNode</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType data;</span><br><span class="line">    BiNode *lchild, *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BiTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BiTree</span>( )&#123;</span><br><span class="line">        root = <span class="built_in">Creat</span>(root);	<span class="comment">//构造函数，建立二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">BiTree</span>( )&#123;</span><br><span class="line">        <span class="built_in">Release</span>(root);   <span class="comment">//析构函数，释放各结点的存储空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="built_in">PreOrder</span>(root);   <span class="comment">//前序遍历二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(root);   <span class="comment">//中序遍历二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(root);   <span class="comment">//后序遍历二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LeverOrder</span><span class="params">( )</span></span>; <span class="comment">//层序遍历二叉树</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BiNode &lt;DataType&gt;*<span class="built_in">Creat</span>(BiNode&lt;DataType&gt; *bt); <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>; 		  <span class="comment">//析构函数调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>; 		  <span class="comment">//前序遍历函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>; 		  <span class="comment">//中序遍历函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>; 		  <span class="comment">//后序遍历函数</span></span><br><span class="line">    BiNode&lt;DataType&gt; *root;					     <span class="comment">//指向根结点的头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">BiNode&lt;DataType&gt; *BiTree &lt;DataType&gt;:: <span class="built_in">Creat</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入扩展二叉树的前序遍历序列，每次输入一个字符:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; ch; <span class="comment">//输入结点的数据信息，假设为字符</span></span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) bt = <span class="literal">nullptr</span>; <span class="comment">//建立一棵空树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        bt = <span class="keyword">new</span> BiNode&lt;DataType&gt;;</span><br><span class="line">        bt-&gt;data = ch;</span><br><span class="line">        bt-&gt;lchild = <span class="built_in">Creat</span>(bt-&gt;lchild); <span class="comment">//递归建立左子树</span></span><br><span class="line">        bt-&gt;rchild = <span class="built_in">Creat</span>(bt-&gt;rchild); <span class="comment">//递归建立右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;	<span class="comment">//前序遍历</span></span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">PreOrder</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>; </span><br><span class="line">    cout &lt;&lt; bt-&gt;data; 	  </span><br><span class="line">    <span class="built_in">PreOrder</span>(bt-&gt;lchild); </span><br><span class="line">    <span class="built_in">PreOrder</span>(bt-&gt;rchild); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;	<span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">InOrder</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;lchild); </span><br><span class="line">        cout &lt;&lt; bt-&gt;data; </span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;	<span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">PostOrder</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;lchild);</span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;rchild);</span><br><span class="line">        cout &lt;&lt; bt-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;	<span class="comment">//层次遍历</span></span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">LeverOrder</span>( )</span><br><span class="line">&#123;</span><br><span class="line">    BiNode&lt;DataType&gt; *Q[<span class="number">100</span>], *q = <span class="literal">nullptr</span>; <span class="comment">//顺序队列</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>; <span class="comment">//队列初始化</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">//二叉树为空，算法结束</span></span><br><span class="line">    Q[++rear] = root; <span class="comment">//根指针入队</span></span><br><span class="line">    <span class="keyword">while</span> (front != rear) <span class="comment">//当队列非空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = Q[++front]; <span class="comment">//出队</span></span><br><span class="line">        cout &lt;&lt; q-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;lchild != <span class="literal">nullptr</span>) Q[++rear] = q-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;rchild != <span class="literal">nullptr</span>) Q[++rear] = q-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">Release</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Release</span>(bt-&gt;lchild); <span class="comment">//释放左子树</span></span><br><span class="line">        <span class="built_in">Release</span>(bt-&gt;rchild); <span class="comment">//释放右子树</span></span><br><span class="line">        <span class="keyword">delete</span> bt; <span class="comment">//释放根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)	<span class="comment">//如果是空，则直接返回空vector</span></span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        queue&lt;TreeNode*&gt; q; 	<span class="comment">//队列存储，进行层次遍历</span></span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        TreeNode* cur;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//记录二叉树的某一行</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; row;  </span><br><span class="line">            <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">//因先进入的是根节点，故每层节点多少，队列大小就是多少</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                row.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="comment">//若是左右孩子存在，则存入左右孩子作为下一个层次</span></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每一层加入输出</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(row); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="avl-tree"><a href="#AVL-Tree" class="headerlink" title="AVL Tree"></a>AVL Tree</h3><blockquote>
<p>AVL树（Adelson-Velsky and Landis Tree）是CS中最早被发明的自平衡二叉查找树。</p>
</blockquote>
<p>一棵AVL树有如下必要条件：</p>
<ul>
<li>必须是二叉查找树</li>
<li>每个节点的左子树和右子树的高度差至多为1</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">AVL Tree Visualzation</a> <strong>可视化演示</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AVLnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> key;    <span class="comment">//值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLnode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLnode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> height;     <span class="comment">//高度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAVL</span><span class="params">(avlNode *node, <span class="type">int</span> level)</span>	<span class="comment">//树尖向左打印</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printAVL(node-&gt;right, level + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, node-&gt;key);</span><br><span class="line"></span><br><span class="line">        printAVL(node-&gt;left, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平衡化操作"><a href="#平衡化操作" class="headerlink" title="平衡化操作"></a>平衡化操作</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/438604092">平衡二叉树 — 优雅的进行旋转</a></p>
<h5 id="ll型"><a href="#LL型" class="headerlink" title="LL型"></a>LL型</h5><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131014059.webp" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">avlNode *<span class="title function_">rightRotate</span><span class="params">(avlNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    avlNode *L = T-&gt;left;</span><br><span class="line">    avlNode *T3 = L-&gt;right;</span><br><span class="line"></span><br><span class="line">    L-&gt;right = T;</span><br><span class="line">    T-&gt;left = T3;</span><br><span class="line"></span><br><span class="line">    T-&gt;height = (Max(nodeHeight(T-&gt;left), nodeHeight(T-&gt;right)) + <span class="number">1</span>);</span><br><span class="line">    L-&gt;height = (Max(nodeHeight(L-&gt;left), nodeHeight(L-&gt;right)) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="rr型"><a href="#RR型" class="headerlink" title="RR型"></a>RR型</h5><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131019717.webp" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">avlNode *<span class="title function_">leftRotate</span><span class="params">(avlNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    avlNode *R= T-&gt;right;</span><br><span class="line">    avlNode *T3 = R-&gt;left;</span><br><span class="line"></span><br><span class="line">    R-&gt;left = z;</span><br><span class="line">    T-&gt;right = T3;</span><br><span class="line"></span><br><span class="line">    T-&gt;height = (Max(nodeHeight(T-&gt;left), nodeHeight(T-&gt;right)) + <span class="number">1</span>);</span><br><span class="line">    R-&gt;height = (Max(nodeHeight(R-&gt;left), nodeHeight(R-&gt;right)) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="lr型"><a href="#LR型" class="headerlink" title="LR型"></a>LR型</h5><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131021410.jpeg" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avlNode *<span class="title function_">LeftRightRotate</span><span class="params">(avlNode *z)</span>&#123;</span><br><span class="line">    T-&gt;left = leftRotate(T-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> (rightRotate(T));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="rl型"><a href="#RL型" class="headerlink" title="RL型"></a>RL型</h5><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131023406.webp" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avlNode *<span class="title function_">RightLeftRotate</span><span class="params">(avlNode *T)</span>&#123;</span><br><span class="line">    T-&gt;right = rightRotate(T-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (leftRotate(T));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><blockquote>
<p>​		二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree）。</p>
</blockquote>
<p>一棵空树或者具有下列性质的二叉树：</p>
<ul>
<li>若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意结点的右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>任意结点的左、右子树也分别为二叉查找树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><blockquote>
<p>红黑树（Red Black Tree） 是一种自平衡二叉查找树</p>
</blockquote>
<p>红黑树满足以下特征：</p>
<ul>
<li>节点分为红色或者黑色；</li>
<li>根节点必为黑色；</li>
<li>叶子节点都为黑色，且为null；</li>
<li>连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）；</li>
<li>从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点；</li>
<li>新加入到红黑树的节点为红色节点；(推断)</li>
</ul>
<p><em>类比234树——4阶B树</em></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeNode</span> <span class="comment">//定义边表结点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//邻接点域</span></span><br><span class="line">    EdgeNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexNode</span> <span class="comment">//定义顶点表结点</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType vertex;</span><br><span class="line">    EdgeNode *firstEdge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">10</span>; <span class="comment">//图的最多顶点数</span></span><br><span class="line"><span class="type">int</span> visited[MaxSize] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALGraph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ALGraph</span>(DataType a[ ], <span class="type">int</span> n, <span class="type">int</span> e); <span class="comment">//构造函数，建立n个顶点e条边的图</span></span><br><span class="line">    ~<span class="built_in">ALGraph</span>( ); <span class="comment">//析构函数，释放邻接表各边表结点的存储空间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>; <span class="comment">//深度优先遍历图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>; <span class="comment">//广度优先遍历图</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VertexNode&lt;DataType&gt; adjlist[MaxSize]; <span class="comment">//存放顶点表的数组</span></span><br><span class="line">    <span class="type">int</span> vertexNum, edgeNum; <span class="comment">//图的顶点数和边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">ALGraph&lt;DataType&gt; :: <span class="built_in">ALGraph</span>(DataType a[ ], <span class="type">int</span> n, <span class="type">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    EdgeNode *s = <span class="literal">nullptr</span>;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) <span class="comment">//输入顶点信息，初始化顶点表</span></span><br><span class="line">    &#123;</span><br><span class="line">        adjlist[i].vertex = a[i];</span><br><span class="line">        adjlist[i].firstEdge = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; edgeNum; k++) <span class="comment">//依次输入每一条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入边所依附的两个顶点的编号：&quot;</span>;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j; <span class="comment">//输入边所依附的两个顶点的编号</span></span><br><span class="line">        s = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">        s-&gt;adjvex = j; <span class="comment">//生成一个边表结点s</span></span><br><span class="line">        s-&gt;next = adjlist[i].firstEdge; <span class="comment">//将结点s插入到第i个边表的表头</span></span><br><span class="line">        adjlist[i].firstEdge = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">ALGraph&lt;DataType&gt;  :: ~<span class="built_in">ALGraph</span>( )</span><br><span class="line">&#123;</span><br><span class="line">    EdgeNode *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = q = adjlist[i].firstEdge;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> q;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> ALGraph&lt;DataType&gt;  :: <span class="built_in">DFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    EdgeNode *p = <span class="literal">NULL</span>;</span><br><span class="line">    cout &lt;&lt; adjlist[v].vertex;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    p = adjlist[v].firstEdge; <span class="comment">//工作指针p指向顶点v的边表</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) <span class="comment">//依次搜索顶点v的邻接点</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span> (visited[j] == <span class="number">0</span>) <span class="built_in">DFTraverse</span>(j);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> ALGraph&lt;DataType&gt; :: <span class="built_in">BFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w, j, Q[MaxSize]; <span class="comment">//采用顺序队列</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>; <span class="comment">//初始化队列</span></span><br><span class="line">    EdgeNode *p = <span class="literal">nullptr</span>;</span><br><span class="line">    cout &lt;&lt; adjlist[v].vertex;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    Q[++rear] = v; <span class="comment">//被访问顶点入队</span></span><br><span class="line">    <span class="keyword">while</span> (front != rear) <span class="comment">//当队列非空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        w = Q[++front];</span><br><span class="line">        p = adjlist[w].firstEdge; <span class="comment">//工作指针p指向顶点v的边表</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            j = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span> (visited[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; adjlist[j].vertex;</span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//测试数据是图6-20(a)，边是(0 1)(0 3)(0 4)(1 2)(2 4)(3 2)(3 4)</span></span><br><span class="line">    <span class="type">char</span> ch[ ] = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function">ALGraph&lt;<span class="type">char</span>&gt; <span class="title">ALG</span><span class="params">(ch, <span class="number">5</span>, <span class="number">6</span>)</span></span>; <span class="comment">//建立具有5个顶点6条边的有向图</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;深度优先遍历序列是：&quot;</span>;</span><br><span class="line">    ALG.<span class="built_in">DFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;广度优先遍历序列是：&quot;</span>;</span><br><span class="line">    ALG.<span class="built_in">BFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************</span></span><br><span class="line"><span class="comment">邻接矩阵类MGraph的使用范例</span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">10</span>; <span class="comment">//图中最多顶点个数</span></span><br><span class="line"><span class="type">int</span> visited[MaxSize] = &#123;<span class="number">0</span>&#125;; <span class="comment">//全局数组变量visited初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MGraph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MGraph</span>(DataType a[ ], <span class="type">int</span> n, <span class="type">int</span> e); <span class="comment">//构造函数，建立具有n个顶点e条边的图</span></span><br><span class="line">    ~<span class="built_in">MGraph</span>( ) &#123; &#125;; <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>; <span class="comment">//深度优先遍历图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>; <span class="comment">//广度优先遍历图</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType vertex[MaxSize]; <span class="comment">//存放图中顶点的数组</span></span><br><span class="line">    <span class="type">int</span> edge[MaxSize][MaxSize]; <span class="comment">//存放图中边的数组</span></span><br><span class="line">    <span class="type">int</span> vertexNum, edgeNum; <span class="comment">//图的顶点数和边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">MGraph &lt;DataType&gt;:: <span class="built_in">MGraph</span>(DataType a[ ], <span class="type">int</span> n, <span class="type">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) <span class="comment">//存储顶点</span></span><br><span class="line">        vertex[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">            edge[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; edgeNum; k++) <span class="comment">//依次输入每一条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入边依附的两个顶点的编号：&quot;</span>;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j; <span class="comment">//输入边依附的两个顶点的编号</span></span><br><span class="line">        edge[i][j] = <span class="number">1</span>;</span><br><span class="line">        edge[j][i] = <span class="number">1</span>; <span class="comment">//置有边标志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> MGraph &lt;DataType&gt;:: <span class="built_in">DFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; vertex[v];</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">        <span class="keyword">if</span> (edge[v][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) <span class="built_in">DFTraverse</span>( j );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> MGraph &lt;DataType&gt;:: <span class="built_in">BFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w, j, Q[MaxSize]; <span class="comment">//采用顺序队列</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>; <span class="comment">//初始化队列</span></span><br><span class="line">    cout &lt;&lt; vertex[v];</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    Q[++rear] = v; <span class="comment">//被访问顶点入队</span></span><br><span class="line">    <span class="keyword">while</span> (front != rear) <span class="comment">//当队列非空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        w = Q[++front]; <span class="comment">//将队头元素出队并送到v中</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">            <span class="keyword">if</span> (edge[w][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; vertex[j];</span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch[ ]= &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">/* 测试数据六条边是：(0 1)(0 2)(0 3)(0 4)(1 2)(2 4) */</span></span><br><span class="line">    MGraph&lt;<span class="type">char</span>&gt; MG&#123;ch, <span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">//建立具有5个顶点6条边的无向图</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;深度优先遍历序列是：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    MG.<span class="built_in">DFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;广度优先遍历序列是：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    MG.<span class="built_in">BFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">经典排序算法</a></p>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210221013239.png" alt="img"></p>
<h3 id="bubble-sort"><a href="#Bubble-sort" class="headerlink" title="Bubble sort"></a>Bubble sort</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                                <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123; <span class="number">61</span>, <span class="number">17</span>, <span class="number">29</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">60</span>, <span class="number">72</span>, <span class="number">21</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">62</span> &#125;;</span><br><span class="line">        <span class="type">int</span> len = (<span class="type">int</span>) <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">        <span class="built_in">bubble_sort</span>(arr, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="type">float</span> arrf[] = &#123; <span class="number">17.5</span>, <span class="number">19.1</span>, <span class="number">0.6</span>, <span class="number">1.9</span>, <span class="number">10.5</span>, <span class="number">12.4</span>, <span class="number">3.8</span>, <span class="number">19.7</span>, <span class="number">1.5</span>, <span class="number">25.4</span>, <span class="number">28.6</span>, <span class="number">4.4</span>, <span class="number">23.8</span>, <span class="number">5.4</span> &#125;;</span><br><span class="line">        len = (<span class="type">float</span>) <span class="built_in">sizeof</span>(arrf) / <span class="built_in">sizeof</span>(*arrf);</span><br><span class="line">        <span class="built_in">bubble_sort</span>(arrf, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                cout &lt;&lt; arrf[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="selection-sort"><a href="#Selection-sort" class="headerlink" title="Selection sort"></a>Selection sort</h3><p>Selection sort is a simple and intuitive sorting algorithm that is O(n²) time complex no matter what data goes in. So when using it, the smaller the data size, the better. The only advantage is that it doesn’t take up extra memory space.</p>
<p><strong>算法步骤</strong></p>
<ol>
<li>First, find the smallest (large) element in the unsorted sequence and store it at the beginning of the sorted sequence.</li>
<li>Then find the smallest (large) element from the remaining unsorted elements and put it at the end of the sorted sequence.</li>
<li>Repeat the second step until all elements are sorted.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">                min = j;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="insertion-sort"><a href="#Insertion-sort" class="headerlink" title="Insertion sort"></a>Insertion sort</h3><p>The code implementation of insertion sort is not as simple and brutal as bubble sort and selection sort, but its principle should be the easiest to understand, because anyone who has played poker should be able to understand it in seconds. Insertion sort is one of the simplest and most intuitive sorting algorithms. It works by constructing an ordered sequence, and for unsorted data, scanning backward and forward in the sorted sequence to find the appropriate position and insert it.</p>
<p>Insertion sort, like bubble sort, also has an optimization algorithm called split-half insertion.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> key=arr[i];</span><br><span class="line">        <span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((j&gt;=<span class="number">0</span>) &amp;&amp; (key&lt;arr[j]))&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>]=key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shell-sort"><a href="#Shell-sort" class="headerlink" title="Shell sort"></a>Shell sort</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(T array[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; length / <span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(array[j], array[j - h]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="merge-sort"><a href="#Merge-sort" class="headerlink" title="Merge sort"></a>Merge sort</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代版</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    T *a = arr;</span><br><span class="line">    T *b = <span class="keyword">new</span> T[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line">            <span class="type">int</span> low = start, mid = <span class="built_in">min</span>(start + seg, len), high = <span class="built_in">min</span>(start + seg + seg, len);</span><br><span class="line">            <span class="type">int</span> k = low;</span><br><span class="line">            <span class="type">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="type">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        T *temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;Array, <span class="type">int</span> front, <span class="type">int</span> mid, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// preconditions:</span></span><br><span class="line">    <span class="comment">// Array[front...mid] is sorted</span></span><br><span class="line">    <span class="comment">// Array[mid+1 ... end] is sorted</span></span><br><span class="line">    <span class="comment">// Copy Array[front ... mid] to LeftSubArray</span></span><br><span class="line">    <span class="comment">// Copy Array[mid+1 ... end] to RightSubArray</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">LeftSubArray</span><span class="params">(Array.begin() + front, Array.begin() + mid + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">RightSubArray</span><span class="params">(Array.begin() + mid + <span class="number">1</span>, Array.begin() + end + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> idxLeft = <span class="number">0</span>, idxRight = <span class="number">0</span>;</span><br><span class="line">    LeftSubArray.<span class="built_in">insert</span>(LeftSubArray.<span class="built_in">end</span>(), numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">    RightSubArray.<span class="built_in">insert</span>(RightSubArray.<span class="built_in">end</span>(), numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">    <span class="comment">// Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = front; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LeftSubArray[idxLeft] &lt; RightSubArray[idxRight]) &#123;</span><br><span class="line">            Array[i] = LeftSubArray[idxLeft];</span><br><span class="line">            idxLeft++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Array[i] = RightSubArray[idxRight];</span><br><span class="line">            idxRight++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;Array, <span class="type">int</span> front, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (front + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(Array, front, mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(Array, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="built_in">Merge</span>(Array, front, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="quick-sort"><a href="#Quick-sort" class="headerlink" title="Quick sort"></a>Quick sort</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort_recursive</span><span class="params">(T arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    T mid = arr[end];</span><br><span class="line">    <span class="type">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换</span></span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right) <span class="comment">//试图在左侧找到一个比枢纽元更大的元素</span></span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right) <span class="comment">//试图在右侧找到一个比枢纽元更小的元素</span></span><br><span class="line">            right--;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[left], arr[right]); <span class="comment">//交换元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[left], arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>​		During the partition process, both the head and tail pointers are scanned cyclically to the last position where the base value was placed. Thus, the head and tail pointer scans together are equivalent to scanning the entire region of the array to be sorted. Therefore, we can conclude that the time complexity of a single partition operation is O(n). The formula for the overall time complexity: T(n) &#x3D; n + T(L) + T(R).</p>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181007848.jpeg" alt="img"></p>
<p>Time complexity：$O(n\log_{2}{n})$</p>
<h4 id="optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h4><h5 id="one-sided-recursive-optimization"><a href="#One-sided-recursive-optimization" class="headerlink" title="One-sided recursive optimization"></a>One-sided recursive optimization</h5><p>​		Mode：when this layer has finished the partition operation, let this layer continue to complete the partition operation to the left of the base value, while the sorting work to the right of the base value is left to the next layer of recursive functions to handle.</p>
<img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181111010.jpeg" alt="img" style="zoom:25%;">

<p>function is called 4 times. </p>
<p>Without the method, the actual number is 7.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 进行一轮 partition 操作</span></span><br><span class="line">        <span class="comment">// 获得基准值的位置</span></span><br><span class="line">        <span class="type">int</span> ind = partition(arr, l, r);</span><br><span class="line">        <span class="comment">// 右侧正常调用递归函数 </span></span><br><span class="line">        quick_sort(arr, ind + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 用本层处理左侧的排序</span></span><br><span class="line">        r = ind - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="optimization-of-benchmark-value-selection"><a href="#Optimization-of-benchmark-value-selection" class="headerlink" title="Optimization of benchmark value selection"></a>Optimization of benchmark value selection</h5><p><em>three-point middle method</em> is to take the three values of the head, tail and middle elements of the sorting interval in each round, and then use the middle value after they are sorted as the base value for the current round.For example, suppose the three values of this round are 2, 9 and 7, and the middle value is 7, so the base value of this round is 7.</p>
<h5 id="partition-operation-optimization"><a href="#Partition-Operation-Optimization" class="headerlink" title="Partition Operation Optimization"></a>Partition Operation Optimization</h5><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181129919.png" alt="img" style="zoom: 25%;">

<p>Let the head pointer look backward for red elements and the tail pointer look forward for green elements, then swap the elements pointed by the head and tail pointers and repeat the process until the head and tail pointers are interleaved and stop. </p>
<h3 id="heapsort"><a href="#Heapsort" class="headerlink" title="Heapsort"></a>Heapsort</h3><p>经典问题：蚂蚁问题</p>
<p>假设现在有一个水平面，上面有 8 只蚂蚁排成一排。方便起见，我们给所有的蚂蚁从左到右依次编号，编号为 1 到 8。从 0 秒开始，红色蚂蚁向左爬，蓝色蚂蚁向右爬，爬行的速度都是 1m&#x2F;s。如果有 2 只蚂蚁迎面碰到以后，这 2 只蚂蚁不会做任何的感情交流，而会立刻掉头向相反方向继续爬行。而爬行到桌子边沿的蚂蚁，会从桌子上掉下去。问：有哪些蚂蚁会从左边掉下去，又有哪些蚂蚁会从右边掉下去？</p>
<img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181155170.jpeg" alt="img" style="zoom:25%;">

<h4 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h4><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181328092.png" alt="img" style="zoom:25%;">




      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://dezeem.github.io/2023/06/06/2023-06-06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构" target="_blank" rel="external">http://dezeem.github.io/2023/06/06/2023-06-06-数据结构/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/Dezeem" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/Dezeem" target="_blank"><span class="text-dark">少先队长</span><small class="ml-1x">Student &amp; Designer</small></a></h3>
        <div>互联网流浪公民</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2024/01/16/2024-01-15-C++%E8%BF%9B%E9%98%B6/" title="Effectivate C++"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/10/05/2022-10-04-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" title="刷题笔记"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Dezeem" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2024 Dezeem
        
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>