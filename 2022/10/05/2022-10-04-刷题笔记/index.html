<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>刷题笔记 | Dezeem&#39;log</title>
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <!-- CSS -->
  
<link rel="stylesheet" href="/css/style.css">

  
  <!-- KaTeX for LaTeX support -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script>
  
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  
  <!-- Theme JavaScript -->
  
<script src="/js/main.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Dezeem'log" type="application/atom+xml">
</head>
<body>
  <header class="header">
  <div class="container">
    <div class="header-inner">
      <div class="logo">
        <a href="/">Dezeem&#39;log</a>
      </div>
      
      <nav class="main-nav">
        <ul>
          
            <li><a href="/">Home</a></li>
          
            <li><a href="/archives">Archives</a></li>
          
            <li><a href="/categories">Categories</a></li>
          
            <li><a href="/tags">Tags</a></li>
          
            <li><a href="/about">About</a></li>
          
        </ul>
      </nav>
      
      <div class="header-right">
        <!-- 语言切换 -->
        <div class="language-switch">
          <a href="#" class="lang-btn" data-lang="zh-CN">中文</a>
          <a href="#" class="lang-btn" data-lang="en">EN</a>
        </div>
        
        <!-- 暗黑模式切换 -->
        <div class="theme-switch">
          <button id="theme-toggle" aria-label="Toggle Dark Mode">
            <i class="fas fa-moon dark-icon"></i>
            <i class="fas fa-sun light-icon"></i>
          </button>
        </div>
        
        <!-- 搜索按钮 -->
        <div class="search-btn">
          <i class="fas fa-search"></i>
        </div>
      </div>
    </div>
  </div>
  
  <!-- 搜索框 -->
  <div class="search-container">
    <div class="container">
      <form class="search-form">
        <input type="text" class="search-input" placeholder="搜索">
        <button type="submit" class="search-submit">
          <i class="fas fa-search"></i>
        </button>
      </form>
      <button class="search-close">
        <i class="fas fa-times"></i>
      </button>
    </div>
  </div>
</header>
  
  <main class="main-content">
    <div class="post-container">
  <div class="container">
    <div class="post-inner">
      <!-- 文章主体 -->
      <div class="post-main">
        <article class="post-content">
          <header class="post-header">
            <h1 class="post-title">刷题笔记</h1>
            <div class="post-meta">
              <time class="post-date" datetime="2022-10-04T20:24:00.000Z">
                2022-10-05
              </time>
              
                <span class="post-categories">
                  
                    <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">算法</a>
                  
                </span>
              
            </div>
          </header>
          
          <div class="post-body">
            <h1 id="洛谷"><a class="markdownIt-Anchor" href="#洛谷"></a> 洛谷</h1>
<h2 id="p1059-noip2006-普及组-明明的随机数"><a class="markdownIt-Anchor" href="#p1059-noip2006-普及组-明明的随机数"></a> P1059 [NOIP2006 普及组] 明明的随机数</h2>
<blockquote>
<p>数组去重排序</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;cin &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> a[m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)  cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a, a + m);  <span class="comment">// 排序</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">unique</span>(a, a + m) - a;  <span class="comment">//去重</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//unique(a, a+m)的返回值是a[m]的地址</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="牛客"><a class="markdownIt-Anchor" href="#牛客"></a> 牛客</h1>
<h3 id="bm1-反转链表"><a class="markdownIt-Anchor" href="#bm1-反转链表"></a> BM1 反转链表</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pHead || !pHead-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ListNode *p = pHead,*r = pHead-&gt;next, *q = p;</span><br><span class="line">        <span class="keyword">while</span>(r-&gt;next)&#123;</span><br><span class="line">            p-&gt;next = r-&gt;next;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            q = r;</span><br><span class="line">            r = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        r-&gt;next = q;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pHead = r;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二分查找排序"><a class="markdownIt-Anchor" href="#二分查找排序"></a> 二分查找/排序</h2>
<h3 id="bm17-二分查找"><a class="markdownIt-Anchor" href="#bm17-二分查找"></a> BM17 二分查找</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> high = nums.<span class="built_in">size</span>(), mid = high / <span class="number">2</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!high)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= high)&#123;</span><br><span class="line">            mid = (left + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="bm18-二维数组中的查找"><a class="markdownIt-Anchor" href="#bm18-二维数组中的查找"></a> BM18 二维数组中的查找</h3>
<p>​		在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p>
<p>[[1,2,8,9],<br>
[2,4,9,12],<br>
[4,7,10,13],<br>
[6,8,11,15]]</p>
<p>给定 target = 7，返回 true；给定 target = 3，返回 false。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; array,<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m, n, x, y;</span><br><span class="line">        m = array.<span class="built_in">size</span>();	<span class="comment">//行数</span></span><br><span class="line">        n = array[<span class="number">0</span>].<span class="built_in">size</span>();	<span class="comment">//列数</span></span><br><span class="line">        x = m<span class="number">-1</span>;y = <span class="number">0</span>;	<span class="comment">//坐标定在左下角</span></span><br><span class="line">        <span class="keyword">while</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &lt;= n<span class="number">-1</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(target &lt; array[x][y])</span><br><span class="line">                   x--;	<span class="comment">//遇小上移</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[x][y])</span><br><span class="line">                   y++;	<span class="comment">//遇大右移</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="bm19-寻找峰值"><a class="markdownIt-Anchor" href="#bm19-寻找峰值"></a> BM19 寻找峰值</h3>
<p>​		给定一个长度为n的数组nums，请找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。</p>
<p>1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于</p>
<p>2.假设 nums[-1] = nums[n] = -\infty−∞</p>
<p>3.对于所有有效的 i 都有 nums[i] != nums[i + 1]</p>
<p>4.你可以使用O(logN)的时间复杂度实现此问题吗？</p>
<p>输入[2,4,1,2,7,8,4]时，会形成两个山峰，一个是索引为1，峰值为4的山峰，另一个是索引为5，峰值为8的山峰。</p>
<p><code>二分查找</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分法 fast-template</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//右边是往下，不一定有坡峰</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="comment">//右边是往上，一定能找到波峰</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其中一个波峰</span></span><br><span class="line">        <span class="keyword">return</span> right;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="bm20-数组中的逆序对"><a class="markdownIt-Anchor" href="#bm20-数组中的逆序对"></a> BM20 数组中的逆序对</h3>
<p><strong>描述：</strong></p>
<p>数组中两个数，如果前一个数字大于后面的数字，则这两数组成一个逆序对。</p>
<p>输入一个数组,求出这个数组中的逆序对的总数P。输出P mod 1000000007的结果。</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
<p>输入描述：题目保证输入的数组中没有的相同的数字</p>
<table>
<thead>
<tr>
<th style="text-align:center">输入示例</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[1,2,3,4,5,6,7,0]</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">[1,2,3]</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<blockquote>
<p>归并排序</p>
</blockquote>
<img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202208191238848.gif" alt="img">
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> kmod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 在最外层开辟数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(data.size())</span></span>;</span><br><span class="line">        <span class="built_in">merge_sort__</span>(data, tmp, <span class="number">0</span>, data.<span class="built_in">size</span>() - <span class="number">1</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge_sort__</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, vector&lt;<span class="type">int</span>&gt; &amp;tmp, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> &amp;ret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">merge_sort__</span>(arr, tmp, l, mid, ret);</span><br><span class="line">        <span class="built_in">merge_sort__</span>(arr, tmp, mid + <span class="number">1</span>, r, ret);</span><br><span class="line">        <span class="built_in">merge__</span>(arr, tmp, l, mid, r, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge__</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, vector&lt;<span class="type">int</span>&gt; &amp;tmp, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r, <span class="type">int</span> &amp;ret)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                tmp[k++] = arr[j++];</span><br><span class="line">                ret += (mid - i + <span class="number">1</span>);</span><br><span class="line">                ret %= kmod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>, i = l; i &lt;= r; ++i, ++k)</span><br><span class="line">            arr[i] = tmp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm21-旋转数组的最小数字"><a class="markdownIt-Anchor" href="#bm21-旋转数组的最小数字"></a> BM21 旋转数组的最小数字</h3>
<p><strong>描述</strong></p>
<p>有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p>
<p>要求：空间复杂度：O(1)，时间复杂度：O(logn)</p>
<p>输入：[3,4,5,1,2]	返回值：1</p>
<p>输入：[3,100,200,3]	返回值：3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = rotateArray.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//最小的数字在mid右边</span></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[right]) </span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//无法判断，一个一个试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] == rotateArray[right]) </span><br><span class="line">                right--;</span><br><span class="line">            <span class="comment">//最小数字要么是mid要么在mid左边</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rotateArray.<span class="built_in">size</span>(); i++) </span><br><span class="line">            <span class="comment">//每次维护最小值</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, rotateArray[i]); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm22-比较版本号"><a class="markdownIt-Anchor" href="#bm22-比较版本号"></a> BM22 比较版本号</h3>
<p><strong>描述:</strong></p>
<p>版本号是由修订号组成，修订号与修订号之间由一个&quot;.&quot;连接。1个修订号可能有多位数字组成，修订号可能包含前导0，且是合法的。例如，1.02.11，0.1，0.2都是合法的版本号。每个版本号至少包含1个修订号。修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。</p>
<p><strong>比较规则：</strong></p>
<ul>
<li>
<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如&quot;0.1&quot;和&quot;0.01&quot;的版本号是相等的</p>
</li>
<li>
<p>如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，“1.1&quot;的版本号小于&quot;1.1.1”。因为&quot;1.1&quot;的版本号相当于&quot;1.1.0&quot;，第3位修订号的下标为0，小于1</p>
</li>
<li>
<p>version1 &gt; version2 返回1，如果 version1 &lt; version2 返回-1，不然返回0.</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;1.1&quot;,&quot;1.01&quot;		返回值：0</span><br><span class="line">说明：version2忽略前导0，为&quot;1.1&quot;，和version相同，返回0 </span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1 = version1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n2 = version2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//直到某个字符串结束</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n1 || j &lt; n2)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> num1 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从下一个点前截取数字</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; n1 &amp;&amp; version1[i] != <span class="string">&#x27;.&#x27;</span>)&#123; </span><br><span class="line">                num1 = num1 * <span class="number">10</span> + (version1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳过点</span></span><br><span class="line">            i++; </span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从下一个点前截取数字</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n2 &amp;&amp; version2[j] != <span class="string">&#x27;.&#x27;</span>)&#123; </span><br><span class="line">                num2 = num2 * <span class="number">10</span> + (version2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳过点</span></span><br><span class="line">            j++; </span><br><span class="line">            <span class="comment">//比较数字大小</span></span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num1 &lt; num2)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//版本号相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h2>
<h3 id="bm27-按之字形顺序打印二叉树"><a class="markdownIt-Anchor" href="#bm27-按之字形顺序打印二叉树"></a> BM27 按之字形顺序打印二叉树</h3>
<p><strong>翻转数组！！！</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">reverse</span>(row.<span class="built_in">begin</span>(), row.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p><em>栈方法</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* pRoot) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>)   <span class="comment">//如果是空，则直接返回空vector</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        stack&lt;TreeNode*&gt; q, q2;     <span class="comment">//队列存储，进行层次遍历</span></span><br><span class="line">        q.<span class="built_in">push</span>(pRoot);</span><br><span class="line">        TreeNode* cur;</span><br><span class="line">        <span class="type">int</span> tag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() || !q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">//记录二叉树的某一行</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; row;</span><br><span class="line">            <span class="type">int</span> n = tag ? q.<span class="built_in">size</span>() : q2.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">//因先进入的是根节点，故每层节点多少，队列大小就是多少</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                cur = (tag) ? q.<span class="built_in">top</span>() : q2.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span> (tag)  q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span>  q2.<span class="built_in">pop</span>();</span><br><span class="line">                row.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="comment">//若是左右孩子存在，则存入左右孩子作为下一个层次</span></span><br><span class="line">                <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;left)</span><br><span class="line">                        q2.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;right)</span><br><span class="line">                        q2.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;right)</span><br><span class="line">                        q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;left)</span><br><span class="line">                        q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tag = !tag;</span><br><span class="line">            <span class="comment">//每一层加入输出</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm28-二叉树的最大深度"><a class="markdownIt-Anchor" href="#bm28-二叉树的最大深度"></a> BM28 二叉树的最大深度</h3>
<p>求给定二叉树的最大深度，深度是指树的根节点到任一叶子节点路径上节点的数量。</p>
<p>最大深度是所有叶子节点的深度的最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param root TreeNode类</span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm29-二叉树中和为某一值的路径一"><a class="markdownIt-Anchor" href="#bm29-二叉树中和为某一值的路径一"></a> BM29 二叉树中和为某一值的路径(一)</h3>
<p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p>
<ol>
<li>
<p>该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点</p>
</li>
<li>
<p>叶子节点是指没有子节点的节点</p>
</li>
<li>
<p>路径只能从父节点到子节点，不能从子节点到父节点</p>
</li>
<li>
<p>总节点数目为n</p>
</li>
</ol>
<p><em>递归</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点，且路径和为sum</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span> &amp;&amp; sum - root-&gt;val == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归进入子节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="堆栈队列"><a class="markdownIt-Anchor" href="#堆栈队列"></a> 堆/栈/队列</h2>
<h3 id="bm42-用两个栈实现队列"><a class="markdownIt-Anchor" href="#bm42-用两个栈实现队列"></a> BM42 用两个栈实现队列</h3>
<p>保证操作合法，即保证pop操作时队列内已有元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">                stack1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> node = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm43-包含min函数的栈"><a class="markdownIt-Anchor" href="#bm43-包含min函数的栈"></a> BM43 包含min函数的栈</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(value);</span><br><span class="line">        <span class="keyword">if</span>(s2.<span class="built_in">empty</span>() || s2.<span class="built_in">top</span>() &gt; value)&#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(s2.<span class="built_in">top</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">pop</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm44-有效括号序列"><a class="markdownIt-Anchor" href="#bm44-有效括号序列"></a> BM44 有效括号序列</h3>
<p>给出一个仅包含字符’(‘,’)‘,’{‘,’}‘,’[‘和’]',的字符串，判断给出的字符串是否是合法的括号序列<br>
括号必须以正确的顺序关闭，&quot;()“和”()[]{}“都是合法的括号序列，但”(]“和”([)]&quot;不合法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//辅助栈</span></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st; </span><br><span class="line">        <span class="comment">//遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)&#123; </span><br><span class="line">            <span class="comment">//遇到左小括号</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) </span><br><span class="line">                <span class="comment">//期待遇到右小括号</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>); </span><br><span class="line">            <span class="comment">//遇到左中括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;[&#x27;</span>) </span><br><span class="line">                <span class="comment">//期待遇到右中括号</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>); </span><br><span class="line">            <span class="comment">//遇到左打括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="comment">//期待遇到右打括号 </span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>); </span><br><span class="line">            <span class="comment">//必须有左括号的情况下才能遇到右括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//右括号匹配则弹出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st.<span class="built_in">top</span>() == s[i]) </span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈中是否还有元素</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm45-滑动窗口的最大值"><a class="markdownIt-Anchor" href="#bm45-滑动窗口的最大值"></a> BM45 滑动窗口的最大值</h3>
<ol>
<li>遍历数组的每一个元素，</li>
<li>如果容器为空，则直接将当前元素加入到容器中。</li>
<li>如果容器不为空，则让当前元素和容器的最后一个元素比较，如果大于，则将容器的最后一个元素删除，然后继续将当前元素和容器的最后一个元素比较</li>
<li>如果当前元素小于容器的最后一个元素，则直接将当前元素加入到容器的末尾</li>
<li>如果容器头部的元素已经不属于当前窗口的边界，则应该将头部元素删除</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxInWindows</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; num, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">size</span>() == <span class="number">0</span> || size &lt; <span class="number">1</span> || num.<span class="built_in">size</span>() &lt; size) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="type">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">           deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">               <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; num[dq.<span class="built_in">back</span>()] &lt; num[i]) &#123;</span><br><span class="line">                   dq.<span class="built_in">pop_back</span>();</span><br><span class="line">               &#125;</span><br><span class="line">               dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">               <span class="comment">// 判断队列的头部的下标是否过期</span></span><br><span class="line">               <span class="keyword">if</span> (dq.<span class="built_in">front</span>() + size &lt;= i) &#123;</span><br><span class="line">                   dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否形成了窗口</span></span><br><span class="line">               <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= size) &#123;</span><br><span class="line">                   ret.<span class="built_in">push_back</span>(num[dq.<span class="built_in">front</span>()]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ret; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm46-最小的k个数"><a class="markdownIt-Anchor" href="#bm46-最小的k个数"></a> BM46 最小的K个数</h3>
<p>给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。</p>
<p><em>方法一：直接排序</em></p>
<p>直接排序，取前k个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span> || k&gt;input.<span class="built_in">size</span>()) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="built_in">sort</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;input.<span class="built_in">begin</span>(), input.<span class="built_in">begin</span>()+k&#125;);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>方法二：堆排序</em></p>
<p>建立一个容量为k的大根堆的<em>优先队列</em>。遍历一遍元素，如果队列大小&lt;k，就直接入队，否则，让当前元素与队顶元素相比，如果队顶元素大，则出队，将当前元素入队</p>
<p><strong>优先队列</strong> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32225189">优先队列 - 知乎</a></p>
<blockquote>
<p>优先队列中，队列中的数据被赋予了优先级。当访问元素时，优先级最高的会先被删除。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span> || k &gt; input.<span class="built_in">size</span>()) <span class="keyword">return</span> ret;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> val : input) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (val &lt; pq.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                    pq.<span class="built_in">pop</span>();</span><br><span class="line">                    pq.<span class="built_in">push</span>(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>());</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>方法三：快排思想</em></p>
<p><strong>快速排序</strong>  <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1K44y1k79z?share_source=copy_pc">视频讲解</a></p>
<blockquote>
<p>分治法思想</p>
</blockquote>
<p>对数组[l, r]一次快排partition过程可得到，[l, p), p, [p+1, r)三个区间,[l,p)为小于等于p的值<br>
[p+1,r)为大于等于p的值。然后再判断p，利用二分法</p>
<ol>
<li>如果[l,p), p，也就是p+1个元素（因为下标从0开始），如果p+1 == k, 找到答案</li>
<li>如果p+1 &lt; k, 说明答案在[p+1, r)区间内，</li>
<li>如果p+1 &gt; k , 说明答案在[l, p)内</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;input, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot = input[r<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> i = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=l; j&lt;r<span class="number">-1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[j] &lt; pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(input[i++], input[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(input[i], input[r<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span> || k &gt; input.<span class="built_in">size</span>()) <span class="keyword">return</span> ret;</span><br><span class="line">         <span class="type">int</span> l = <span class="number">0</span>, r = input.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">partition</span>(input, l, r);</span><br><span class="line">            <span class="keyword">if</span> (p+<span class="number">1</span> == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;input.<span class="built_in">begin</span>(), input.<span class="built_in">begin</span>()+k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p+<span class="number">1</span> &lt; k) &#123;</span><br><span class="line">                l = p + <span class="number">1</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;c</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="寻找第k大"><a class="markdownIt-Anchor" href="#寻找第k大"></a> 寻找第K大</h3>
<p>有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。</p>
<p>给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partion</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123; <span class="comment">//常规的快排划分，但这次是大数在左</span></span><br><span class="line">        <span class="type">int</span> temp = a[low];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &lt;= temp)</span><br><span class="line">                high--;</span><br><span class="line">            <span class="keyword">if</span>(low == high)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                a[low] = a[high];</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &gt;= temp)</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">if</span>(low == high)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                a[high] = a[low];</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = temp;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> K)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">partion</span>(a, low, high); <span class="comment">//先进行一轮划分，p下标左边的都比它大，下标右边都比它小</span></span><br><span class="line">        <span class="keyword">if</span>(K == p - low + <span class="number">1</span>)  <span class="comment">//若p刚好是第K个点，则找到</span></span><br><span class="line">            <span class="keyword">return</span> a[p];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p - low + <span class="number">1</span> &gt; K)  <span class="comment">//从头到p超过k个数组，则目标在左边</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSort</span>(a, low, p - <span class="number">1</span>, K);  <span class="comment">//递归左边</span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSort</span>(a, p + <span class="number">1</span>, high, K - (p - low + <span class="number">1</span>));  <span class="comment">//否则，在右边,递归右边,但是需要减去左边更大的数字的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> n, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm48-数据流中的中位数"><a class="markdownIt-Anchor" href="#bm48-数据流中的中位数"></a> BM48 数据流中的中位数</h3>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<blockquote>
<p>插入排序</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//记录输入流</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; val;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="comment">//val中没有数据，直接加入</span></span><br><span class="line">            val.<span class="built_in">push_back</span>(num); </span><br><span class="line">        <span class="comment">//val中有数据，需要插入排序</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历找到插入点</span></span><br><span class="line">            <span class="keyword">for</span>(; i &lt; val.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= val[i])&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            val.<span class="built_in">insert</span>(val.<span class="built_in">begin</span>() + i, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = val.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//奇数个数字</span></span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123; </span><br><span class="line">            <span class="comment">//类型转换</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">double</span>(val[n / <span class="number">2</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//偶数个数字</span></span><br><span class="line">        <span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="type">double</span> a = val[n / <span class="number">2</span>];</span><br><span class="line">            <span class="type">double</span> b = val[n / <span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>堆排序（优先队列）</p>
</blockquote>
<ul>
<li>一个大根堆，存中位数左边的数据，</li>
<li>一个小根堆，存中位数右边的数据，</li>
<li>动态维护两个数据结构的大小，即最多只相差一个。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//大顶堆，元素数值较小</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; min; </span><br><span class="line">    <span class="comment">//小顶堆，元素数值都比大顶堆大</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; max;</span><br><span class="line">    <span class="comment">//维护两个堆，取两个堆顶部即可</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;       </span><br><span class="line">        <span class="comment">//先加入较小部分 </span></span><br><span class="line">        min.<span class="built_in">push</span>(num);</span><br><span class="line">        <span class="comment">//将较小部分的最大值取出，送入到较大部分</span></span><br><span class="line">        max.<span class="built_in">push</span>(min.<span class="built_in">top</span>());  </span><br><span class="line">        min.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//平衡两个堆的数量</span></span><br><span class="line">        <span class="keyword">if</span>(min.<span class="built_in">size</span>() &lt; max.<span class="built_in">size</span>())&#123;  </span><br><span class="line">            min.<span class="built_in">push</span>(max.<span class="built_in">top</span>());</span><br><span class="line">            max.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//奇数个</span></span><br><span class="line">        <span class="keyword">if</span>(min.<span class="built_in">size</span>() &gt; max.<span class="built_in">size</span>())  </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)min.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//偶数个</span></span><br><span class="line">            <span class="built_in">return</span> (<span class="type">double</span>)(min.<span class="built_in">top</span>() + max.<span class="built_in">top</span>()) / <span class="number">2</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm49-表达式求值"><a class="markdownIt-Anchor" href="#bm49-表达式求值"></a> BM49 表达式求值</h3>
<p>请写一个整数计算器，支持加减乘三种运算和括号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">function</span><span class="params">(string s, <span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack; </span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = index; i &lt; s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">//数字转换成int数字</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(i != s.<span class="built_in">length</span>() - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//碰到&#x27;(&#x27;时，把整个括号内的当成一个数字处理</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//递归处理括号</span></span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">function</span>(s, i + <span class="number">1</span>);</span><br><span class="line">                num = res[<span class="number">0</span>];</span><br><span class="line">                i = res[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(i != s.<span class="built_in">length</span>() - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;           </span><br><span class="line">            <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">            <span class="comment">//加减号先入栈</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: </span><br><span class="line">                stack.<span class="built_in">push</span>(num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="comment">//相反数</span></span><br><span class="line">                stack.<span class="built_in">push</span>(-num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//优先计算乘号</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:  </span><br><span class="line">                <span class="type">int</span> temp = stack.<span class="built_in">top</span>();</span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">                stack.<span class="built_in">push</span>(temp * num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//右括号结束递归</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                op = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//栈中元素相加</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())&#123;  </span><br><span class="line">            sum += stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;sum, i&#125;; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">function</span>(s, <span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="哈希"><a class="markdownIt-Anchor" href="#哈希"></a> 哈希</h2>
<h3 id="bm-50-两数之和"><a class="markdownIt-Anchor" href="#bm-50-两数之和"></a> BM 50 两数之和</h3>
<p><em>哈希表</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = numbers.<span class="built_in">size</span>(); </span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!n) 	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// unordered_map是用哈希表实现的，复杂度为O(1)，而map是用红黑树实现的</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashmap; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.<span class="built_in">find</span>(target - numbers[i]) != hashmap.<span class="built_in">end</span>()) &#123; </span><br><span class="line">                <span class="comment">// find函数返回hashmap.end()代表未找到，否则代表找到</span></span><br><span class="line">                <span class="comment">// 将结果存入数组</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(hashmap[target - numbers[i]] + <span class="number">1</span>); </span><br><span class="line">                res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashmap[numbers[i]] = i; <span class="comment">// 将未找到的值插入哈希表中，继续遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm51-数组中出现次数超过一半的数字"><a class="markdownIt-Anchor" href="#bm51-数组中出现次数超过一半的数字"></a> BM51 数组中出现次数超过一半的数字</h3>
<p><em>哈希表</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> val : numbers) ++mp[val];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> val : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[val] &gt; numbers.<span class="built_in">size</span>() / <span class="number">2</span> ) <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)</span></span><br></pre></td></tr></table></figure>
<p><em>排序法</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> cond = numbers[numbers.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> k :numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cond == k) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; numbers.<span class="built_in">size</span>() / <span class="number">2</span>) <span class="keyword">return</span> cond;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(nlongn)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>
<p><em>候选法</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cond = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                cond = numbers[i];</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cond == numbers[i]) ++cnt;</span><br><span class="line">                <span class="keyword">else</span> --cnt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> k :numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cond == k) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; numbers.<span class="built_in">size</span>() / <span class="number">2</span>) <span class="keyword">return</span> cond;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>
<h3 id="bm52-数组中只出现一次的两个数字"><a class="markdownIt-Anchor" href="#bm52-数组中只出现一次的两个数字"></a> BM52 数组中只出现一次的两个数字</h3>
<p><em>哈希表</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>(); i++) </span><br><span class="line">            <span class="comment">//统计每个数出现的频率</span></span><br><span class="line">            mp[array[i]]++; </span><br><span class="line">        <span class="comment">//再次遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>(); i++) </span><br><span class="line">            <span class="comment">//找到频率为1的两个数</span></span><br><span class="line">            <span class="keyword">if</span>(mp[array[i]] == <span class="number">1</span>) </span><br><span class="line">                res.<span class="built_in">push_back</span>(array[i]);</span><br><span class="line">        <span class="comment">//整理次序</span></span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>] &lt; res[<span class="number">1</span>]) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> &#123;res[<span class="number">1</span>], res[<span class="number">0</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(n)，其中n为数组长度，两次单独的遍历数组每个元素</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)，哈希表的长度应该为(n−2)/2</span></span><br></pre></td></tr></table></figure>
<p><em>异或运算</em></p>
<p>​		异或运算满足交换率，且相同的数字作异或会被抵消掉，比如：a⊕b⊕c⊕b⊕c=a，且任何数字与0异或还是原数字，该题目里面所有数字异或运算就会得到a⊕b，也即得到了两个只出现一次的数字的异或和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历数组得到a^b</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) </span><br><span class="line">    temp ^= array[i];</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历数组得到a^b</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>(); i++) </span><br><span class="line">            temp ^= array[i];</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找到两个数不相同的第一位</span></span><br><span class="line">        <span class="keyword">while</span>((k &amp; temp) == <span class="number">0</span>) </span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">//遍历数组，对每个数分类</span></span><br><span class="line">            <span class="keyword">if</span>((k &amp; array[i]) == <span class="number">0</span>) </span><br><span class="line">                res[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[<span class="number">1</span>] ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//整理次序</span></span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>] &lt; res[<span class="number">1</span>]) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> &#123;res[<span class="number">1</span>], res[<span class="number">0</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(n)，遍历两次数组，找到两个数不相同的第一位循环为常数次</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)，常数级变量使用，无额外辅助空间</span></span><br></pre></td></tr></table></figure>
<h3 id="bm53-缺失的第一个正整数"><a class="markdownIt-Anchor" href="#bm53-缺失的第一个正整数"></a> BM53 缺失的第一个正整数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberDisappeared</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="comment">//哈希表记录数组中出现的每个数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            mp[nums[i]]++;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从1开始找到哈希表中第一个没有出现的正整数</span></span><br><span class="line">        <span class="keyword">while</span>(mp.<span class="built_in">find</span>(res) != mp.<span class="built_in">end</span>()) </span><br><span class="line">            res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)</span></span><br></pre></td></tr></table></figure>
<p><em>原地哈希</em></p>
<ul>
<li>step 1：我们可以先遍历数组将所有的负数都修改成n+1。</li>
<li>step 2：然后再遍历数组，每当遇到一个元素绝对值不超过n时，则表示这个元素是1～n中出现的元素，我们可以将这个数值对应的下标里的元素改成负数，相当于每个出现过的正整数，我们把与它值相等的下标都指向一个负数，这就是类似哈希表的实现原理的操作。</li>
<li>step 3：最后遍历数组的时候碰到的第一个非负数，它的下标就是没有出现的第一个正整数，因为它在之前的过程中没有被修改，说明它这个下标对应的正整数没有出现过。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberDisappeared</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            <span class="comment">//负数全部记为n+1</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= <span class="number">0</span>) </span><br><span class="line">                nums[i] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="comment">//对于1-n中的数字</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[i]) &lt;= n) </span><br><span class="line">                <span class="comment">//这个数字的下标标记为负数</span></span><br><span class="line">                nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>] = <span class="number">-1</span> * <span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>]); </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="comment">//找到第一个元素不为负数的下标</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>
<h3 id="三数之和"><a class="markdownIt-Anchor" href="#三数之和"></a> 三数之和</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;num) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ans;</span><br><span class="line">        <span class="keyword">if</span>(num.<span class="built_in">size</span>()&lt;<span class="number">3</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>() - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] == num[i<span class="number">-1</span>] &amp;&amp; i)	<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> l = i + <span class="number">1</span>,r = num.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[l] + num[r] == -num[i])&#123;</span><br><span class="line">                    <span class="comment">//若指针i 加指针j 等于当前数x 则答案为x 和指针i 与j 的三元组</span></span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;num[i],num[l],num[r]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(num[l]==num[l+<span class="number">1</span>] &amp;&amp; l + <span class="number">1</span>&lt;r)	l++;</span><br><span class="line">                    <span class="keyword">while</span>(num[r]==num[r<span class="number">-1</span>] &amp;&amp; r<span class="number">-1</span> &gt; l)	r--;</span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(num[l]+num[r]&gt;-num[i])&#123;</span><br><span class="line">                    r--;	<span class="comment">//若指针l 加指针r 大于当前数-num[i]则指针r--</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> l++;	<span class="comment">//若指针l 加指针r 小于当前数-num[i]则指针l++，</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209270849014.gif" alt="alt"></p>
<hr>
<h2 id="递归回溯"><a class="markdownIt-Anchor" href="#递归回溯"></a> 递归/回溯</h2>
<h3 id="bm55-没有重复项数字的全排列"><a class="markdownIt-Anchor" href="#bm55-没有重复项数字的全排列"></a> BM55 没有重复项数字的全排列</h3>
<p>给出一组数字，返回该组数字的所有排列：</p>
<p>例如：</p>
<p>[1,2,3]的所有排列如下<br>
[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2], [3,2,1].<br>
（以数字在数组中的位置靠前为优先级，按字典序排列输出。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;res, vector&lt;<span class="type">int</span>&gt; &amp;num, <span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//分枝进入结尾，找到一种排列</span></span><br><span class="line">        <span class="keyword">if</span>(index == num.<span class="built_in">size</span>() - <span class="number">1</span>) </span><br><span class="line">            res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//遍历后续的元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; num.<span class="built_in">size</span>(); i++)&#123; </span><br><span class="line">                <span class="comment">//交换二者</span></span><br><span class="line">                <span class="built_in">swap</span>(num[i], num[index]); </span><br><span class="line">                <span class="comment">//继续往后找</span></span><br><span class="line">                <span class="built_in">recursion</span>(res, num, index + <span class="number">1</span>); </span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                <span class="built_in">swap</span>(num[i], num[index]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt; &amp;num) &#123;</span><br><span class="line">        <span class="comment">//先按字典序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>()); </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="comment">//递归获取</span></span><br><span class="line">        <span class="built_in">recursion</span>(res, num, <span class="number">0</span>); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209271648264.gif" alt="alt"></p>
<hr>
<h3 id="bm56-有重复项数字的全排列"><a class="markdownIt-Anchor" href="#bm56-有重复项数字的全排列"></a> BM56 有重复项数字的全排列</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;res, vector&lt;<span class="type">int</span>&gt; &amp;num, vector&lt;<span class="type">int</span>&gt; &amp;temp, vector&lt;<span class="type">int</span>&gt; &amp;vis)</span></span>&#123;</span><br><span class="line">        <span class="comment">//临时数组满了加入输出</span></span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>() == num.<span class="built_in">size</span>())&#123; </span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历所有元素选取一个加入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i++)&#123; </span><br><span class="line">            <span class="comment">//如果该元素已经被加入了则不需要再加入了</span></span><br><span class="line">            <span class="keyword">if</span>(vis[i]) 	<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; num[i - <span class="number">1</span>] == num[i] &amp;&amp; !vis[i - <span class="number">1</span>]) </span><br><span class="line">                <span class="comment">//当前的元素num[i]与同一层的前一个元素num[i-1]相同且num[i-1]已经用过了</span></span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            <span class="comment">//标记为使用过</span></span><br><span class="line">            vis[i] = <span class="number">1</span>;  </span><br><span class="line">            <span class="comment">//加入数组</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(num[i]); </span><br><span class="line">            <span class="built_in">recursion</span>(res, num, temp, vis);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            vis[i] = <span class="number">0</span>; </span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt; &amp;num) &#123;</span><br><span class="line">        <span class="comment">//先按字典序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>()); </span><br><span class="line">        <span class="comment">//标记每个位置的元素是否被使用过</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(num.size(), <span class="number">0</span>)</span></span>; </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp; </span><br><span class="line">        <span class="comment">//递归获取</span></span><br><span class="line">        <span class="built_in">recursion</span>(res, num, temp, vis); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209271654636.gif" alt="alt"></p>
<hr>
<h3 id="bm57-岛屿数量"><a class="markdownIt-Anchor" href="#bm57-岛屿数量"></a> BM57 岛屿数量</h3>
<p>给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。</p>
<p>例如：输入	(注：存储的01数据其实是字符’0’,‘1’)</p>
<p>[[1,1,0,0,0],</p>
<p>[0,1,0,1,1],</p>
<p>[0,0,0,1,1],</p>
<p>[0,0,0,0,0],</p>
<p>[0,0,1,1,1]]</p>
<p>对应的输出为3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//深度优先遍历与i，j相邻的所有1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; </span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();	<span class="comment">//行</span></span><br><span class="line">        <span class="type">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();		<span class="comment">//列</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>; 	 <span class="comment">//置为0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//后续四个方向遍历</span></span><br><span class="line">        <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">            <span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">            <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>,j);</span><br><span class="line">        <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">            <span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; m &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">            <span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//空矩阵的情况</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//记录岛屿数</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line">        <span class="comment">//遍历矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                <span class="comment">//遍历到1的情况</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123; </span><br><span class="line">                    <span class="comment">//计数</span></span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j); 	<span class="comment">//将与这个1相邻的所有1置为0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209291530913.gif" alt="alt"></p>
<hr>
<h3 id="bm58-字符串的排列"><a class="markdownIt-Anchor" href="#bm58-字符串的排列"></a> BM58 字符串的排列</h3>
<p>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。</p>
<p>例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。</p>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209291541100.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(vector&lt;string&gt; &amp;res, string &amp;str, string &amp;temp, vector&lt;<span class="type">int</span>&gt; &amp;vis)</span></span>&#123;</span><br><span class="line">        <span class="comment">//临时字符串满了加入输出</span></span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">length</span>() == str.<span class="built_in">length</span>())&#123; </span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历所有元素选取一个加入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)&#123; </span><br><span class="line">            <span class="comment">//如果该元素已经被加入了则不需要再加入了</span></span><br><span class="line">            <span class="keyword">if</span>(vis[i]) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; str[i - <span class="number">1</span>] == str[i] &amp;&amp; !vis[i - <span class="number">1</span>])</span><br><span class="line">                <span class="comment">//当前的元素str[i]与同一层的前一个元素str[i-1]相同且str[i-1]已经用过了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//标记为使用过  </span></span><br><span class="line">            vis[i] = <span class="number">1</span>;  </span><br><span class="line">            <span class="comment">//加入临时字符串</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(str[i]); </span><br><span class="line">            <span class="built_in">recursion</span>(res, str, temp, vis);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            vis[i] = <span class="number">0</span>; </span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先按字典序排序，使重复字符串相邻</span></span><br><span class="line">        <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>()); </span><br><span class="line">        <span class="comment">//标记每个位置的字符是否被使用过s</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(str.size(), <span class="number">0</span>)</span></span>; </span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="comment">//递归获取</span></span><br><span class="line">        <span class="built_in">recursion</span>(res, str, temp, vis); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm59-n皇后问题"><a class="markdownIt-Anchor" href="#bm59-n皇后问题"></a> BM59 N皇后问题</h3>
<p>N皇后问题是指在 n * n 的棋盘上要摆 n 个皇后，要求：任何两个皇后不同行，不同列也不在同一条斜线上，求给一个整数 n ，返回 n 皇后的摆法数。</p>
<p><em>常规代码</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//判断皇后是否符合条件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;pos, <span class="type">int</span> row, <span class="type">int</span> col)</span></span>&#123; </span><br><span class="line">        <span class="comment">//遍历所有已经记录的行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123; </span><br><span class="line">            <span class="comment">//不能同行同列同一斜线</span></span><br><span class="line">            <span class="keyword">if</span>(row == i || col == pos[i] || <span class="built_in">abs</span>(row - i) == <span class="built_in">abs</span>(col - pos[i])) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归查找皇后种类</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, vector&lt;<span class="type">int</span>&gt; &amp; pos, <span class="type">int</span> &amp;res)</span></span>&#123; </span><br><span class="line">        <span class="comment">//完成全部行都选择了位置</span></span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123; </span><br><span class="line">            res++; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历所有列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; </span><br><span class="line">            <span class="comment">//检查该位置是否符合条件</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(pos, row, i))&#123; </span><br><span class="line">                <span class="comment">//加入位置</span></span><br><span class="line">                pos[row] = i; </span><br><span class="line">                <span class="comment">//递归继续查找</span></span><br><span class="line">                <span class="built_in">recursion</span>(n, row + <span class="number">1</span>, pos, res); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Nqueen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(n, <span class="number">0</span>)</span></span>; 	<span class="comment">//下标为行号，元素为列号，记录皇后位置 </span></span><br><span class="line">        <span class="built_in">recursion</span>(n, <span class="number">0</span>, pos, res); 	 <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><em>位运算</em></p>
<ol>
<li>如对 col = 0100 对应第二列已有皇后，那么下一行的第一列和第三列都不能选<br>
对应 pos = 0010，也就是col右移一位；对应neg = 1000，也就是col左移一位<br>
pre = ~ (col | pos | neg) &amp; ((1 &lt;&lt; n) - 1) 代表可以放皇后的位置<br>
~ (col | pos | neg)：col、pos、neg取或运算后0表示可以放皇后的位置，取反后1表示可以放皇后的位置((1 &lt;&lt; n) - 1) ：是为了保证pre不大于n位</li>
<li>然后对pre中所有的1进行遍历，从最后一个1开始往前遍历，在当前行放置了一个皇后之后进入下一行，对col、pos、neg做出相应的处理，其余操作与上一个方法相同</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Nqueen</span> <span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        limit = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, limit);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> col, <span class="type">int</span> pos, <span class="type">int</span> neg, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//标记放皇后的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> ~(col | pos | neg) &amp; (limit);</span><br><span class="line">        <span class="comment">//遍历pre</span></span><br><span class="line">        <span class="keyword">while</span>(pre &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> pre &amp; (-pre);</span><br><span class="line">            <span class="comment">//当前行放置了一个皇后之后进入下一行</span></span><br><span class="line">            backtrack(i + <span class="number">1</span>, col | cur, (pos | cur) &gt;&gt; <span class="number">1</span>, (neg | cur) &lt;&lt; <span class="number">1</span>, limit);</span><br><span class="line">            pre &amp;= pre - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209291548386.gif" alt="alt"></p>
<hr>
<h3 id="bm60-括号生成"><a class="markdownIt-Anchor" href="#bm60-括号生成"></a> BM60 括号生成</h3>
<p>给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。</p>
<p>例如，给出n=3，解集为：“((()))”, “(()())”, “(())()”, “()()()”, “()(())”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, string temp, vector&lt;string&gt; &amp;res, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//左右括号都用完了，就加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(left == n &amp;&amp; right == n)&#123; </span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用一次左括号</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; n) </span><br><span class="line">            <span class="built_in">recursion</span>(left + <span class="number">1</span>, right, temp + <span class="string">&quot;(&quot;</span>, res, n);</span><br><span class="line">        <span class="comment">//使用右括号个数必须少于左括号</span></span><br><span class="line">        <span class="keyword">if</span>(right &lt; n &amp;&amp; left &gt; right) </span><br><span class="line">            <span class="built_in">recursion</span>(left, right + <span class="number">1</span>, temp + <span class="string">&quot;)&quot;</span>, res, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录结果</span></span><br><span class="line">        vector&lt;string&gt; res; </span><br><span class="line">        <span class="comment">//记录每次组装的字符串</span></span><br><span class="line">        string temp; </span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="built_in">recursion</span>(<span class="number">0</span>, <span class="number">0</span>, temp, res, n); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209291555095.gif" alt="alt"></p>
<hr>
<h3 id="bm61-矩阵最长递增路径"><a class="markdownIt-Anchor" href="#bm61-矩阵最长递增路径"></a> BM61 矩阵最长递增路径</h3>
<p>给定一个 n 行 m 列矩阵 matrix ，矩阵内所有数均为非负整数。 你需要在矩阵中找到一条最长路径，使这条路径上的元素是递增的。并输出这条最长路径的长度。</p>
<p>这个路径必须满足以下条件：</p>
<p>1.每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。</p>
<p>2.你不能走重复的单元格。即每个格子最多只能走一次。</p>
<p>***思路：***既然是查找最长的递增路径长度，那我们首先要找到这个路径的起点，起点不好直接找到，就从上到下从左到右遍历矩阵的每个元素。然后以每个元素都可以作为起点查找它能到达的最长递增路径。</p>
<p>如何查找以某个点为起点的最长递增路径呢？我们可以考虑深度优先搜索，因为我们查找递增路径的时候，每次选中路径一个点，然后找到与该点相邻的递增位置，相当于进入这个相邻的点，继续查找递增路径，这就是递归的子问题。因此递归过程如下：</p>
<ul>
<li><em>终止条件</em> 进入路径最后一个点后，四个方向要么是矩阵边界，要么没有递增的位置，路径不能再增长，返回上一级。</li>
<li><em>返回值</em> 每次返回的就是本级之后的子问题中查找到的路径长度加上本级的长度。</li>
<li><em>本级任务</em> 每次进入一级子问题，先初始化后续路径长度为0，然后遍历四个方向（可以用数组表示，下标对数组元素的加减表示去往四个方向），进入符合不是边界且在递增的邻近位置作为子问题，查找子问题中的递增路径长度。因为有四个方向，所以最多有四种递增路径情况，因此要维护当级子问题的最大值。</li>
</ul>
<p><em><strong>具体做法</strong></em></p>
<ol>
<li>使用一个dp数组记录i，j处的单元格拥有的最长递增路径，这样在递归过程中如果访问到就不需要重复访问。</li>
<li>遍历矩阵每个位置，都可以作为起点，并维护一个最大的路径长度的值。</li>
<li>对于每个起点，使用dfs查找最长的递增路径：只要下一个位置比当前的位置数字大，就可以深入，同时累加路径长度。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;	<span class="comment">//记录四个方向</span></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="comment">//深度优先搜索，返回最大单元格数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;matrix, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;dp, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)	<span class="keyword">return</span> dp[i][j];</span><br><span class="line">        dp[i][j]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">            <span class="type">int</span> nexti = i + dirs[k][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nextj = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//判断条件</span></span><br><span class="line">            <span class="keyword">if</span> (nexti &gt;= <span class="number">0</span> &amp;&amp; nexti &lt; n &amp;&amp; nextj &gt;= <span class="number">0</span> &amp;&amp; nextj &lt; m &amp;&amp; matrix[nexti][nextj] &gt; matrix[i][j]) </span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], <span class="built_in">dfs</span>(matrix, dp, nexti, nextj) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//矩阵不为空</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//i，j处的单元格拥有的最长递增路径</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span> (n, vector &lt;<span class="type">int</span>&gt; (m));  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="comment">//更新最大值</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(matrix, dp, i, j)); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210021320667.gif" alt="alt"></p>
<hr>
<p><strong>BFS</strong> → <code>有向图的最长路径</code> → <code>拓扑排序</code></p>
<p><em>思路</em>将矩阵看成一个有向图，一个元素到另一个元素递增，代表有向图的箭头。这样我们可以根据有向图的出度入度找到最长的路径，且这个路径在矩阵中就是递增的。</p>
<p><em>具体做法</em></p>
<ol>
<li>计算每个单元格所对应的出度（符合边界条件且递增），作为边界条件的单元格的出度都为0。利用一个二维矩阵记录每个单元格的出度</li>
<li>利用拓扑排序的思想，从所有出度为0的单元格开始进行广度优先搜索。</li>
<li>用队列进行bfs，队列中每次加入出度为0的点，即路径最远点，每次从A点到B点，便将A点出度减一。</li>
<li>每次搜索都会遍历当前层所有单元格，更新其余单元格出度，将出度变为0的单元格加入下一层搜索。</li>
<li>搜索结束时，搜索的总层数即为矩阵中的最长递增路径的长度，因为bfs的层数就是路径增长的层数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//记录四个方向</span></span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;	<span class="comment">//以单元格建立坐标系</span></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        n = matrix.<span class="built_in">size</span>();	<span class="comment">//行</span></span><br><span class="line">        m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();	<span class="comment">//列</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录每个单元的出度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">outdegrees</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (m)); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> nexti = i + dirs[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> nextj = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (nexti &gt;= <span class="number">0</span> &amp;&amp; nexti &lt; n &amp;&amp; nextj &gt;= <span class="number">0</span> &amp;&amp; nextj &lt; m &amp;&amp; matrix[nexti][nextj] &gt; matrix[i][j]) &#123;</span><br><span class="line">                        <span class="comment">//符合条件，记录出度</span></span><br><span class="line">                        outdegrees[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) </span><br><span class="line">                <span class="keyword">if</span> (outdegrees[i][j] == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//找到出度为0的入队列</span></span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; size; x++) &#123;</span><br><span class="line">                pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; temp = q.<span class="built_in">front</span>(); </span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> i = temp.first;</span><br><span class="line">                <span class="type">int</span> j = temp.second;</span><br><span class="line">                <span class="comment">//四个方向</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123; </span><br><span class="line">                    <span class="type">int</span> nexti = i + dirs[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> nextj = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">//逆向搜索，所以下一步是小于</span></span><br><span class="line">                    <span class="keyword">if</span> (nexti &gt;= <span class="number">0</span> &amp;&amp; nexti &lt; n &amp;&amp; nextj &gt;= <span class="number">0</span> &amp;&amp; nextj &lt; m &amp;&amp; matrix[nexti][nextj] &lt; matrix[i][j]) &#123;</span><br><span class="line">                        <span class="comment">//符合条件，出度递减</span></span><br><span class="line">                        outdegrees[nexti][nextj]--; </span><br><span class="line">                        <span class="keyword">if</span> (outdegrees[nexti][nextj] == <span class="number">0</span>) &#123;</span><br><span class="line">                            q.<span class="built_in">push</span>(&#123;nexti, nextj&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209291605039.gif" alt="图片说明"></p>
<hr>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<h3 id="bm62-斐波那契数列"><a class="markdownIt-Anchor" href="#bm62-斐波那契数列"></a> BM62 斐波那契数列</h3>
<p><strong>描述</strong>	斐波那契数列，输入一个正整数 n ，输出斐波那契数列的第 n 项。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>x</mi><mo>=</mo><mn>0</mn><mtext> or </mtext><mi>x</mi><mo>=</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>x</mi><mo>&gt;</mo><mn>2</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">fib(x) = \begin{cases} 1 &amp; \text{if } x=0 \text{ or } x=2 \\ fib(x-1)+fib(x-2) &amp; \text{if } x&gt;2 \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mord text"><span class="mord"> or </span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)，本题也有时间复杂度 O(logn)的解法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记忆化搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> f[<span class="number">50</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)	     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (f[n] &gt; <span class="number">0</span>)	<span class="keyword">return</span> f[n];</span><br><span class="line">        <span class="keyword">return</span> f[n] = (<span class="built_in">Fibonacci</span>(n<span class="number">-1</span>)+<span class="built_in">Fibonacci</span>(n<span class="number">-2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">50</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>, dp[<span class="number">2</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span> ; i &lt;= n ; i ++) dp[i] = dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span> , b = <span class="number">1</span> , c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span> ; i &lt;= n ; i ++) &#123;</span><br><span class="line">            c = a+b , a = b , b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm63-跳台阶"><a class="markdownIt-Anchor" href="#bm63-跳台阶"></a> BM63 跳台阶</h3>
<p><strong>描述</strong>	<em>同斐波那契数列</em></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p>要求：时间复杂度：O(n)，空间复杂度： O(1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span> , b = <span class="number">1</span> , c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> ; i &lt;= number ; i ++) &#123;</span><br><span class="line">            c = a+b , a = b , b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm64-最小花费爬楼梯"><a class="markdownIt-Anchor" href="#bm64-最小花费爬楼梯"></a> BM64 最小花费爬楼梯</h3>
<p><strong>描述</strong>	给定一个整数数组 cost，其中 cost[i]是从楼梯第i个台阶向上爬需要支付的费用，下标从0开始。</p>
<p>一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]表示爬到第i阶楼梯需要的最小花费</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cost.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="comment">//每次选取最小的方案</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]); </span><br><span class="line">        <span class="keyword">return</span> dp[cost.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm65-最长公共子序列"><a class="markdownIt-Anchor" href="#bm65-最长公共子序列"></a> BM65 最长公共子序列</h3>
<p><strong>描述</strong>	给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回&quot;-1&quot;。目前给出的数据，仅仅会存在一个最长的公共子序列</p>
<p>输入：“1A2C3D4B56”,“B1D23A456A”</p>
<p>输出：“123456”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">LCS</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">empty</span>() || s2.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> dp[s1.<span class="built_in">size</span>()+<span class="number">1</span>][s2.<span class="built_in">size</span>()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s1.<span class="built_in">size</span>(); i++) </span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= s2.<span class="built_in">size</span>(); j++) </span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s2.<span class="built_in">size</span>(); j++) </span><br><span class="line">                dp[i][j] = (s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) ? dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>: <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s1.<span class="built_in">size</span>(), j = s2.<span class="built_in">size</span>(); dp[i][j] &gt;= <span class="number">1</span>;) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                res += s1[i<span class="number">-1</span>];</span><br><span class="line">                i--;j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j] &gt;= dp[i][j<span class="number">-1</span>]) i--;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">empty</span>() ? <span class="string">&quot;-1&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm66-最长公共子串"><a class="markdownIt-Anchor" href="#bm66-最长公共子串"></a> BM66 最长公共子串</h3>
<p>给定两个字符串str1和str2,输出两个字符串的最长公共子串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">LCS</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示到str1第i个个到str2第j个为止的公共子串长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(str1.<span class="built_in">length</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(str2.<span class="built_in">length</span>() + <span class="number">1</span>, <span class="number">0</span>)); </span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= str1.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= str2.<span class="built_in">length</span>(); j++)&#123;</span><br><span class="line">                <span class="comment">//如果该两位相同</span></span><br><span class="line">                <span class="keyword">if</span>(str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>])&#123; </span><br><span class="line">                    <span class="comment">//则增加长度</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; </span><br><span class="line">                    <span class="comment">//该位置为0</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新最大长度</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt; max)&#123; </span><br><span class="line">                    max = dp[i][j];</span><br><span class="line">                    pos = i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.<span class="built_in">substr</span>(pos - max + <span class="number">1</span>, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bm67-不同路径的数目一"><a class="markdownIt-Anchor" href="#bm67-不同路径的数目一"></a> BM67 不同路径的数目(一)</h3>
<p>一个机器人在m×n大小的地图的左上角（起点）。</p>
<p>机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。</p>
<p>可以有多少种不同的路径从起点走到终点？</p>
<table>
<thead>
<tr>
<th style="text-align:center">起点</th>
<th></th>
<th></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td style="text-align:center"></td>
<td style="text-align:center">终点</td>
</tr>
</tbody>
</table>
<p>要求：空间复杂度 O(nm)，时间复杂度 O(nm)</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(min(n,m))</p>
<hr>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209080806006.gif" alt="34"></p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">       vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">       <span class="comment">//第一行初始化，只有一条路径</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//第一列初始化，只有一条路径</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">               <span class="comment">//转移方程</span></span><br><span class="line">               dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//数学求解</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = n, y = <span class="number">1</span>; y &lt; m; ++x, ++y) &#123;</span><br><span class="line">        <span class="comment">//组合公式的循环求解</span></span><br><span class="line">        ret = ret * x / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bm68-矩阵的最小路径和"><a class="markdownIt-Anchor" href="#bm68-矩阵的最小路径和"></a> BM68 矩阵的最小路径和</h3>
<p><strong>描述</strong>	给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。</p>
<p>要求：时间复杂度 O(nm)</p>
<p>例如：当输入[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]时，对应的返回值为12，</p>
<p>所选择的最小累加和路径如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209080819199.png" alt="img" style="zoom:50%;"><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209080824148.gif" alt="alt" style="zoom: 20%;"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();  </span><br><span class="line">        <span class="comment">//dp[i][j]表示以当前i，j位置为终点的最短路径长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//处理第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//处理第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j] + dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//其他按照公式来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123; </span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++)&#123;</span><br><span class="line">              dp[i][j] = matrix[i][j] + (dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>] ? dp[i][j - <span class="number">1</span>] : dp[i - <span class="number">1</span>][j]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

          </div>
          
          <footer class="post-footer">
            
          </footer>
        </article>
      </div>
      
      <!-- 文章目录 -->
      
        <div class="post-toc">
          <div class="toc-header">
            <h3>post.toc</h3>
            <button class="toc-toggle">
              <i class="fas fa-chevron-down"></i>
            </button>
          </div>
          <div class="toc-content">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B4%9B%E8%B0%B7"><span class="toc-number">1.</span> <span class="toc-text"> 洛谷</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#p1059-noip2006-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%98%8E%E6%98%8E%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text"> P1059 [NOIP2006 普及组] 明明的随机数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%9B%E5%AE%A2"><span class="toc-number">2.</span> <span class="toc-text"> 牛客</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bm1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.0.1.</span> <span class="toc-text"> BM1 反转链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text"> 二分查找&#x2F;排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bm17-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">2.1.1.</span> <span class="toc-text"> BM17 二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm18-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">2.1.2.</span> <span class="toc-text"> BM18 二维数组中的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm19-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="toc-number">2.1.3.</span> <span class="toc-text"> BM19 寻找峰值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm20-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-number">2.1.4.</span> <span class="toc-text"> BM20 数组中的逆序对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm21-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-number">2.1.5.</span> <span class="toc-text"> BM21 旋转数组的最小数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm22-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">2.1.6.</span> <span class="toc-text"> BM22 比较版本号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.2.</span> <span class="toc-text"> 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bm27-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.2.1.</span> <span class="toc-text"> BM27 按之字形顺序打印二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm28-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.2.2.</span> <span class="toc-text"> BM28 二叉树的最大深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm29-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%80"><span class="toc-number">2.2.3.</span> <span class="toc-text"> BM29 二叉树中和为某一值的路径(一)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E9%98%9F%E5%88%97"><span class="toc-number">2.3.</span> <span class="toc-text"> 堆&#x2F;栈&#x2F;队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bm42-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">2.3.1.</span> <span class="toc-text"> BM42 用两个栈实现队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm43-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="toc-number">2.3.2.</span> <span class="toc-text"> BM43 包含min函数的栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm44-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97"><span class="toc-number">2.3.3.</span> <span class="toc-text"> BM44 有效括号序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm45-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">2.3.4.</span> <span class="toc-text"> BM45 滑动窗口的最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm46-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="toc-number">2.3.5.</span> <span class="toc-text"> BM46 最小的K个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E7%AC%ACk%E5%A4%A7"><span class="toc-number">2.3.6.</span> <span class="toc-text"> 寻找第K大</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm48-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">2.3.7.</span> <span class="toc-text"> BM48 数据流中的中位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm49-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">2.3.8.</span> <span class="toc-text"> BM49 表达式求值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">2.4.</span> <span class="toc-text"> 哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bm-50-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">2.4.1.</span> <span class="toc-text"> BM 50 两数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm51-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">2.4.2.</span> <span class="toc-text"> BM51 数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm52-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">2.4.3.</span> <span class="toc-text"> BM52 数组中只出现一次的两个数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm53-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0"><span class="toc-number">2.4.4.</span> <span class="toc-text"> BM53 缺失的第一个正整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">2.4.5.</span> <span class="toc-text"> 三数之和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF"><span class="toc-number">2.5.</span> <span class="toc-text"> 递归&#x2F;回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bm55-%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E9%A1%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">2.5.1.</span> <span class="toc-text"> BM55 没有重复项数字的全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm56-%E6%9C%89%E9%87%8D%E5%A4%8D%E9%A1%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">2.5.2.</span> <span class="toc-text"> BM56 有重复项数字的全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm57-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">2.5.3.</span> <span class="toc-text"> BM57 岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm58-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">2.5.4.</span> <span class="toc-text"> BM58 字符串的排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm59-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.5.</span> <span class="toc-text"> BM59 N皇后问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm60-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">2.5.6.</span> <span class="toc-text"> BM60 括号生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm61-%E7%9F%A9%E9%98%B5%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="toc-number">2.5.7.</span> <span class="toc-text"> BM61 矩阵最长递增路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.6.</span> <span class="toc-text"> 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bm62-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">2.6.1.</span> <span class="toc-text"> BM62 斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm63-%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="toc-number">2.6.2.</span> <span class="toc-text"> BM63 跳台阶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm64-%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">2.6.3.</span> <span class="toc-text"> BM64 最小花费爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm65-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.6.4.</span> <span class="toc-text"> BM65 最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm66-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2"><span class="toc-number">2.6.5.</span> <span class="toc-text"> BM66 最长公共子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm67-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E7%9A%84%E6%95%B0%E7%9B%AE%E4%B8%80"><span class="toc-number">2.6.6.</span> <span class="toc-text"> BM67 不同路径的数目(一)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bm68-%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">2.6.7.</span> <span class="toc-text"> BM68 矩阵的最小路径和</span></a></li></ol></li></ol></li></ol>
          </div>
        </div>
      
    </div>
  </div>
</div>
  </main>
  
  <footer class="footer">
  <div class="container">
    <div class="footer-inner">
      <div class="copyright">
        &copy; 2025 Dezeem
      </div>
      <div class="powered-by">
        由 &lt;a href=&#34;https://hexo.io&#34; target=&#34;_blank&#34;&gt;Hexo&lt;/a&gt; 强力驱动 | 
        主题 <a href="https://github.com/yourusername/hexo-theme-canary" target="_blank">Canary</a>
      </div>
    </div>
  </div>
</footer>
  <div class="mobile-nav">
  <div class="mobile-nav-inner">
    <div class="mobile-nav-header">
      <div class="logo">
        <a href="/">Dezeem&#39;log</a>
      </div>
      <button class="mobile-nav-close">
        <i class="fas fa-times"></i>
      </button>
    </div>
    
    <nav class="mobile-menu">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives">Archives</a></li>
        
          <li><a href="/categories">Categories</a></li>
        
          <li><a href="/tags">Tags</a></li>
        
          <li><a href="/about">About</a></li>
        
      </ul>
    </nav>
    
    <div class="mobile-nav-footer">
      <div class="language-switch">
        <a href="#" class="lang-btn" data-lang="zh-CN">中文</a>
        <a href="#" class="lang-btn" data-lang="en">EN</a>
      </div>
      
      <div class="theme-switch">
        <button id="mobile-theme-toggle" aria-label="Toggle Dark Mode">
          <i class="fas fa-moon dark-icon"></i>
          <i class="fas fa-sun light-icon"></i>
        </button>
      </div>
    </div>
  </div>
</div>

<div class="mobile-nav-toggle">
  <i class="fas fa-bars"></i>
</div> <!-- 新增 -->
  
  <!-- JavaScript -->
  
<script src="/js/main.js"></script>

  
  
</body>
</html>