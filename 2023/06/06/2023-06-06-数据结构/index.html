<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>数据结构 | Dezeem&#39;log</title>
  
    <link rel="icon" href="/img/favicon.png">
  

  <!-- CSS -->
  
<link rel="stylesheet" href="/css/style.css">


  <!-- KaTeX for LaTeX support -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script>

  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

  <!-- Theme JavaScript -->
  
<script src="/js/main.js"></script>

  
  <!-- 添加 jQuery 库 -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Dezeem'log" type="application/atom+xml">
</head>
<body>
  <header class="header">
  <div class="container">
    <div class="header-inner">
      <div class="logo">
        <a href="/">Dezeem</a>
      </div>
      
      <nav class="main-nav">
        <ul>
          
            <li><a href="/archives">Archives</a></li>
          
            <li><a href="/categories">Categories</a></li>
          
            <li><a href="/tags">Tags</a></li>
          
            <li><a href="/essays">Essays</a></li>
          
            <li><a href="/about">About</a></li>
          
        </ul>
      </nav>
      
      <div class="header-right">
        <!-- 语言切换 -->
        <!-- <div class="language-switch">
          <a href="#" class="lang-btn " data-lang="zh-CN">中文</a>
          <span class="separator">|</span>
          <a href="#" class="lang-btn active" data-lang="en">EN</a>
        </div> -->
        
        <!-- 暗黑模式切换 -->
        <div class="theme-switch">
          <button id="theme-toggle" aria-label="Toggle Dark Mode">
            <i class="fas fa-moon dark-icon"></i>
            <i class="fas fa-sun light-icon"></i>
          </button>
        </div>
        
        <!-- 搜索按钮 -->
        <div class="search-btn">
          <i class="fas fa-search"></i>
        </div>
      </div>
    </div>
  </div>
  
  <!-- 搜索框 -->
  <div class="search-container">
    <div class="container">
      <form class="search-form">
        <input type="text" class="search-input" placeholder="Search">
        <button type="submit" class="search-submit">
          <i class="fas fa-search"></i>
        </button>
      </form>
      <button class="search-close">
        <i class="fas fa-times"></i>
      </button>
    </div>
  </div>
</header>
  
  <div class="post-container">
  <div class="container">
    <div class="post-inner">
      <!-- 文章主体 -->
      <div class="post-main">
        <article class="post-content">
          <header class="post-header">
            <h1 class="post-title">数据结构</h1>
            <div class="post-meta">
              <time class="post-date" datetime="2023-06-06T09:14:13.000Z">
                2023-06-06
              </time>
              
                <span class="post-categories">
                  
                    <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">算法</a>
                  
                </span>
              
            </div>
          </header>
          
          <div class="post-body">
            <h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1>
<h2 id="线性表"><a class="markdownIt-Anchor" href="#线性表"></a> 线性表</h2>
<h3 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define element type</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define struct of linked list</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define Status</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    ERROR,</span><br><span class="line">    SUCCESS</span><br><span class="line">&#125; Status;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">CreateList_Head</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));     <span class="comment">//创建头结点</span></span><br><span class="line">    L-&gt;next  =<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=s;                          <span class="comment">//插入结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    L = <span class="keyword">new</span> LNode;</span><br><span class="line">    <span class="built_in">CreateList_Head</span>(L);</span><br><span class="line">    <span class="built_in">TraverseList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKSIZE 10;              <span class="comment">//存储空间分配增量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100;    <span class="comment">//存储空间初始分配量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType* base;    <span class="comment">//栈底</span></span><br><span class="line">    ElemType* top;     <span class="comment">//栈顶</span></span><br><span class="line">    <span class="type">int</span> stacksize;          <span class="comment">//当前已分配的空间</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line">Status <span class="title function_">initStack</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S.base = (ElemType *)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!S.base)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack&amp; S, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top - S.base &gt;= S.stacksize)   <span class="comment">//如果栈满就追加空间</span></span><br><span class="line">    &#123;                           <span class="comment">//新增内存空间</span></span><br><span class="line">        S.base = (ElemType*)<span class="built_in">realloc</span>(S.base, (S.stacksize + <span class="number">10</span>) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!S.base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        S.top = S.base + S.stacksize;</span><br><span class="line">        S.stacksize += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++ = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack&amp; S, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h2>
<blockquote>
<p><strong>根据存储结构划分：1.链式队列	2.循环队列	3.单向队列	4.双端队列</strong></p>
</blockquote>
<h3 id="顺序队列"><a class="markdownIt-Anchor" href="#顺序队列"></a> 顺序队列</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line">&#125;Sequeue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeueInit</span><span class="params">(Sequeue &amp;Top)</span>&#123;<span class="comment">//队列的初始化</span></span><br><span class="line">    Top.front=<span class="number">0</span>;</span><br><span class="line">    Top.rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeueEmpty</span><span class="params">(Sequeue &amp;Top)</span>&#123;<span class="comment">//判队列为空</span></span><br><span class="line">    <span class="keyword">if</span>(Top.rear==Top.front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;队列不为空\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeuePush</span><span class="params">(Sequeue &amp;Top,<span class="type">int</span> m)</span>&#123;<span class="comment">//循环入队列</span></span><br><span class="line">   <span class="keyword">if</span>((Top.rear+<span class="number">1</span>)%MAXSIZE==Top.front)</span><br><span class="line">        &#123;<span class="built_in">printf</span>(<span class="string">&quot;队列已满&quot;</span>);&#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       Top.data[Top.rear]=m;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d已入队\n&quot;</span>,m);</span><br><span class="line">       Top.rear=(Top.rear+<span class="number">1</span>)%MAXSIZE;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeueTop</span><span class="params">(Sequeue &amp;Top)</span><span class="comment">//求队列头部元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列头部元素为%d\n&quot;</span>,Top.data[Top.front]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeuePop</span><span class="params">(Sequeue &amp;Top)</span>&#123;<span class="comment">//循环出队列</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Top.rear==Top.front)</span><br><span class="line">     &#123;<span class="built_in">printf</span>(<span class="string">&quot;队列为空&quot;</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (Top.rear!=Top.front) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;队第%d元素为%d\n&quot;</span>,i,Top.data[Top.front]);</span><br><span class="line">            Top.front=(Top.front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SequeueTopp</span><span class="params">(Sequeue &amp;Top)</span><span class="comment">//求队列头部元素( 返回值)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Top.data[Top.front];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeuePushh</span><span class="params">(Sequeue &amp;Top,<span class="type">int</span> m)</span>&#123;<span class="comment">//不循环入队列</span></span><br><span class="line">    Top.data[Top.rear]=m;</span><br><span class="line">    Top.rear++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">SequeuePopp</span><span class="params">(Sequeue &amp;Top)</span>&#123;<span class="comment">//不循环出队列</span></span><br><span class="line">    <span class="type">int</span> m=Top.data[Top.front];</span><br><span class="line">        Top.front++;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环队列"><a class="markdownIt-Anchor" href="#循环队列"></a> 循环队列</h3>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<h3 id="动态数组"><a class="markdownIt-Anchor" href="#动态数组"></a> 动态数组</h3>
<h2 id="树和二叉树"><a class="markdownIt-Anchor" href="#树和二叉树"></a> 树和二叉树</h2>
<h3 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h3>
<blockquote>
<p><strong>C++：nullptr 专用于初始化空类型指针</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiNode</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType data;</span><br><span class="line">    BiNode *lchild, *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BiTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BiTree</span>( )&#123;</span><br><span class="line">        root = <span class="built_in">Creat</span>(root);	<span class="comment">//构造函数，建立二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">BiTree</span>( )&#123;</span><br><span class="line">        <span class="built_in">Release</span>(root);   <span class="comment">//析构函数，释放各结点的存储空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="built_in">PreOrder</span>(root);   <span class="comment">//前序遍历二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(root);   <span class="comment">//中序遍历二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(root);   <span class="comment">//后序遍历二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LeverOrder</span><span class="params">( )</span></span>; <span class="comment">//层序遍历二叉树</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BiNode &lt;DataType&gt;*<span class="built_in">Creat</span>(BiNode&lt;DataType&gt; *bt); <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>; 		  <span class="comment">//析构函数调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>; 		  <span class="comment">//前序遍历函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>; 		  <span class="comment">//中序遍历函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>; 		  <span class="comment">//后序遍历函数</span></span><br><span class="line">    BiNode&lt;DataType&gt; *root;					     <span class="comment">//指向根结点的头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">BiNode&lt;DataType&gt; *BiTree &lt;DataType&gt;:: <span class="built_in">Creat</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入扩展二叉树的前序遍历序列，每次输入一个字符:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; ch; <span class="comment">//输入结点的数据信息，假设为字符</span></span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) bt = <span class="literal">nullptr</span>; <span class="comment">//建立一棵空树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        bt = <span class="keyword">new</span> BiNode&lt;DataType&gt;;</span><br><span class="line">        bt-&gt;data = ch;</span><br><span class="line">        bt-&gt;lchild = <span class="built_in">Creat</span>(bt-&gt;lchild); <span class="comment">//递归建立左子树</span></span><br><span class="line">        bt-&gt;rchild = <span class="built_in">Creat</span>(bt-&gt;rchild); <span class="comment">//递归建立右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;	<span class="comment">//前序遍历</span></span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">PreOrder</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>; </span><br><span class="line">    cout &lt;&lt; bt-&gt;data; 	  </span><br><span class="line">    <span class="built_in">PreOrder</span>(bt-&gt;lchild); </span><br><span class="line">    <span class="built_in">PreOrder</span>(bt-&gt;rchild); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;	<span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">InOrder</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;lchild); </span><br><span class="line">        cout &lt;&lt; bt-&gt;data; </span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;	<span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">PostOrder</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;lchild);</span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;rchild);</span><br><span class="line">        cout &lt;&lt; bt-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;	<span class="comment">//层次遍历</span></span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">LeverOrder</span>( )</span><br><span class="line">&#123;</span><br><span class="line">    BiNode&lt;DataType&gt; *Q[<span class="number">100</span>], *q = <span class="literal">nullptr</span>; <span class="comment">//顺序队列</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>; <span class="comment">//队列初始化</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">//二叉树为空，算法结束</span></span><br><span class="line">    Q[++rear] = root; <span class="comment">//根指针入队</span></span><br><span class="line">    <span class="keyword">while</span> (front != rear) <span class="comment">//当队列非空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = Q[++front]; <span class="comment">//出队</span></span><br><span class="line">        cout &lt;&lt; q-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;lchild != <span class="literal">nullptr</span>) Q[++rear] = q-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;rchild != <span class="literal">nullptr</span>) Q[++rear] = q-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">Release</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Release</span>(bt-&gt;lchild); <span class="comment">//释放左子树</span></span><br><span class="line">        <span class="built_in">Release</span>(bt-&gt;rchild); <span class="comment">//释放右子树</span></span><br><span class="line">        <span class="keyword">delete</span> bt; <span class="comment">//释放根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历"><a class="markdownIt-Anchor" href="#层序遍历"></a> 层序遍历</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)	<span class="comment">//如果是空，则直接返回空vector</span></span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        queue&lt;TreeNode*&gt; q; 	<span class="comment">//队列存储，进行层次遍历</span></span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        TreeNode* cur;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//记录二叉树的某一行</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; row;  </span><br><span class="line">            <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">//因先进入的是根节点，故每层节点多少，队列大小就是多少</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                row.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="comment">//若是左右孩子存在，则存入左右孩子作为下一个层次</span></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每一层加入输出</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(row); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="avl-tree"><a class="markdownIt-Anchor" href="#avl-tree"></a> AVL Tree</h3>
<blockquote>
<p>AVL树（Adelson-Velsky and Landis Tree）是CS中最早被发明的自平衡二叉查找树。</p>
</blockquote>
<p>一棵AVL树有如下必要条件：</p>
<ul>
<li>必须是二叉查找树</li>
<li>每个节点的左子树和右子树的高度差至多为1</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">AVL Tree Visualzation</a> <strong>可视化演示</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AVLnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> key;    <span class="comment">//值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLnode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLnode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> height;     <span class="comment">//高度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAVL</span><span class="params">(avlNode *node, <span class="type">int</span> level)</span>	<span class="comment">//树尖向左打印</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printAVL(node-&gt;right, level + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, node-&gt;key);</span><br><span class="line"></span><br><span class="line">        printAVL(node-&gt;left, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="平衡化操作"><a class="markdownIt-Anchor" href="#平衡化操作"></a> 平衡化操作</h4>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/438604092">平衡二叉树 — 优雅的进行旋转</a></p>
<h5 id="ll型"><a class="markdownIt-Anchor" href="#ll型"></a> LL型</h5>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131014059.webp" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">avlNode *<span class="title function_">rightRotate</span><span class="params">(avlNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    avlNode *L = T-&gt;left;</span><br><span class="line">    avlNode *T3 = L-&gt;right;</span><br><span class="line"></span><br><span class="line">    L-&gt;right = T;</span><br><span class="line">    T-&gt;left = T3;</span><br><span class="line"></span><br><span class="line">    T-&gt;height = (Max(nodeHeight(T-&gt;left), nodeHeight(T-&gt;right)) + <span class="number">1</span>);</span><br><span class="line">    L-&gt;height = (Max(nodeHeight(L-&gt;left), nodeHeight(L-&gt;right)) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="rr型"><a class="markdownIt-Anchor" href="#rr型"></a> RR型</h5>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131019717.webp" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">avlNode *<span class="title function_">leftRotate</span><span class="params">(avlNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    avlNode *R= T-&gt;right;</span><br><span class="line">    avlNode *T3 = R-&gt;left;</span><br><span class="line"></span><br><span class="line">    R-&gt;left = z;</span><br><span class="line">    T-&gt;right = T3;</span><br><span class="line"></span><br><span class="line">    T-&gt;height = (Max(nodeHeight(T-&gt;left), nodeHeight(T-&gt;right)) + <span class="number">1</span>);</span><br><span class="line">    R-&gt;height = (Max(nodeHeight(R-&gt;left), nodeHeight(R-&gt;right)) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="lr型"><a class="markdownIt-Anchor" href="#lr型"></a> LR型</h5>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131021410.jpeg" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avlNode *<span class="title function_">LeftRightRotate</span><span class="params">(avlNode *z)</span>&#123;</span><br><span class="line">    T-&gt;left = leftRotate(T-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> (rightRotate(T));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="rl型"><a class="markdownIt-Anchor" href="#rl型"></a> RL型</h5>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131023406.webp" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avlNode *<span class="title function_">RightLeftRotate</span><span class="params">(avlNode *T)</span>&#123;</span><br><span class="line">    T-&gt;right = rightRotate(T-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (leftRotate(T));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉查找树"><a class="markdownIt-Anchor" href="#二叉查找树"></a> 二叉查找树</h3>
<blockquote>
<p>​		二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree）。</p>
</blockquote>
<p>一棵空树或者具有下列性质的二叉树：</p>
<ul>
<li>若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意结点的右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>任意结点的左、右子树也分别为二叉查找树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure>
<h3 id="红黑树"><a class="markdownIt-Anchor" href="#红黑树"></a> 红黑树</h3>
<blockquote>
<p>红黑树（Red Black Tree） 是一种自平衡二叉查找树</p>
</blockquote>
<p>红黑树满足以下特征：</p>
<ul>
<li>节点分为红色或者黑色；</li>
<li>根节点必为黑色；</li>
<li>叶子节点都为黑色，且为null；</li>
<li>连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）；</li>
<li>从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点；</li>
<li>新加入到红黑树的节点为红色节点；(推断)</li>
</ul>
<p><em>类比234树——4阶B树</em></p>
<h2 id="图"><a class="markdownIt-Anchor" href="#图"></a> 图</h2>
<h3 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表"></a> 邻接表</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeNode</span> <span class="comment">//定义边表结点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//邻接点域</span></span><br><span class="line">    EdgeNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexNode</span> <span class="comment">//定义顶点表结点</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType vertex;</span><br><span class="line">    EdgeNode *firstEdge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">10</span>; <span class="comment">//图的最多顶点数</span></span><br><span class="line"><span class="type">int</span> visited[MaxSize] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALGraph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ALGraph</span>(DataType a[ ], <span class="type">int</span> n, <span class="type">int</span> e); <span class="comment">//构造函数，建立n个顶点e条边的图</span></span><br><span class="line">    ~<span class="built_in">ALGraph</span>( ); <span class="comment">//析构函数，释放邻接表各边表结点的存储空间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>; <span class="comment">//深度优先遍历图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>; <span class="comment">//广度优先遍历图</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VertexNode&lt;DataType&gt; adjlist[MaxSize]; <span class="comment">//存放顶点表的数组</span></span><br><span class="line">    <span class="type">int</span> vertexNum, edgeNum; <span class="comment">//图的顶点数和边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">ALGraph&lt;DataType&gt; :: <span class="built_in">ALGraph</span>(DataType a[ ], <span class="type">int</span> n, <span class="type">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    EdgeNode *s = <span class="literal">nullptr</span>;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) <span class="comment">//输入顶点信息，初始化顶点表</span></span><br><span class="line">    &#123;</span><br><span class="line">        adjlist[i].vertex = a[i];</span><br><span class="line">        adjlist[i].firstEdge = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; edgeNum; k++) <span class="comment">//依次输入每一条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入边所依附的两个顶点的编号：&quot;</span>;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j; <span class="comment">//输入边所依附的两个顶点的编号</span></span><br><span class="line">        s = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">        s-&gt;adjvex = j; <span class="comment">//生成一个边表结点s</span></span><br><span class="line">        s-&gt;next = adjlist[i].firstEdge; <span class="comment">//将结点s插入到第i个边表的表头</span></span><br><span class="line">        adjlist[i].firstEdge = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">ALGraph&lt;DataType&gt;  :: ~<span class="built_in">ALGraph</span>( )</span><br><span class="line">&#123;</span><br><span class="line">    EdgeNode *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = q = adjlist[i].firstEdge;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> q;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> ALGraph&lt;DataType&gt;  :: <span class="built_in">DFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    EdgeNode *p = <span class="literal">NULL</span>;</span><br><span class="line">    cout &lt;&lt; adjlist[v].vertex;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    p = adjlist[v].firstEdge; <span class="comment">//工作指针p指向顶点v的边表</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) <span class="comment">//依次搜索顶点v的邻接点</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span> (visited[j] == <span class="number">0</span>) <span class="built_in">DFTraverse</span>(j);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> ALGraph&lt;DataType&gt; :: <span class="built_in">BFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w, j, Q[MaxSize]; <span class="comment">//采用顺序队列</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>; <span class="comment">//初始化队列</span></span><br><span class="line">    EdgeNode *p = <span class="literal">nullptr</span>;</span><br><span class="line">    cout &lt;&lt; adjlist[v].vertex;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    Q[++rear] = v; <span class="comment">//被访问顶点入队</span></span><br><span class="line">    <span class="keyword">while</span> (front != rear) <span class="comment">//当队列非空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        w = Q[++front];</span><br><span class="line">        p = adjlist[w].firstEdge; <span class="comment">//工作指针p指向顶点v的边表</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            j = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span> (visited[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; adjlist[j].vertex;</span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//测试数据是图6-20(a)，边是(0 1)(0 3)(0 4)(1 2)(2 4)(3 2)(3 4)</span></span><br><span class="line">    <span class="type">char</span> ch[ ] = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function">ALGraph&lt;<span class="type">char</span>&gt; <span class="title">ALG</span><span class="params">(ch, <span class="number">5</span>, <span class="number">6</span>)</span></span>; <span class="comment">//建立具有5个顶点6条边的有向图</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;深度优先遍历序列是：&quot;</span>;</span><br><span class="line">    ALG.<span class="built_in">DFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;广度优先遍历序列是：&quot;</span>;</span><br><span class="line">    ALG.<span class="built_in">BFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************</span></span><br><span class="line"><span class="comment">邻接矩阵类MGraph的使用范例</span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">10</span>; <span class="comment">//图中最多顶点个数</span></span><br><span class="line"><span class="type">int</span> visited[MaxSize] = &#123;<span class="number">0</span>&#125;; <span class="comment">//全局数组变量visited初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MGraph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MGraph</span>(DataType a[ ], <span class="type">int</span> n, <span class="type">int</span> e); <span class="comment">//构造函数，建立具有n个顶点e条边的图</span></span><br><span class="line">    ~<span class="built_in">MGraph</span>( ) &#123; &#125;; <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>; <span class="comment">//深度优先遍历图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>; <span class="comment">//广度优先遍历图</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType vertex[MaxSize]; <span class="comment">//存放图中顶点的数组</span></span><br><span class="line">    <span class="type">int</span> edge[MaxSize][MaxSize]; <span class="comment">//存放图中边的数组</span></span><br><span class="line">    <span class="type">int</span> vertexNum, edgeNum; <span class="comment">//图的顶点数和边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">MGraph &lt;DataType&gt;:: <span class="built_in">MGraph</span>(DataType a[ ], <span class="type">int</span> n, <span class="type">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) <span class="comment">//存储顶点</span></span><br><span class="line">        vertex[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">            edge[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; edgeNum; k++) <span class="comment">//依次输入每一条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入边依附的两个顶点的编号：&quot;</span>;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j; <span class="comment">//输入边依附的两个顶点的编号</span></span><br><span class="line">        edge[i][j] = <span class="number">1</span>;</span><br><span class="line">        edge[j][i] = <span class="number">1</span>; <span class="comment">//置有边标志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> MGraph &lt;DataType&gt;:: <span class="built_in">DFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; vertex[v];</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">        <span class="keyword">if</span> (edge[v][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) <span class="built_in">DFTraverse</span>( j );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> MGraph &lt;DataType&gt;:: <span class="built_in">BFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w, j, Q[MaxSize]; <span class="comment">//采用顺序队列</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>; <span class="comment">//初始化队列</span></span><br><span class="line">    cout &lt;&lt; vertex[v];</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    Q[++rear] = v; <span class="comment">//被访问顶点入队</span></span><br><span class="line">    <span class="keyword">while</span> (front != rear) <span class="comment">//当队列非空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        w = Q[++front]; <span class="comment">//将队头元素出队并送到v中</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">            <span class="keyword">if</span> (edge[w][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; vertex[j];</span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch[ ]= &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">/* 测试数据六条边是：(0 1)(0 2)(0 3)(0 4)(1 2)(2 4) */</span></span><br><span class="line">    MGraph&lt;<span class="type">char</span>&gt; MG&#123;ch, <span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">//建立具有5个顶点6条边的无向图</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;深度优先遍历序列是：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    MG.<span class="built_in">DFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;广度优先遍历序列是：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    MG.<span class="built_in">BFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字典"><a class="markdownIt-Anchor" href="#字典"></a> 字典</h2>
<h2 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h2>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">经典排序算法</a></p>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210221013239.png" alt="img"></p>
<h3 id="bubble-sort"><a class="markdownIt-Anchor" href="#bubble-sort"></a> Bubble sort</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                                <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123; <span class="number">61</span>, <span class="number">17</span>, <span class="number">29</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">60</span>, <span class="number">72</span>, <span class="number">21</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">62</span> &#125;;</span><br><span class="line">        <span class="type">int</span> len = (<span class="type">int</span>) <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">        <span class="built_in">bubble_sort</span>(arr, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="type">float</span> arrf[] = &#123; <span class="number">17.5</span>, <span class="number">19.1</span>, <span class="number">0.6</span>, <span class="number">1.9</span>, <span class="number">10.5</span>, <span class="number">12.4</span>, <span class="number">3.8</span>, <span class="number">19.7</span>, <span class="number">1.5</span>, <span class="number">25.4</span>, <span class="number">28.6</span>, <span class="number">4.4</span>, <span class="number">23.8</span>, <span class="number">5.4</span> &#125;;</span><br><span class="line">        len = (<span class="type">float</span>) <span class="built_in">sizeof</span>(arrf) / <span class="built_in">sizeof</span>(*arrf);</span><br><span class="line">        <span class="built_in">bubble_sort</span>(arrf, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                cout &lt;&lt; arrf[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="selection-sort"><a class="markdownIt-Anchor" href="#selection-sort"></a> Selection sort</h3>
<p>Selection sort is a simple and intuitive sorting algorithm that is O(n²) time complex no matter what data goes in. So when using it, the smaller the data size, the better. The only advantage is that it doesn’t take up extra memory space.</p>
<p><strong>算法步骤</strong></p>
<ol>
<li>First, find the smallest (large) element in the unsorted sequence and store it at the beginning of the sorted sequence.</li>
<li>Then find the smallest (large) element from the remaining unsorted elements and put it at the end of the sorted sequence.</li>
<li>Repeat the second step until all elements are sorted.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">                min = j;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="insertion-sort"><a class="markdownIt-Anchor" href="#insertion-sort"></a> Insertion sort</h3>
<p>The code implementation of insertion sort is not as simple and brutal as bubble sort and selection sort, but its principle should be the easiest to understand, because anyone who has played poker should be able to understand it in seconds. Insertion sort is one of the simplest and most intuitive sorting algorithms. It works by constructing an ordered sequence, and for unsorted data, scanning backward and forward in the sorted sequence to find the appropriate position and insert it.</p>
<p>Insertion sort, like bubble sort, also has an optimization algorithm called split-half insertion.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> key=arr[i];</span><br><span class="line">        <span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((j&gt;=<span class="number">0</span>) &amp;&amp; (key&lt;arr[j]))&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>]=key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shell-sort"><a class="markdownIt-Anchor" href="#shell-sort"></a> Shell sort</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(T array[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; length / <span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(array[j], array[j - h]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="merge-sort"><a class="markdownIt-Anchor" href="#merge-sort"></a> Merge sort</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代版</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    T *a = arr;</span><br><span class="line">    T *b = <span class="keyword">new</span> T[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line">            <span class="type">int</span> low = start, mid = <span class="built_in">min</span>(start + seg, len), high = <span class="built_in">min</span>(start + seg + seg, len);</span><br><span class="line">            <span class="type">int</span> k = low;</span><br><span class="line">            <span class="type">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="type">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        T *temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;Array, <span class="type">int</span> front, <span class="type">int</span> mid, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// preconditions:</span></span><br><span class="line">    <span class="comment">// Array[front...mid] is sorted</span></span><br><span class="line">    <span class="comment">// Array[mid+1 ... end] is sorted</span></span><br><span class="line">    <span class="comment">// Copy Array[front ... mid] to LeftSubArray</span></span><br><span class="line">    <span class="comment">// Copy Array[mid+1 ... end] to RightSubArray</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">LeftSubArray</span><span class="params">(Array.begin() + front, Array.begin() + mid + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">RightSubArray</span><span class="params">(Array.begin() + mid + <span class="number">1</span>, Array.begin() + end + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> idxLeft = <span class="number">0</span>, idxRight = <span class="number">0</span>;</span><br><span class="line">    LeftSubArray.<span class="built_in">insert</span>(LeftSubArray.<span class="built_in">end</span>(), numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">    RightSubArray.<span class="built_in">insert</span>(RightSubArray.<span class="built_in">end</span>(), numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">    <span class="comment">// Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = front; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LeftSubArray[idxLeft] &lt; RightSubArray[idxRight]) &#123;</span><br><span class="line">            Array[i] = LeftSubArray[idxLeft];</span><br><span class="line">            idxLeft++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Array[i] = RightSubArray[idxRight];</span><br><span class="line">            idxRight++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;Array, <span class="type">int</span> front, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (front + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(Array, front, mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(Array, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="built_in">Merge</span>(Array, front, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="quick-sort"><a class="markdownIt-Anchor" href="#quick-sort"></a> Quick sort</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort_recursive</span><span class="params">(T arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    T mid = arr[end];</span><br><span class="line">    <span class="type">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换</span></span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right) <span class="comment">//试图在左侧找到一个比枢纽元更大的元素</span></span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right) <span class="comment">//试图在右侧找到一个比枢纽元更小的元素</span></span><br><span class="line">            right--;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[left], arr[right]); <span class="comment">//交换元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[left], arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="time-complexity"><a class="markdownIt-Anchor" href="#time-complexity"></a> Time complexity</h4>
<p>​		During the partition process, both the head and tail pointers are scanned cyclically to the last position where the base value was placed. Thus, the head and tail pointer scans together are equivalent to scanning the entire region of the array to be sorted. Therefore, we can conclude that the time complexity of a single partition operation is O(n). The formula for the overall time complexity: T(n) = n + T(L) + T®.</p>
<p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181007848.jpeg" alt="img"></p>
<p>Time complexity：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p>
<h4 id="optimization"><a class="markdownIt-Anchor" href="#optimization"></a> Optimization</h4>
<h5 id="one-sided-recursive-optimization"><a class="markdownIt-Anchor" href="#one-sided-recursive-optimization"></a> One-sided recursive optimization</h5>
<p>​		Mode：when this layer has finished the partition operation, let this layer continue to complete the partition operation to the left of the base value, while the sorting work to the right of the base value is left to the next layer of recursive functions to handle.</p>
<img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181111010.jpeg" alt="img" style="zoom:25%;">
<p>function is called 4 times.</p>
<p>Without the method, the actual number is 7.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 进行一轮 partition 操作</span></span><br><span class="line">        <span class="comment">// 获得基准值的位置</span></span><br><span class="line">        <span class="type">int</span> ind = partition(arr, l, r);</span><br><span class="line">        <span class="comment">// 右侧正常调用递归函数 </span></span><br><span class="line">        quick_sort(arr, ind + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 用本层处理左侧的排序</span></span><br><span class="line">        r = ind - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="optimization-of-benchmark-value-selection"><a class="markdownIt-Anchor" href="#optimization-of-benchmark-value-selection"></a> Optimization of benchmark value selection</h5>
<p><em>three-point middle method</em> is to take the three values of the head, tail and middle elements of the sorting interval in each round, and then use the middle value after they are sorted as the base value for the current round.For example, suppose the three values of this round are 2, 9 and 7, and the middle value is 7, so the base value of this round is 7.</p>
<h5 id="partition-operation-optimization"><a class="markdownIt-Anchor" href="#partition-operation-optimization"></a> Partition Operation Optimization</h5>
<img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181129919.png" alt="img" style="zoom: 25%;">
<p>Let the head pointer look backward for red elements and the tail pointer look forward for green elements, then swap the elements pointed by the head and tail pointers and repeat the process until the head and tail pointers are interleaved and stop.</p>
<h3 id="heapsort"><a class="markdownIt-Anchor" href="#heapsort"></a> Heapsort</h3>
<p>经典问题：蚂蚁问题</p>
<p>假设现在有一个水平面，上面有 8 只蚂蚁排成一排。方便起见，我们给所有的蚂蚁从左到右依次编号，编号为 1 到 8。从 0 秒开始，红色蚂蚁向左爬，蓝色蚂蚁向右爬，爬行的速度都是 1m/s。如果有 2 只蚂蚁迎面碰到以后，这 2 只蚂蚁不会做任何的感情交流，而会立刻掉头向相反方向继续爬行。而爬行到桌子边沿的蚂蚁，会从桌子上掉下去。问：有哪些蚂蚁会从左边掉下去，又有哪些蚂蚁会从右边掉下去？</p>
<img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181155170.jpeg" alt="img" style="zoom:25%;">
<h4 id="大顶堆"><a class="markdownIt-Anchor" href="#大顶堆"></a> 大顶堆</h4>
<img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181328092.png" alt="img" style="zoom:25%;">

          </div>
          
          <footer class="post-footer">
            <div class="post-tags">
              
                
                  <a href="/tags/%E6%89%8B%E5%86%8C/" class="post-tag">
                    手册
                  </a>
                
              
            </div>
          </footer>
        </article>
        <!-- 版权信息显示 -->
        
          <div class="post-copyright">
            <span>
              本文采用
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">
                CC BY-NC-SA 4.0
              </a>
              协议进行许可，转载请注明出处。
            </span>
          </div>
        
      </div>
      
      <!-- 文章目录 -->
      
        <!-- 确保目录生成参数正确 -->
        <div class="post-toc-wrapper">
          <div class="post-toc">
            <div class="toc-content">
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text"> 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text"> 线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.2.</span> <span class="toc-text"> 栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.3.</span> <span class="toc-text"> 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 顺序队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 循环队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text"> 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 动态数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text"> 树和二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#avl-tree"><span class="toc-number">1.5.3.</span> <span class="toc-text"> AVL Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.3.1.</span> <span class="toc-text"> 平衡化操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ll%E5%9E%8B"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text"> LL型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rr%E5%9E%8B"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text"> RR型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lr%E5%9E%8B"><span class="toc-number">1.5.3.1.3.</span> <span class="toc-text"> LR型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rl%E5%9E%8B"><span class="toc-number">1.5.3.1.4.</span> <span class="toc-text"> RL型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">1.5.4.</span> <span class="toc-text"> 二叉查找树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.5.5.</span> <span class="toc-text"> 红黑树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">1.6.</span> <span class="toc-text"> 图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 邻接矩阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">1.7.</span> <span class="toc-text"> 字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text"> 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bubble-sort"><span class="toc-number">1.8.1.</span> <span class="toc-text"> Bubble sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selection-sort"><span class="toc-number">1.8.2.</span> <span class="toc-text"> Selection sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insertion-sort"><span class="toc-number">1.8.3.</span> <span class="toc-text"> Insertion sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell-sort"><span class="toc-number">1.8.4.</span> <span class="toc-text"> Shell sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge-sort"><span class="toc-number">1.8.5.</span> <span class="toc-text"> Merge sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quick-sort"><span class="toc-number">1.8.6.</span> <span class="toc-text"> Quick sort</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#time-complexity"><span class="toc-number">1.8.6.1.</span> <span class="toc-text"> Time complexity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#optimization"><span class="toc-number">1.8.6.2.</span> <span class="toc-text"> Optimization</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#one-sided-recursive-optimization"><span class="toc-number">1.8.6.2.1.</span> <span class="toc-text"> One-sided recursive optimization</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#optimization-of-benchmark-value-selection"><span class="toc-number">1.8.6.2.2.</span> <span class="toc-text"> Optimization of benchmark value selection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#partition-operation-optimization"><span class="toc-number">1.8.6.2.3.</span> <span class="toc-text"> Partition Operation Optimization</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#heapsort"><span class="toc-number">1.8.7.</span> <span class="toc-text"> Heapsort</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E9%A1%B6%E5%A0%86"><span class="toc-number">1.8.7.1.</span> <span class="toc-text"> 大顶堆</span></a></li></ol></li></ol></li></ol></li></ol>
            </div>
          </div>
        </div>
      
    </div>
  </div>
</div>
  
  <div class="footer">
  <div class="container">
    <div class="footer-inner">
      <div class="copyright">
        © 2025 Dezeem
        <span class="powered-by">
          Powered by<a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>
        </span>
        <span class="theme-info">
          | Theme
          <a href="https://github.com/dezeem/hexo-theme-canary" target="_blank" rel="noopener">Canary</a>
        </span>
      </div>
      
    </div>
  </div>
</div>
  
  <!-- 移动导航切换按钮 -->
  <div class="mobile-nav-toggle">
    <i class="fas fa-bars"></i>
  </div>
  
  <!-- 移动导航菜单 -->
  <div class="mobile-nav">
  <div class="mobile-nav-inner">
    <div class="mobile-nav-header">
      <div class="logo">
        <a href="/">Dezeem&#39;log</a>
      </div>
      <button class="mobile-nav-close">
        <i class="fas fa-times"></i>
      </button>
    </div>
    
    <nav class="mobile-menu">
      <ul>
        
          <li><a href="/archives">archives</a></li>
        
          <li><a href="/categories">categories</a></li>
        
          <li><a href="/tags">tags</a></li>
        
          <li><a href="/essays">essays</a></li>
        
          <li><a href="/about">about</a></li>
        
      </ul>
    </nav>
    
    <div class="mobile-nav-footer">
      <div class="language-switch">
        <a href="#" class="lang-btn " data-lang="zh-CN">中文</a>
        <a href="#" class="lang-btn active" data-lang="en">EN</a>
      </div>
      
      <div class="theme-switch">
        <button id="mobile-theme-toggle" aria-label="Toggle Dark Mode">
          <i class="fas fa-moon dark-icon"></i>
          <i class="fas fa-sun light-icon"></i>
        </button>
      </div>
    </div>
  </div>
</div>
  
  <script>
    // 初始化 KaTeX
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false}
        ]
      });
    });
  </script>
</body>
</html>