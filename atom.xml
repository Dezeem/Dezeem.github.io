<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dezeem&#39;log</title>
  
  <subtitle>romantic</subtitle>
  <link href="http://dezeem.github.io/atom.xml" rel="self"/>
  
  <link href="http://dezeem.github.io/"/>
  <updated>2024-12-12T14:07:10.105Z</updated>
  <id>http://dezeem.github.io/</id>
  
  <author>
    <name>Dezeem</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>スパークル</title>
    <link href="http://dezeem.github.io/2024/12/13/2024-12-12-Spark_Lyrics/"/>
    <id>http://dezeem.github.io/2024/12/13/2024-12-12-Spark_Lyrics/</id>
    <published>2024-12-12T20:00:00.000Z</published>
    <updated>2024-12-12T14:07:10.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="スパークル"><a href="#スパークル" class="headerlink" title="スパークル"></a>スパークル</h1><p>まだこの世界は 僕を飼いならしてたいみたいだ<br>这个世界 好像仍想驯服我呢<br>望み通りいいだろう 美しくもがくよ<br>那就如你所愿吧 我会美丽的挣扎</p><p>互いの砂時計 眺めながらキスをしようよ<br>凝视着你我手中的沙漏 亲吻吧<br>「さよなら」から一番 遠い 場所で待ち合わせよう<br>在离「再见」最远的地方 等候吧</p><p>ついに時はきた 昨日までは序章の序章で<br>这一刻终于到来了 昨天为止都是序章的序章<br>飛ばし読みでいいから ここからが僕だよ<br>跳过不读也无妨 今天开始才是真正的我<br>経験と知識と カビの生えかかった勇気を持って<br>怀着经验与知识 和一身铁迹斑斑的勇气<br>いまだかつてないスピードで君のもとへダイブを<br>以前所未有的速度 冲到你的身边</p><p>まどろみの中で 生温いコーラに<br>打盹时梦见的 温热的可乐<br>ここでないどっかを 夢見たよ<br>和这里不存在的某处<br>教室の窓の外に<br>教室的窗外<br>電車に揺られ 運ばれる朝に<br>清晨摇摇晃晃的电车</p><p>運命だとか未来とかって 言葉がどれだけ手を<br>命运啊未来啊 这样的词语 无论如何伸手<br>伸ばそうと届かない 場所で僕ら恋をする<br>也无法触及 在这样的地方 我们相爱着<br>時計の針も二人を 横目に見ながら進む<br>无视时钟的指针 前行着<br>こんな世界を二人で 一生 いや、何章でも<br>我们在这样的世界里 一直 一直<br>生き抜いていこう<br>共度余生</p><p>「初めまして」なんてさ 遥か彼方へと追いやって<br>「初次见面」啊 追逐着遥远的你<br>1000年周期を 一日で息しよう<br>千年的等待 转瞬即逝</p><p>辞書にある言葉で 出来上がった世界を憎んだ<br>憎恨这个用字典里的词汇勾画出的世界<br>万華鏡の中で 八月のある朝<br>万花筒中 八月的某个清晨</p><p>君は僕の前で ハニかんでは澄ましてみせた<br>你在我面前 露出了澄澈的笑容<br>この世界の教科書のような笑顔で<br>宛如这世界的教科书一般</p><p>嘘みたいな日々を 規格外の意味も<br>谎言般的日子 标准之外的意义<br>悲劇だっていいから 望んだよ<br>即使是悲剧也无妨 仍旧期盼着<br>そしたらドアの外に<br>那样就能将门外的你<br>君が全部抱えて 立ってたよ<br>紧紧抱在怀里 久久相依</p><p>運命だとか未来とかって 言葉がどれだけ手を<br>命运啊未来啊 这样的词语 无论如何伸手<br>伸ばそうと届かない 場所で 僕ら遊ぼうか<br>也无法触及 在这样的地方 我们游荡着</p><p>愛し方さえも 君の匂いがした<br>就连恋爱的方式 也散发着你的气息<br>歩き方さえも その笑い声がした<br>就连走路的方式 也回荡着你的笑声</p><p>いつか消えてなくなる 君のすべてを<br>你的一切 终有一日会消散不见<br>この眼に焼き付けておくことは<br>但我将永远铭记在心<br>もう権利なんかじゃない 義務だと思うんだ<br>这不是什么权利 而是我的义务啊</p><p>運命だとか未来とかって 言葉がどれだけ手を<br>命运啊未来啊 这样的词语 无论如何伸手<br>伸ばそうと届かない 場所で僕ら恋をする<br>也无法触及 在这样的地方 我们相爱着<br>時計の針も二人を 横目に見ながら進む<br>无视时钟的指针 前行着<br>そんな世界を二人で 一生 いや、何章でも<br>我们在这样的世界里 一直 一直</p><p>生き抜いていこう<br>共度余生</p><p>終わり<br>终</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;スパークル&quot;&gt;&lt;a href=&quot;#スパークル&quot; class=&quot;headerlink&quot; title=&quot;スパークル&quot;&gt;&lt;/a&gt;スパークル&lt;/h1&gt;&lt;p&gt;まだこの世界は 僕を飼いならしてたいみたいだ&lt;br&gt;这个世界 好像仍想驯服我呢&lt;br&gt;望み通りいいだろう 美しくもが</summary>
      
    
    
    
    <category term="歌词" scheme="http://dezeem.github.io/categories/%E6%AD%8C%E8%AF%8D/"/>
    
    
    <category term="RADWIMPS" scheme="http://dezeem.github.io/tags/RADWIMPS/"/>
    
  </entry>
  
  <entry>
    <title>Effectivate C++</title>
    <link href="http://dezeem.github.io/2024/01/16/2024-01-15-C++%E8%BF%9B%E9%98%B6/"/>
    <id>http://dezeem.github.io/2024/01/16/2024-01-15-C++%E8%BF%9B%E9%98%B6/</id>
    <published>2024-01-15T20:30:00.000Z</published>
    <updated>2024-05-08T12:56:13.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="effectivate-c"><a href="#Effectivate-C" class="headerlink" title="Effectivate C++"></a>Effectivate C++</h1><h2 id="习惯c"><a href="#习惯C" class="headerlink" title="习惯C++"></a>习惯C++</h2><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><p><strong>视C++为一个语言联邦</strong></p><p><strong>次语言:</strong></p><ul><li>C语言：以C语言为基础。</li><li>Object-Oriented C++：面向对象程序设计</li><li>Template C++：泛型编程</li><li>STL：程序库</li></ul><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><p><strong>尽量以const, enum, inline替代 #define</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASPECT_RATIO 1.653 <span class="comment">//避免这种写法</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> AspectRatio = <span class="number">1.653</span> <span class="comment">//替换</span></span><br></pre></td></tr></table></figure><ul><li>对于单纯常量，最好以const对象或enums替换#defines</li><li>对于形似函数的宏（macros），最好改用inline函数替换#defines</li></ul><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><p><strong>尽可能使用const</strong></p><h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><p><strong>确定对象在被使用前已先被初始化</strong></p><h1 id="c资源管理"><a href="#C-资源管理" class="headerlink" title="C++资源管理"></a>C++资源管理</h1><h2 id="堆heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h2><p>在内存管理的语境下，堆——动态分配内存的区域，有别于数据结构的堆</p><p>此内存被分配后需要手动释放，否则造成内存泄漏。</p><p>自由存储区——free store</p><ul><li>特指用new和delete来分配和释放内存区域</li><li>new和delete的底层通常使用malloc和free实现</li></ul><p>malloc和free的操作区域是heap</p><h2 id="栈stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h2><p>在内存管理的语境下，栈——函数调用过程中产生的本地变量和调用数据的区域，和数据结构的栈高度类似，满足FIFO。</p><h2 id="rall"><a href="#RALL" class="headerlink" title="RALL"></a>RALL</h2><p>Resource Acquisition Is Initialization——C++是主流编程语言中唯一依赖RALL做资源管理，依托栈和析构函数</p><p>在包括 x86 在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。</p><h1 id="重新认识c"><a href="#重新认识C" class="headerlink" title="重新认识C++"></a>重新认识C++</h1><h2 id="程序的生命周期"><a href="#程序的生命周期" class="headerlink" title="程序的生命周期"></a>程序的生命周期</h2><p>编码(Coding)→预处理(Pre-processing)→编译(Compiling)→运行(Running)</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p><a href="http://openresty.org/cn/c-coding-style-guide.html">OpenResty® C 代码风格指南</a></p><p>最基本的要求是遵循语言规范和设计文档，再者还有代码规范、注释规范、设计模式、编程惯用法等</p><p>代码风格</p><ul><li>空格和空行<ul><li>留白的艺术——像‘写诗’一样去写代码</li></ul></li><li>起个好名字<ul><li>变量、函数名和名字空间用 snake_case，全局变量加“g_”前缀；</li><li>自定义类名用 CamelCase，成员函数用 snake_case，成员变量加“m_”前缀；</li><li>宏和常量应当全大写，单词之间用下划线连接；</li><li>尽量不要用下划线作为变量的前缀或者后缀（比如 _local、name_），很难识别;</li></ul></li><li>注释</li></ul><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>C&#x2F;C++程序独有。预处理器（Pro-processer）起作用。“预处理”的目的是文字替换，即各种预处理指令，比如 #include、#define、#if 等，实现“预处理编程”。</p><p>预处理阶段编程的操作目标是“源码”，用各种指令控制预处理器，把源码<br>改造成另一种形式，就像是捏橡皮泥一样。</p><ul><li>预处理指令都以符号“#”开头</li><li>单独的一个“#”也是一个预处理指令，叫“空指令”</li><li>“#include”，它的作用是“包含文件”，可以包含任意的文件</li><li>使用“#if 1”“#if 0”来显式启用或者禁用大段代码，比“&#x2F;* …*&#x2F;”的注释方式安全</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译和链接。经过编译器和链接器的“锤炼”，生成可在计算机上运行的二进制机器码。编译的过程中，编译器还会根据 C++ 语言规则检查程序的语法、语义是否正确，发现错误就会产生“编译失败”。这是最基本的 C++“静态检查”。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>C++11，标准委员会认识到了“编译指令”的好处，把“民间”用法升级为“官方版本”，起名叫“属性”。可以理解为给变量、函数、类等“贴”上一个编译阶段的“标签”，方便编译器识别处理。</p><p>“属性”没有新增关键字，而是用两对方括号形式“[[…]]”，方括号的中间就是属性标签。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[noreturn]] <span class="comment">// 属性标签</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">bool</span> flag)</span> <span class="comment">// 函数绝不会返回任何值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">throw_std::<span class="built_in">runtime_error</span>(<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> C++11 里只定义了两个属性：“noreturn”和“carries_dependency”，它们<br>基本上没什么大用处。C++14 增加了一个比较实用的属性“deprecated”，用来标记不推<br>荐使用的变量、函数或者类，也就是被“废弃”。</p><p>比如，原来写了一个函数 old_func()，后来觉得不够好，就另外重写了一个完全不同的新函数。但是，那个老函数已经发布出去被不少人用了，立即删除不太可能，该怎么办呢？<br>这个时候，可以让“属性”发挥威力了。你可以给函数加上一个“deprecated”的编译期标签，再加上一些说明文字：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">deprecated</span>(<span class="string">&quot;deadline:2020-12-31&quot;</span>)]]</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">old_func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>于是，任何用到这个函数的程序都会在编译时看到这个标签，报出一条警告：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: ‘<span class="function"><span class="type">int</span> <span class="title">old_func</span><span class="params">()</span>’ is deprecated: deadline:<span class="number">2020</span><span class="number">-12</span><span class="number">-31</span> [-Wdeprecated-decl</span></span><br></pre></td></tr></table></figure><p>程序能够正常编译，但这种强制的警告形式会“提醒”用户旧接口已经被废弃了，应该尽快迁移到新接口。这种形式比毫无约束力的文档或者注释要好得多。</p><h4 id="静态断言static_assert"><a href="#静态断言（static-assert）" class="headerlink" title="静态断言（static_assert）"></a>静态断言（static_assert）</h4><p>static_assert 运行在编译阶段，只能看到编译时的常数和类型，看不到运行时的变量、指针、内存数据等，是“静态”的。</p><p><strong>编程范式</strong></p><p>编程范式（Paradigm）。“编程范式”是一种“方法论”，就是指导你编写代码的一些思路、规则、习惯、定式和常用语。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>CPU 利用率通常是评价程序运行的好坏最直观、最容易获取的指标，优化它是提升系统性能最快速的手段。</p><h4 id="系统级工具"><a href="#系统级工具" class="headerlink" title="系统级工具"></a>系统级工具</h4><p>四个“高性价比”的工具：top、pstack、strace 和 perf。它们用起来很简单，而且实用性很强，可以观测到程序的很多外部参数和内部函数调用，由内而外、由表及里地分析程序性能。</p><p>某个进程 CPU 使用率太高，怀疑有问题，那我就要深入进程内部，看看到底是哪些操作消耗了 CPU。这时，我们可以选用两个工具：pstack 和 strace。</p><p><em>pstack</em> 可以打印出进程的调用栈信息，有点像是给正在运行的进程拍了个快照，你能看到某个时刻的进程里调用的函数和关系，对进程的运行有个初步的印象。</p><p>pstack 显示的只是进程的一个“静态截面”，信息量还是有点少，而 <em>strace</em> 可以显示出进程的正在运行的系统调用，实时查看进程与系统内核交换了哪些信息。</p><p><em>perf</em> 可以说是 pstack 和 strace 的“高级版”，它按照固定的频率去“采样”，相当于连续执行多次的 pstack，然后再统计函数的调用次数，算出百分比。只要采样的频率足够大，把这些“瞬时截面”组合在一起，就可以得到进程运行时的可信数据，比较全面地描述出 CPU 使用情况。</p><p>常用的 perf 命令是“perf top -K -p xxx”，按 CPU 使用率排序，只看用户空间的调用。</p><h4 id="源码级工具"><a href="#源码级工具" class="headerlink" title="源码级工具"></a>源码级工具</h4><p>推荐一个专业的源码级性能分析工具：Google Performance Tools，简称为 gperftools。它是一个 C++ 工具集，包含了几个专门的性能分析工具（还有一个高效的内存分配器 tcmalloc），分析效果直观、友好、易理解，被广泛地应用于很多系统，经过了充分的实际验证。</p><p>编译运行后会得到一个“case1.perf”的文件，里面就是 gperftools 的分析数据，但它是<br>二进制的，不能直接查看，如果想要获得可读的信息，需要另外一个工具脚本 pprof。但是，pprof 脚本并不含在 apt-get 的安装包里，所以，你还要从GitHub上下载源码，然后用“–text”选项，就可以输出文本形式的分析报告。pprof 也能输出图形化的分析报告，支持有向图和火焰图，需要你提前安装 Graphviz和 FlameGraph。</p><h2 id="怎样写出好的类"><a href="#怎样写出“好”的类" class="headerlink" title="怎样写出“好”的类"></a>怎样写出“好”的类</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>抽象（Abstraction）和封装（Encapsulation）</p><h3 id="实现原则"><a href="#实现原则" class="headerlink" title="实现原则"></a>实现原则</h3><ul><li>在设计类的时候尽量少用继承和虚函数。</li><li>使用特殊标识符“final”可以禁止类被继承，简化类的层次关系。</li></ul><h3 id="编码准则"><a href="#编码准则" class="headerlink" title="编码准则"></a>编码准则</h3><p>在必须使用继承的场合，建议你只使用 public 继承，避免使用 virtual、protected</p><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><ul><li><p>“委托构造”（delegating constructor）</p><ul><li>&#96;&#96;&#96;c++<br>class DemoDelegating final<br>{<br>private:<br>int a;&#x2F;&#x2F; 成员变量<br>public:<br>DemoDelegating(int x) : a(x)&#x2F;&#x2F; 基本的构造函数<br>{}<br>DemoDelegating() :&#x2F;&#x2F; 无参数的构造函数<br>DemoDelegating(0)&#x2F;&#x2F; 给出默认值，委托给第一个构造函数<br>{}<br>DemoDelegating(const string&amp; s) : &#x2F;&#x2F; 字符串参数构造函数<br>DemoDelegating(stoi(s))&#x2F;&#x2F; 转换成整数，再委托给第一个构造函数<br>{}<br>};<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- “成员变量初始化”（In-class member initializer）</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    class DemoInit final</span><br><span class="line">    &#123;</span><br><span class="line">    private:</span><br><span class="line">            inta = 0;</span><br><span class="line">            strings =&quot;</span><br><span class="line">            vector&lt;int&gt;v&#123;1, 2, 3&#125;; </span><br><span class="line">    public:</span><br><span class="line">    DemoInit() = default;</span><br><span class="line">    ~DemoInit() = default;</span><br><span class="line">    public:</span><br><span class="line">    DemoInit(int x) : a(x) &#123;&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>“类型别名”（Type Alias）</p><ul><li>&#96;&#96;&#96;c++<br>using uint_t &#x3D; unsigned int;&#x2F;&#x2F; using别名<br>typedef unsigned int uint_t；    &#x2F;&#x2F; 等价的typedef<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 语言特性</span><br><span class="line"></span><br><span class="line">## 自动类型推导</span><br><span class="line"></span><br><span class="line">关键字 *auto*</span><br><span class="line"></span><br><span class="line">- auto 总是推导出“值类型”，绝不会是“引用”；</span><br><span class="line">- auto 可以附加上 const、volatile、*、&amp; 这样的类型修饰符，得到新的类型。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">auto x = 0L; // 自动推导为long</span><br><span class="line">auto y = &amp;x; // 自动推导为long*</span><br><span class="line">auto z &#123;&amp;x&#125;; // 自动推导为long*</span><br><span class="line">auto err;// 错误，没有赋值表达式，不知道是什么类型</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>C++ 的“自动类型推导”还有另外一个关键字：<em>decltype</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;<span class="comment">// 整型变量</span></span><br><span class="line"><span class="keyword">decltype</span>(x) x1;<span class="comment">// 推导为int，x1是int</span></span><br><span class="line"><span class="keyword">decltype</span>(x)&amp; x2 = x; <span class="comment">// 推导为int，x2是int&amp;，引用必须赋值</span></span><br><span class="line"><span class="keyword">decltype</span>(x)* x3;<span class="comment">// 推导为int，x3是int*</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;x) x4;<span class="comment">// 推导为int*，x4是int*</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;x)* x5;<span class="comment">// 推导为int*，x5是int**</span></span><br><span class="line"><span class="keyword">decltype</span>(x2) x6 = x2; <span class="comment">// 推导为int&amp;，x6是int&amp;，引用必须赋值</span></span><br></pre></td></tr></table></figure><p>decltype 不仅能够推导出值类型，还能够推导出引用类型，也就是表达式的“原始类<br>型”。</p><p>C++14 增加了一个“decltype(auto)”的形式，既可以精确推导类型，又能像<br>auto 一样方便使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;<span class="comment">// 整型变量</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x1 = (x); <span class="comment">// 推导为int&amp;，因为(expr)是引用类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x2 = &amp;x; <span class="comment">// 推导为int*</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x3 = x1; <span class="comment">// 推导为int&amp;</span></span><br></pre></td></tr></table></figure><p>auto 还有一个“最佳实践”，就是“range-based for”，不需要关心容器元素类型、迭<br>代器返回值和首末位置，就能非常轻松地完成遍历操作。不过，为了保证效率，最好使<br>用“const auto&amp;”或者“auto&amp;”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>&#125;; <span class="comment">// vector顺序容器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123; <span class="comment">// 常引用方式访问元素，避免拷贝代价</span></span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;,&quot;</span>;<span class="comment">// 常引用不会改变元素的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : v) &#123;<span class="comment">// 引用方式访问元素</span></span><br><span class="line">i++;<span class="comment">// 可以改变元素的值</span></span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量x2f变量"><a href="#常量-x2F-变量" class="headerlink" title="常量&#x2F;变量"></a>常量&#x2F;变量</h2><p>const&#x2F;volatile&#x2F;mutable</p><ul><li>const</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要加上volatile修饰，运行时才能看到效果</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">int</span> MAX_LEN = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">auto</span> ptr = (<span class="type">int</span>*)(&amp;MAX_LEN);</span><br><span class="line">*ptr = <span class="number">2048</span>;</span><br><span class="line">cout &lt;&lt; MAX</span><br><span class="line">LEN &lt;&lt; endl;<span class="comment">// 输出2048</span></span><br></pre></td></tr></table></figure><p>我从来不用“* const”的形式，也建议你最好不要用，而且这种形式在实际开发时也确实没有多大作用（除非你想“炫技”）。</p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202212171358334.png" alt="image-20221217135753980" style="zoom:67%;"><ul><li>mutable</li></ul><p>用来修饰成员变量，允许 const 成员函数修改，mutable 变量的变化不影响对象的常量性，但要小心不要误用损坏对象。你今后再写类的时候，就要认真想一想，哪些操作改变了内部状态，哪些操作没改变内部状态，对于只读的函数，就要加上 const 修饰。写错了也不用怕，编译器会帮你检查出来。</p><ul><li>volatile</li></ul><p>它表示变量可能会被“不被察觉”地修改，禁止编译器优化，影响性能，应当少用。</p><p><strong>尽可能多用 const，让代码更安全</strong></p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202212171403172.png" alt="image-20221217140232505" style="zoom:50%;"><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>常用的有两种智能指针，分别是 unique_ptr 和 shared_ptr</p><ul><li>unique_ptr</li></ul><p>unique_ptr 是最简单、最容易使用的一个智能指针，在声明的时候必须用模板参数指定类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;<span class="comment">// int智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(*ptr1 = <span class="number">10</span>);<span class="comment">// 可以使用*取内容</span></span><br><span class="line"><span class="built_in">assert</span>(ptr1 != <span class="literal">nullptr</span>);<span class="comment">// 可以判断是否为空指针</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello&quot;</span>))</span></span>; <span class="comment">// string智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(*ptr2 == <span class="string">&quot;hello&quot;</span>);<span class="comment">// 可以使用*取内容</span></span><br><span class="line"><span class="built_in">assert</span>(ptr2-&gt;<span class="built_in">size</span>() == <span class="number">5</span>);<span class="comment">// 可以使用-&gt;调用成员函数</span></span><br></pre></td></tr></table></figure><p>unique_ptr 虽然名字叫指针，用起来也很像，但它实际上并不是指针，而是一个对象。所以，不要企图对它调用 delete，它会自动管理初始化时的指针，在离开作用域时析构释放内存。</p><p>它也没有定义加减运算，不能随意移动指针地址，完全避免了指针越界等危险。</p><p>未初始化的 unique_ptr 表示空指针，这样就相当于直接操作了空指针，运行时就会产生致命的错误。<br>为了避免这种低级错误，可以调用工厂函数 make_unique()，强制创建智能指针的时候必须初始化。同时还可以利用自动类型推导 auto，少写一些代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr3 = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);<span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(ptr3 &amp;&amp; *ptr3 == <span class="number">42</span>);</span><br><span class="line"><span class="keyword">auto</span> ptr4 = <span class="built_in">make_unique</span>&lt;string&gt;(<span class="string">&quot;god of war&quot;</span>); <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(!ptr4-&gt;<span class="built_in">empty</span>());</span><br></pre></td></tr></table></figure><p>尽量不要对 unique_ptr 执行赋值操作</p><ul><li>shared_ptr</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>; <span class="comment">// int智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(*ptr1 = <span class="number">10</span>);<span class="comment">// 可以使用*取内容</span></span><br><span class="line"><span class="function">shared_ptr&lt;string&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello&quot;</span>))</span></span>; <span class="comment">// string智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(*ptr2 == <span class="string">&quot;hello&quot;</span>);<span class="comment">// 可以使用*取内容</span></span><br><span class="line"><span class="keyword">auto</span> ptr3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(ptr3 &amp;&amp; *ptr3 == <span class="number">42</span>);<span class="comment">// 可以判断是否为空指针</span></span><br><span class="line"><span class="keyword">auto</span> ptr4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="string">&quot;zelda&quot;</span>); <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(!ptr4-&gt;<span class="built_in">empty</span>());<span class="comment">// 可以使用-&gt;调用成员函数</span></span><br></pre></td></tr></table></figure><p>它的所有权是可以被安全共享的，也就是说支持拷贝赋值。</p><h2 id="exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><ul><li><em>异常的处理流程是完全独立的</em>，throw 抛出异常后就可以不用管了，错误处理代码都集中在专门的 catch 块里。这样就彻底分离了业务逻辑与错误逻辑，看起来更清楚。</li><li><em>异常是绝对不能被忽略的</em>，必须被处理。如果你有意或者无意不写 catch 捕获异常，那么它会一直向上传播出去，直至找到一个能够处理的 catch 块。如果实在没有，那就会导致程序立即停止运行，明白地提示你发生了错误，而不会“坚持带病工作”。</li><li><em>异常可以用在错误码无法使用的场合</em>，这也算是 C++ 的“私人原因”。因为它比 C 语言多了构造 &#x2F; 析构函数、操作符重载等新特性，有的函数根本就没有返回值，或者返回值无法表示错误，而全局的 errno 实在是“太不优雅”了，与 C++ 的理念不符，所以也必须使用异常来报告错误。</li></ul><h2 id="函数式编程-lambda"><a href="#函数式编程-lambda" class="headerlink" title="函数式编程 lambda"></a>函数式编程 lambda</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [](<span class="type">int</span> x)<span class="comment">// 定义一个lambda表达式</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x*x &lt;&lt; endl;<span class="comment">// lambda表达式的具体内容</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3</span>);<span class="comment">// 调用lambda表达式</span></span><br></pre></td></tr></table></figure><p>lambda 表达式除了可以像普通函数那样被调用，还有一个普通函数所不具备的特殊本领，就是可以“捕获”外部变量，在内部的代码里直接操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10</span>;<span class="comment">// 一个外部变量</span></span><br><span class="line"><span class="keyword">auto</span> func = [=](<span class="type">int</span> x)<span class="comment">// lambda表达式，用“=”值捕获</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x*n &lt;&lt; endl;<span class="comment">// 直接操作外部变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3</span>);<span class="comment">// 调用lambda表达式</span></span><br></pre></td></tr></table></figure><p>C++ 没有为 lambda 表达式引入新的关键字，并没有“lambda”这样的词汇，而是用了一个特殊的形式“[]”，术语叫“lambda 引出符”（lambda introducer）。在 lambda 引出符后面，就可以像普通函数那样，用圆括号声明入口参数，用花括号定义函数体。</p><h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li><p>字面量后缀</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::string_literals; <span class="comment">//必须打开名字空间</span></span><br><span class="line"><span class="keyword">auto</span> str = <span class="string">&quot;std string&quot;</span>s;<span class="comment">// 后缀s，表示是标准字符串，直接类型推导</span></span><br></pre></td></tr></table></figure></li><li><p>原始字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> str = <span class="string">R&quot;(nier:automata)&quot;</span>; <span class="comment">// 原始字符串：nier:automata</span></span><br></pre></td></tr></table></figure></li><li><p>字符串转换函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(<span class="built_in">stoi</span>(<span class="string">&quot;42&quot;</span>) == <span class="number">42</span>);<span class="comment">// 字符串转整数</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">stol</span>(<span class="string">&quot;253&quot;</span>) == <span class="number">253L</span>);<span class="comment">// 字符串转长整数</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">stod</span>(<span class="string">&quot;2.0&quot;</span>) == <span class="number">2.0</span>);<span class="comment">// 字符串转浮点数</span></span><br></pre></td></tr></table></figure></li><li><p>字符串视图类</p></li></ol><p><em>正则表达式</em></p><p>C++ 正则表达式主要有两个类。</p><ul><li>regex：表示一个正则表达式，是 basic_regex 的特化形式；</li><li>smatch：表示正则表达式的匹配结果，是 match_results 的特化形式。</li></ul><p>C++ 正则匹配有三个算法，注意它们都是“只读”的，不会变动原字符串。</p><ul><li>regex_match()：完全匹配一个字符串；</li><li>regex_search()：在字符串里查找一个正则匹配；</li><li>regex_replace()：正则查找再做替换。</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器，就是能够“容纳”“存放”元素的一些数据结构。</p><p>容器里存储的是元素的拷贝、副本，而不是引用。</p><ul><li>顺序容器<ul><li>即数据结构里的线性表，一共有 5 种：array、vector、deque、list、forward_list</li><li>连续存储的数组：array、vector 和 deque。<ul><li>array 和 vector 直接对应 C 的内置数组，内存布局与 C 完全兼容，所以是开销最低、速度最快的容器。区别在于，array 是静态数组，而 vector 是动态数组。</li><li>deque 也是动态数组，它可以在两端高效地插入删除元素，这也是它的名字double-end queue 的来历，而 vector 则只能用 push_back 在末端追加元素。</li></ul></li><li>指针结构的链表：list 和 forward_list<ul><li>list 是双向链表，而 forward_list是单向链表。</li></ul></li></ul></li><li>有序容器<ul><li>C++ 的有序容器使用的是树结构，通常是红黑树——有着最好查找性能的二叉树。</li><li>标准库里一共有四种有序容器：set&#x2F;multiset 和 map&#x2F;multimap。set 是集合，map 是关联数组（在其他语言里也叫“字典”）。</li><li>有 multi 前缀的容器表示可以容纳重复的 key，内部结构与无前缀的相同，所以也可以认为只有两种有序容器。</li><li>集合关系就用 set，关联数组就用 map。</li></ul></li><li>无序容器<ul><li>unordered_set&#x2F;unordered_multiset、unordered_map&#x2F;unordered_multimap。</li><li>内部数据结构不是红黑树，而是散列表（也叫哈希表，hash table）</li><li>如果只想要单纯的集合、字典，没有排序需求，就应该用无序容器，没有比较排序的成本，它的速度就会非常快。</li></ul></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><em>迭代器</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// array静态数组容器</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">begin</span>(arr);<span class="comment">// 全局函数获取迭代器，首端</span></span><br><span class="line"><span class="keyword">auto</span> e = <span class="built_in">end</span>(arr);<span class="comment">// 全局函数获取迭代器，末端</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">distance</span>(b, e) == <span class="number">5</span>); <span class="comment">// 迭代器的距离</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="built_in">next</span>(b);<span class="comment">// 获取“下一个”位置</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">distance</span>(b, p) == <span class="number">1</span>); <span class="comment">// 迭代器的距离</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">distance</span>(p, b) == <span class="number">-1</span>); <span class="comment">// 反向计算迭代器的距离</span></span><br><span class="line"><span class="built_in">advance</span>(p, <span class="number">2</span>);<span class="comment">// 迭代器前进两个位置，指向元素&#x27;3&#x27;</span></span><br><span class="line"><span class="built_in">assert</span>(*p == <span class="number">3</span>);</span><br><span class="line"><span class="built_in">assert</span>(p == <span class="built_in">prev</span>(e, <span class="number">2</span>)); <span class="comment">// 是末端迭代器的前两个位置</span></span><br></pre></td></tr></table></figure><p><code>for_each()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>&#125;; <span class="comment">// vector容器</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; x : v) &#123;<span class="comment">// range for循环</span></span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> print = [](<span class="type">const</span> <span class="keyword">auto</span>&amp; x) <span class="comment">// 定义一个lambda表达式</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">for_each(<span class="built_in">cbegin</span>(v), <span class="built_in">cend</span>(v), print);<span class="comment">// for_each算法</span></span><br><span class="line"></span><br><span class="line">for_each(<span class="comment">// for_each算法，内部定义lambda表达式</span></span><br><span class="line"><span class="built_in">cbegin</span>(v), <span class="built_in">cend</span>(v),<span class="comment">// 获取常量迭代器</span></span><br><span class="line">[](<span class="type">const</span> <span class="keyword">auto</span>&amp; x)<span class="comment">// 匿名lambda表达式</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><em>排序</em></p><ul><li>常见问题对应的算法：<ul><li>要求排序后仍然保持元素的相对顺序，应该用 stable_sort，它是稳定的；</li><li>选出前几名（TopN），应该用 partial_sort；</li><li>选出前几名，但不要求再排出名次（BestN），应该用 nth_element；</li><li>中位数（Median）、百分位数（Percentile），还是用 nth_element；</li><li>按照某种规则把元素划分成两组，用 partition；</li><li>第一名和最后一名，用 minmax_element。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202212181733088.png" alt="image-20221218173338732"></p><p><em>查找</em></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>“读而不写”就不会有数据竞争。</p><ul><li>多线程是并发最常用的实现方式，好处是任务并行、避免阻塞，坏处是开发难度高，有数据竞争、死锁等很多“坑”；</li><li>call_once() 实现了仅调用一次的功能，避免多线程初始化时的冲突；</li><li>thread_local 实现了线程局部存储，让每个线程都独立访问数据，互不干扰；</li><li>atomic 实现了原子化变量，可以用作线程安全的计数器，也可以实现无锁数据结构；</li><li>async() 启动一个异步任务，相当于开了一个线程，但内部通常会有优化，比直接使用线程更好。</li></ul><h1 id="技能进阶"><a href="#技能进阶" class="headerlink" title="技能进阶"></a>技能进阶</h1><h2 id="序列化x2f反序列化"><a href="#序列化-x2F-反序列化" class="headerlink" title="序列化&#x2F;反序列化"></a>序列化&#x2F;反序列化</h2><h3 id="json"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON 是一种轻量级的数据交换格式，采用纯文本表示，所以是“human readable”，阅<br>读和修改都很方便。</p><p>JSON for Modern C++ 可能不是最小最快的 JSON 解析工具，但功能足够完善，而且使<br>用方便，仅需要包含一个头文件“json.hpp”，没有外部依赖，也不需要额外的安装、编<br>译、链接工作，适合快速上手开发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:nlohmann/json.git <span class="meta"># git clone</span></span><br><span class="line">wget https:<span class="comment">//github.com/nlohmann/json/releases/download/v3.7.3/json.hpp</span></span><br></pre></td></tr></table></figure><h3 id="messagepack"><a href="#MessagePack" class="headerlink" title="MessagePack"></a>MessagePack</h3><p>它也是一种轻量级的数据交换格式，与 JSON 的不同之处在于它不是纯文本，而是二进制。由于二进制这个特点，MessagePack 也得到了广泛的应用，著名的有 Redis、Pinterest。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:msgpack/msgpack-c.git</span><br><span class="line">g++ msgpack.cpp -std=c++14 -I../common/include -o a.out</span><br></pre></td></tr></table></figure><h3 id="protobuffer"><a href="#ProtoBuffer" class="headerlink" title="ProtoBuffer"></a>ProtoBuffer</h3><p>通常简称为 PB，由 Google 出品。PB 也是一种二进制的数据格式，但毕竟是工业级产品，所以没有 JSON 和 MessagePack那么“轻”，相关的东西比较多，要安装一个预处理器和开发库，编译时还要链接动态库（-lprotobuf）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install protobuf-compiler</span><br><span class="line">apt-get install libprotobuf-dev</span><br><span class="line"></span><br><span class="line">g++ protobuf.cpp -std=c++14 -lprotobuf -o a.out</span><br></pre></td></tr></table></figure><p>PB 的另一个特点是数据有“模式”（schema），必须要先写一个 IDL（Interface Description Language）文件，定义好数据结构，只有预先定义了的数据结构，才能被序列化和反序列化。</p><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p><em>libcurl：高可移植、功能丰富的通信库</em></p><p><em>cpr：更现代、更易用的通信库</em></p><p>cpr 是对 libcurl 的一个 C++11 封装，使用了很多现代 C++ 的高级特性，对外的接口模仿了 Python 的 requests 库，非常简单易用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:whoshuu/cpr.git</span><br><span class="line">cmake . -DUSE_SYSTEM_CURL=ON -DBUILD_CPR</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><em>ZMQ：高效、快速、多功能的通信库</em></p><p>作为消息队列，ZMQ 的另一大特点是零配置零维护零成本，不需要搭建额外的代理服务器，只要安装了开发库就能够直接使用，相当于把消息队列功能直接嵌入到你的应用程序里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libzmq3-dev</span><br></pre></td></tr></table></figure><p>ZMQ 是一个高级的网络通信库，支持多种通信模式，可以把消息队列功能直接嵌入应用程序，搭建出高效、灵活、免管理的分布式系统。</p><h2 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h2><h3 id="python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>pybind11 完全基于现代 C++ 开发（C++11 以上），所以没有兼容旧系统的负担。它使用了大量的现代 C++ 特性，不仅代码干净整齐，运行效率也更高。</p><p>pybind11 支持 Python2.7、Python3 和 PyPy，这里我用的是 Python3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python3-dev</span><br><span class="line">apt-get install python3-pip</span><br><span class="line">pip3 install pybind11</span><br></pre></td></tr></table></figure><h3 id="lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><p>第二个脚本语言是小巧高效的 Lua，号称是“最快的脚本语言”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:openresty/luajit2.git</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>常用有 5 个原则，也就是常说的“SOLID”。</p><ol><li>SRP，单一职责（Single ResponsibilityPrinciple）；</li><li>OCP，开闭（Open Closed Principle）；</li><li>LSP，里氏替换（Liskov Substitution Principle）；</li><li>ISP，接口隔离（Interface-Segregation Principle）；</li><li>DIP，依赖反转，有的时候也叫依赖倒置（Dependency Inversion Principle）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;effectivate-c&quot;&gt;&lt;a href=&quot;#Effectivate-C&quot; class=&quot;headerlink&quot; title=&quot;Effectivate C++&quot;&gt;&lt;/a&gt;Effectivate C++&lt;/h1&gt;&lt;h2 id=&quot;习惯c&quot;&gt;&lt;a href=&quot;#习惯</summary>
      
    
    
    
    <category term="C++" scheme="http://dezeem.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://dezeem.github.io/2023/06/06/2023-06-06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://dezeem.github.io/2023/06/06/2023-06-06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-06-06T09:14:13.000Z</published>
    <updated>2023-06-06T02:44:21.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define element type</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define struct of linked list</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define Status</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    ERROR,</span><br><span class="line">    SUCCESS</span><br><span class="line">&#125; Status;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">CreateList_Head</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));     <span class="comment">//创建头结点</span></span><br><span class="line">    L-&gt;next  =<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=s;                          <span class="comment">//插入结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    L = <span class="keyword">new</span> LNode;</span><br><span class="line">    <span class="built_in">CreateList_Head</span>(L);</span><br><span class="line">    <span class="built_in">TraverseList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKSIZE 10;              <span class="comment">//存储空间分配增量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100;    <span class="comment">//存储空间初始分配量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType* base;    <span class="comment">//栈底</span></span><br><span class="line">    ElemType* top;     <span class="comment">//栈顶</span></span><br><span class="line">    <span class="type">int</span> stacksize;          <span class="comment">//当前已分配的空间</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line">Status <span class="title function_">initStack</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S.base = (ElemType *)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!S.base)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack&amp; S, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top - S.base &gt;= S.stacksize)   <span class="comment">//如果栈满就追加空间</span></span><br><span class="line">    &#123;                           <span class="comment">//新增内存空间</span></span><br><span class="line">        S.base = (ElemType*)<span class="built_in">realloc</span>(S.base, (S.stacksize + <span class="number">10</span>) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!S.base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        S.top = S.base + S.stacksize;</span><br><span class="line">        S.stacksize += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++ = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack&amp; S, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote><p><strong>根据存储结构划分：1.链式队列2.循环队列3.单向队列4.双端队列</strong></p></blockquote><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line">&#125;Sequeue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeueInit</span><span class="params">(Sequeue &amp;Top)</span>&#123;<span class="comment">//队列的初始化</span></span><br><span class="line">    Top.front=<span class="number">0</span>;</span><br><span class="line">    Top.rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeueEmpty</span><span class="params">(Sequeue &amp;Top)</span>&#123;<span class="comment">//判队列为空</span></span><br><span class="line">    <span class="keyword">if</span>(Top.rear==Top.front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;队列不为空\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeuePush</span><span class="params">(Sequeue &amp;Top,<span class="type">int</span> m)</span>&#123;<span class="comment">//循环入队列</span></span><br><span class="line">   <span class="keyword">if</span>((Top.rear+<span class="number">1</span>)%MAXSIZE==Top.front)</span><br><span class="line">        &#123;<span class="built_in">printf</span>(<span class="string">&quot;队列已满&quot;</span>);&#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       Top.data[Top.rear]=m;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d已入队\n&quot;</span>,m);</span><br><span class="line">       Top.rear=(Top.rear+<span class="number">1</span>)%MAXSIZE;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeueTop</span><span class="params">(Sequeue &amp;Top)</span><span class="comment">//求队列头部元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列头部元素为%d\n&quot;</span>,Top.data[Top.front]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeuePop</span><span class="params">(Sequeue &amp;Top)</span>&#123;<span class="comment">//循环出队列</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Top.rear==Top.front)</span><br><span class="line">     &#123;<span class="built_in">printf</span>(<span class="string">&quot;队列为空&quot;</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (Top.rear!=Top.front) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;队第%d元素为%d\n&quot;</span>,i,Top.data[Top.front]);</span><br><span class="line">            Top.front=(Top.front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SequeueTopp</span><span class="params">(Sequeue &amp;Top)</span><span class="comment">//求队列头部元素( 返回值)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Top.data[Top.front];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SequeuePushh</span><span class="params">(Sequeue &amp;Top,<span class="type">int</span> m)</span>&#123;<span class="comment">//不循环入队列</span></span><br><span class="line">    Top.data[Top.rear]=m;</span><br><span class="line">    Top.rear++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">SequeuePopp</span><span class="params">(Sequeue &amp;Top)</span>&#123;<span class="comment">//不循环出队列</span></span><br><span class="line">    <span class="type">int</span> m=Top.data[Top.front];</span><br><span class="line">        Top.front++;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote><p><strong>C++：nullptr 专用于初始化空类型指针</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiNode</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType data;</span><br><span class="line">    BiNode *lchild, *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BiTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BiTree</span>( )&#123;</span><br><span class="line">        root = <span class="built_in">Creat</span>(root);<span class="comment">//构造函数，建立二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">BiTree</span>( )&#123;</span><br><span class="line">        <span class="built_in">Release</span>(root);   <span class="comment">//析构函数，释放各结点的存储空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="built_in">PreOrder</span>(root);   <span class="comment">//前序遍历二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(root);   <span class="comment">//中序遍历二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(root);   <span class="comment">//后序遍历二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LeverOrder</span><span class="params">( )</span></span>; <span class="comment">//层序遍历二叉树</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BiNode &lt;DataType&gt;*<span class="built_in">Creat</span>(BiNode&lt;DataType&gt; *bt); <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>;   <span class="comment">//析构函数调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>;   <span class="comment">//前序遍历函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>;   <span class="comment">//中序遍历函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>;   <span class="comment">//后序遍历函数</span></span><br><span class="line">    BiNode&lt;DataType&gt; *root;     <span class="comment">//指向根结点的头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">BiNode&lt;DataType&gt; *BiTree &lt;DataType&gt;:: <span class="built_in">Creat</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入扩展二叉树的前序遍历序列，每次输入一个字符:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; ch; <span class="comment">//输入结点的数据信息，假设为字符</span></span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) bt = <span class="literal">nullptr</span>; <span class="comment">//建立一棵空树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        bt = <span class="keyword">new</span> BiNode&lt;DataType&gt;;</span><br><span class="line">        bt-&gt;data = ch;</span><br><span class="line">        bt-&gt;lchild = <span class="built_in">Creat</span>(bt-&gt;lchild); <span class="comment">//递归建立左子树</span></span><br><span class="line">        bt-&gt;rchild = <span class="built_in">Creat</span>(bt-&gt;rchild); <span class="comment">//递归建立右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;<span class="comment">//前序遍历</span></span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">PreOrder</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>; </span><br><span class="line">    cout &lt;&lt; bt-&gt;data;   </span><br><span class="line">    <span class="built_in">PreOrder</span>(bt-&gt;lchild); </span><br><span class="line">    <span class="built_in">PreOrder</span>(bt-&gt;rchild); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;<span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">InOrder</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;lchild); </span><br><span class="line">        cout &lt;&lt; bt-&gt;data; </span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;<span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">PostOrder</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;lchild);</span><br><span class="line">        <span class="built_in">InOrder</span>(bt-&gt;rchild);</span><br><span class="line">        cout &lt;&lt; bt-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;<span class="comment">//层次遍历</span></span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">LeverOrder</span>( )</span><br><span class="line">&#123;</span><br><span class="line">    BiNode&lt;DataType&gt; *Q[<span class="number">100</span>], *q = <span class="literal">nullptr</span>; <span class="comment">//顺序队列</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>; <span class="comment">//队列初始化</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">//二叉树为空，算法结束</span></span><br><span class="line">    Q[++rear] = root; <span class="comment">//根指针入队</span></span><br><span class="line">    <span class="keyword">while</span> (front != rear) <span class="comment">//当队列非空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = Q[++front]; <span class="comment">//出队</span></span><br><span class="line">        cout &lt;&lt; q-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;lchild != <span class="literal">nullptr</span>) Q[++rear] = q-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;rchild != <span class="literal">nullptr</span>) Q[++rear] = q-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> BiTree&lt;DataType&gt;:: <span class="built_in">Release</span>(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Release</span>(bt-&gt;lchild); <span class="comment">//释放左子树</span></span><br><span class="line">        <span class="built_in">Release</span>(bt-&gt;rchild); <span class="comment">//释放右子树</span></span><br><span class="line">        <span class="keyword">delete</span> bt; <span class="comment">//释放根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="comment">//如果是空，则直接返回空vector</span></span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        queue&lt;TreeNode*&gt; q; <span class="comment">//队列存储，进行层次遍历</span></span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        TreeNode* cur;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//记录二叉树的某一行</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; row;  </span><br><span class="line">            <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">//因先进入的是根节点，故每层节点多少，队列大小就是多少</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                row.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="comment">//若是左右孩子存在，则存入左右孩子作为下一个层次</span></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每一层加入输出</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(row); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="avl-tree"><a href="#AVL-Tree" class="headerlink" title="AVL Tree"></a>AVL Tree</h3><blockquote><p>AVL树（Adelson-Velsky and Landis Tree）是CS中最早被发明的自平衡二叉查找树。</p></blockquote><p>一棵AVL树有如下必要条件：</p><ul><li>必须是二叉查找树</li><li>每个节点的左子树和右子树的高度差至多为1</li></ul><p><a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">AVL Tree Visualzation</a> <strong>可视化演示</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AVLnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> key;    <span class="comment">//值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLnode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLnode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> height;     <span class="comment">//高度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAVL</span><span class="params">(avlNode *node, <span class="type">int</span> level)</span><span class="comment">//树尖向左打印</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printAVL(node-&gt;right, level + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, node-&gt;key);</span><br><span class="line"></span><br><span class="line">        printAVL(node-&gt;left, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="平衡化操作"><a href="#平衡化操作" class="headerlink" title="平衡化操作"></a>平衡化操作</h4><p><a href="https://zhuanlan.zhihu.com/p/438604092">平衡二叉树 — 优雅的进行旋转</a></p><h5 id="ll型"><a href="#LL型" class="headerlink" title="LL型"></a>LL型</h5><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131014059.webp" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">avlNode *<span class="title function_">rightRotate</span><span class="params">(avlNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    avlNode *L = T-&gt;left;</span><br><span class="line">    avlNode *T3 = L-&gt;right;</span><br><span class="line"></span><br><span class="line">    L-&gt;right = T;</span><br><span class="line">    T-&gt;left = T3;</span><br><span class="line"></span><br><span class="line">    T-&gt;height = (Max(nodeHeight(T-&gt;left), nodeHeight(T-&gt;right)) + <span class="number">1</span>);</span><br><span class="line">    L-&gt;height = (Max(nodeHeight(L-&gt;left), nodeHeight(L-&gt;right)) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="rr型"><a href="#RR型" class="headerlink" title="RR型"></a>RR型</h5><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131019717.webp" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">avlNode *<span class="title function_">leftRotate</span><span class="params">(avlNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    avlNode *R= T-&gt;right;</span><br><span class="line">    avlNode *T3 = R-&gt;left;</span><br><span class="line"></span><br><span class="line">    R-&gt;left = z;</span><br><span class="line">    T-&gt;right = T3;</span><br><span class="line"></span><br><span class="line">    T-&gt;height = (Max(nodeHeight(T-&gt;left), nodeHeight(T-&gt;right)) + <span class="number">1</span>);</span><br><span class="line">    R-&gt;height = (Max(nodeHeight(R-&gt;left), nodeHeight(R-&gt;right)) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="lr型"><a href="#LR型" class="headerlink" title="LR型"></a>LR型</h5><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131021410.jpeg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avlNode *<span class="title function_">LeftRightRotate</span><span class="params">(avlNode *z)</span>&#123;</span><br><span class="line">    T-&gt;left = leftRotate(T-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> (rightRotate(T));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="rl型"><a href="#RL型" class="headerlink" title="RL型"></a>RL型</h5><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211131023406.webp" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avlNode *<span class="title function_">RightLeftRotate</span><span class="params">(avlNode *T)</span>&#123;</span><br><span class="line">    T-&gt;right = rightRotate(T-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (leftRotate(T));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><blockquote><p>​二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree）。</p></blockquote><p>一棵空树或者具有下列性质的二叉树：</p><ul><li>若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若任意结点的右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li><li>任意结点的左、右子树也分别为二叉查找树</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><blockquote><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树</p></blockquote><p>红黑树满足以下特征：</p><ul><li>节点分为红色或者黑色；</li><li>根节点必为黑色；</li><li>叶子节点都为黑色，且为null；</li><li>连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）；</li><li>从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点；</li><li>新加入到红黑树的节点为红色节点；(推断)</li></ul><p><em>类比234树——4阶B树</em></p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeNode</span> <span class="comment">//定义边表结点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//邻接点域</span></span><br><span class="line">    EdgeNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexNode</span> <span class="comment">//定义顶点表结点</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType vertex;</span><br><span class="line">    EdgeNode *firstEdge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">10</span>; <span class="comment">//图的最多顶点数</span></span><br><span class="line"><span class="type">int</span> visited[MaxSize] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALGraph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ALGraph</span>(DataType a[ ], <span class="type">int</span> n, <span class="type">int</span> e); <span class="comment">//构造函数，建立n个顶点e条边的图</span></span><br><span class="line">    ~<span class="built_in">ALGraph</span>( ); <span class="comment">//析构函数，释放邻接表各边表结点的存储空间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>; <span class="comment">//深度优先遍历图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>; <span class="comment">//广度优先遍历图</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VertexNode&lt;DataType&gt; adjlist[MaxSize]; <span class="comment">//存放顶点表的数组</span></span><br><span class="line">    <span class="type">int</span> vertexNum, edgeNum; <span class="comment">//图的顶点数和边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">ALGraph&lt;DataType&gt; :: <span class="built_in">ALGraph</span>(DataType a[ ], <span class="type">int</span> n, <span class="type">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    EdgeNode *s = <span class="literal">nullptr</span>;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) <span class="comment">//输入顶点信息，初始化顶点表</span></span><br><span class="line">    &#123;</span><br><span class="line">        adjlist[i].vertex = a[i];</span><br><span class="line">        adjlist[i].firstEdge = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; edgeNum; k++) <span class="comment">//依次输入每一条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入边所依附的两个顶点的编号：&quot;</span>;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j; <span class="comment">//输入边所依附的两个顶点的编号</span></span><br><span class="line">        s = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">        s-&gt;adjvex = j; <span class="comment">//生成一个边表结点s</span></span><br><span class="line">        s-&gt;next = adjlist[i].firstEdge; <span class="comment">//将结点s插入到第i个边表的表头</span></span><br><span class="line">        adjlist[i].firstEdge = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">ALGraph&lt;DataType&gt;  :: ~<span class="built_in">ALGraph</span>( )</span><br><span class="line">&#123;</span><br><span class="line">    EdgeNode *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = q = adjlist[i].firstEdge;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> q;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> ALGraph&lt;DataType&gt;  :: <span class="built_in">DFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    EdgeNode *p = <span class="literal">NULL</span>;</span><br><span class="line">    cout &lt;&lt; adjlist[v].vertex;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    p = adjlist[v].firstEdge; <span class="comment">//工作指针p指向顶点v的边表</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) <span class="comment">//依次搜索顶点v的邻接点</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span> (visited[j] == <span class="number">0</span>) <span class="built_in">DFTraverse</span>(j);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> ALGraph&lt;DataType&gt; :: <span class="built_in">BFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w, j, Q[MaxSize]; <span class="comment">//采用顺序队列</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>; <span class="comment">//初始化队列</span></span><br><span class="line">    EdgeNode *p = <span class="literal">nullptr</span>;</span><br><span class="line">    cout &lt;&lt; adjlist[v].vertex;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    Q[++rear] = v; <span class="comment">//被访问顶点入队</span></span><br><span class="line">    <span class="keyword">while</span> (front != rear) <span class="comment">//当队列非空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        w = Q[++front];</span><br><span class="line">        p = adjlist[w].firstEdge; <span class="comment">//工作指针p指向顶点v的边表</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            j = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span> (visited[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; adjlist[j].vertex;</span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//测试数据是图6-20(a)，边是(0 1)(0 3)(0 4)(1 2)(2 4)(3 2)(3 4)</span></span><br><span class="line">    <span class="type">char</span> ch[ ] = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function">ALGraph&lt;<span class="type">char</span>&gt; <span class="title">ALG</span><span class="params">(ch, <span class="number">5</span>, <span class="number">6</span>)</span></span>; <span class="comment">//建立具有5个顶点6条边的有向图</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;深度优先遍历序列是：&quot;</span>;</span><br><span class="line">    ALG.<span class="built_in">DFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;广度优先遍历序列是：&quot;</span>;</span><br><span class="line">    ALG.<span class="built_in">BFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************</span></span><br><span class="line"><span class="comment">邻接矩阵类MGraph的使用范例</span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">10</span>; <span class="comment">//图中最多顶点个数</span></span><br><span class="line"><span class="type">int</span> visited[MaxSize] = &#123;<span class="number">0</span>&#125;; <span class="comment">//全局数组变量visited初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MGraph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MGraph</span>(DataType a[ ], <span class="type">int</span> n, <span class="type">int</span> e); <span class="comment">//构造函数，建立具有n个顶点e条边的图</span></span><br><span class="line">    ~<span class="built_in">MGraph</span>( ) &#123; &#125;; <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>; <span class="comment">//深度优先遍历图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>; <span class="comment">//广度优先遍历图</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DataType vertex[MaxSize]; <span class="comment">//存放图中顶点的数组</span></span><br><span class="line">    <span class="type">int</span> edge[MaxSize][MaxSize]; <span class="comment">//存放图中边的数组</span></span><br><span class="line">    <span class="type">int</span> vertexNum, edgeNum; <span class="comment">//图的顶点数和边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">MGraph &lt;DataType&gt;:: <span class="built_in">MGraph</span>(DataType a[ ], <span class="type">int</span> n, <span class="type">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) <span class="comment">//存储顶点</span></span><br><span class="line">        vertex[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">            edge[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; edgeNum; k++) <span class="comment">//依次输入每一条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入边依附的两个顶点的编号：&quot;</span>;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j; <span class="comment">//输入边依附的两个顶点的编号</span></span><br><span class="line">        edge[i][j] = <span class="number">1</span>;</span><br><span class="line">        edge[j][i] = <span class="number">1</span>; <span class="comment">//置有边标志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> MGraph &lt;DataType&gt;:: <span class="built_in">DFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; vertex[v];</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">        <span class="keyword">if</span> (edge[v][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) <span class="built_in">DFTraverse</span>( j );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="type">void</span> MGraph &lt;DataType&gt;:: <span class="built_in">BFTraverse</span>(<span class="type">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w, j, Q[MaxSize]; <span class="comment">//采用顺序队列</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>; <span class="comment">//初始化队列</span></span><br><span class="line">    cout &lt;&lt; vertex[v];</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    Q[++rear] = v; <span class="comment">//被访问顶点入队</span></span><br><span class="line">    <span class="keyword">while</span> (front != rear) <span class="comment">//当队列非空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        w = Q[++front]; <span class="comment">//将队头元素出队并送到v中</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">            <span class="keyword">if</span> (edge[w][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; vertex[j];</span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch[ ]= &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">/* 测试数据六条边是：(0 1)(0 2)(0 3)(0 4)(1 2)(2 4) */</span></span><br><span class="line">    MGraph&lt;<span class="type">char</span>&gt; MG&#123;ch, <span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">//建立具有5个顶点6条边的无向图</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;深度优先遍历序列是：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    MG.<span class="built_in">DFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;广度优先遍历序列是：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    MG.<span class="built_in">BFTraverse</span>(<span class="number">0</span>); <span class="comment">//从顶点0出发进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">经典排序算法</a></p><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210221013239.png" alt="img"></p><h3 id="bubble-sort"><a href="#Bubble-sort" class="headerlink" title="Bubble sort"></a>Bubble sort</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                                <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123; <span class="number">61</span>, <span class="number">17</span>, <span class="number">29</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">60</span>, <span class="number">72</span>, <span class="number">21</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">62</span> &#125;;</span><br><span class="line">        <span class="type">int</span> len = (<span class="type">int</span>) <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">        <span class="built_in">bubble_sort</span>(arr, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="type">float</span> arrf[] = &#123; <span class="number">17.5</span>, <span class="number">19.1</span>, <span class="number">0.6</span>, <span class="number">1.9</span>, <span class="number">10.5</span>, <span class="number">12.4</span>, <span class="number">3.8</span>, <span class="number">19.7</span>, <span class="number">1.5</span>, <span class="number">25.4</span>, <span class="number">28.6</span>, <span class="number">4.4</span>, <span class="number">23.8</span>, <span class="number">5.4</span> &#125;;</span><br><span class="line">        len = (<span class="type">float</span>) <span class="built_in">sizeof</span>(arrf) / <span class="built_in">sizeof</span>(*arrf);</span><br><span class="line">        <span class="built_in">bubble_sort</span>(arrf, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                cout &lt;&lt; arrf[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="selection-sort"><a href="#Selection-sort" class="headerlink" title="Selection sort"></a>Selection sort</h3><p>Selection sort is a simple and intuitive sorting algorithm that is O(n²) time complex no matter what data goes in. So when using it, the smaller the data size, the better. The only advantage is that it doesn’t take up extra memory space.</p><p><strong>算法步骤</strong></p><ol><li>First, find the smallest (large) element in the unsorted sequence and store it at the beginning of the sorted sequence.</li><li>Then find the smallest (large) element from the remaining unsorted elements and put it at the end of the sorted sequence.</li><li>Repeat the second step until all elements are sorted.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">                min = j;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insertion-sort"><a href="#Insertion-sort" class="headerlink" title="Insertion sort"></a>Insertion sort</h3><p>The code implementation of insertion sort is not as simple and brutal as bubble sort and selection sort, but its principle should be the easiest to understand, because anyone who has played poker should be able to understand it in seconds. Insertion sort is one of the simplest and most intuitive sorting algorithms. It works by constructing an ordered sequence, and for unsorted data, scanning backward and forward in the sorted sequence to find the appropriate position and insert it.</p><p>Insertion sort, like bubble sort, also has an optimization algorithm called split-half insertion.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> key=arr[i];</span><br><span class="line">        <span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((j&gt;=<span class="number">0</span>) &amp;&amp; (key&lt;arr[j]))&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>]=key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shell-sort"><a href="#Shell-sort" class="headerlink" title="Shell sort"></a>Shell sort</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(T array[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; length / <span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(array[j], array[j - h]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="merge-sort"><a href="#Merge-sort" class="headerlink" title="Merge sort"></a>Merge sort</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代版</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    T *a = arr;</span><br><span class="line">    T *b = <span class="keyword">new</span> T[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line">            <span class="type">int</span> low = start, mid = <span class="built_in">min</span>(start + seg, len), high = <span class="built_in">min</span>(start + seg + seg, len);</span><br><span class="line">            <span class="type">int</span> k = low;</span><br><span class="line">            <span class="type">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="type">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        T *temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;Array, <span class="type">int</span> front, <span class="type">int</span> mid, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// preconditions:</span></span><br><span class="line">    <span class="comment">// Array[front...mid] is sorted</span></span><br><span class="line">    <span class="comment">// Array[mid+1 ... end] is sorted</span></span><br><span class="line">    <span class="comment">// Copy Array[front ... mid] to LeftSubArray</span></span><br><span class="line">    <span class="comment">// Copy Array[mid+1 ... end] to RightSubArray</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">LeftSubArray</span><span class="params">(Array.begin() + front, Array.begin() + mid + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">RightSubArray</span><span class="params">(Array.begin() + mid + <span class="number">1</span>, Array.begin() + end + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> idxLeft = <span class="number">0</span>, idxRight = <span class="number">0</span>;</span><br><span class="line">    LeftSubArray.<span class="built_in">insert</span>(LeftSubArray.<span class="built_in">end</span>(), numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">    RightSubArray.<span class="built_in">insert</span>(RightSubArray.<span class="built_in">end</span>(), numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">    <span class="comment">// Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = front; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LeftSubArray[idxLeft] &lt; RightSubArray[idxRight]) &#123;</span><br><span class="line">            Array[i] = LeftSubArray[idxLeft];</span><br><span class="line">            idxLeft++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Array[i] = RightSubArray[idxRight];</span><br><span class="line">            idxRight++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;Array, <span class="type">int</span> front, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (front + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(Array, front, mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(Array, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="built_in">Merge</span>(Array, front, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="quick-sort"><a href="#Quick-sort" class="headerlink" title="Quick sort"></a>Quick sort</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort_recursive</span><span class="params">(T arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    T mid = arr[end];</span><br><span class="line">    <span class="type">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换</span></span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right) <span class="comment">//试图在左侧找到一个比枢纽元更大的元素</span></span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right) <span class="comment">//试图在右侧找到一个比枢纽元更小的元素</span></span><br><span class="line">            right--;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[left], arr[right]); <span class="comment">//交换元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[left], arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>​During the partition process, both the head and tail pointers are scanned cyclically to the last position where the base value was placed. Thus, the head and tail pointer scans together are equivalent to scanning the entire region of the array to be sorted. Therefore, we can conclude that the time complexity of a single partition operation is O(n). The formula for the overall time complexity: T(n) &#x3D; n + T(L) + T(R).</p><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181007848.jpeg" alt="img"></p><p>Time complexity：$O(n\log_{2}{n})$</p><h4 id="optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h4><h5 id="one-sided-recursive-optimization"><a href="#One-sided-recursive-optimization" class="headerlink" title="One-sided recursive optimization"></a>One-sided recursive optimization</h5><p>​Mode：when this layer has finished the partition operation, let this layer continue to complete the partition operation to the left of the base value, while the sorting work to the right of the base value is left to the next layer of recursive functions to handle.</p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181111010.jpeg" alt="img" style="zoom:25%;"><p>function is called 4 times. </p><p>Without the method, the actual number is 7.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 进行一轮 partition 操作</span></span><br><span class="line">        <span class="comment">// 获得基准值的位置</span></span><br><span class="line">        <span class="type">int</span> ind = partition(arr, l, r);</span><br><span class="line">        <span class="comment">// 右侧正常调用递归函数 </span></span><br><span class="line">        quick_sort(arr, ind + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 用本层处理左侧的排序</span></span><br><span class="line">        r = ind - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="optimization-of-benchmark-value-selection"><a href="#Optimization-of-benchmark-value-selection" class="headerlink" title="Optimization of benchmark value selection"></a>Optimization of benchmark value selection</h5><p><em>three-point middle method</em> is to take the three values of the head, tail and middle elements of the sorting interval in each round, and then use the middle value after they are sorted as the base value for the current round.For example, suppose the three values of this round are 2, 9 and 7, and the middle value is 7, so the base value of this round is 7.</p><h5 id="partition-operation-optimization"><a href="#Partition-Operation-Optimization" class="headerlink" title="Partition Operation Optimization"></a>Partition Operation Optimization</h5><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181129919.png" alt="img" style="zoom: 25%;"><p>Let the head pointer look backward for red elements and the tail pointer look forward for green elements, then swap the elements pointed by the head and tail pointers and repeat the process until the head and tail pointers are interleaved and stop. </p><h3 id="heapsort"><a href="#Heapsort" class="headerlink" title="Heapsort"></a>Heapsort</h3><p>经典问题：蚂蚁问题</p><p>假设现在有一个水平面，上面有 8 只蚂蚁排成一排。方便起见，我们给所有的蚂蚁从左到右依次编号，编号为 1 到 8。从 0 秒开始，红色蚂蚁向左爬，蓝色蚂蚁向右爬，爬行的速度都是 1m&#x2F;s。如果有 2 只蚂蚁迎面碰到以后，这 2 只蚂蚁不会做任何的感情交流，而会立刻掉头向相反方向继续爬行。而爬行到桌子边沿的蚂蚁，会从桌子上掉下去。问：有哪些蚂蚁会从左边掉下去，又有哪些蚂蚁会从右边掉下去？</p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181155170.jpeg" alt="img" style="zoom:25%;"><h4 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h4><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202211181328092.png" alt="img" style="zoom:25%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;h2 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性</summary>
      
    
    
    
    <category term="算法" scheme="http://dezeem.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="手册" scheme="http://dezeem.github.io/tags/%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>刷题笔记</title>
    <link href="http://dezeem.github.io/2022/10/05/2022-10-04-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://dezeem.github.io/2022/10/05/2022-10-04-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-10-04T20:24:00.000Z</published>
    <updated>2022-10-18T01:24:21.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="洛谷"><a href="#洛谷" class="headerlink" title="洛谷"></a>洛谷</h1><h2 id="p1059-noip2006-普及组-明明的随机数"><a href="#P1059-NOIP2006-普及组-明明的随机数" class="headerlink" title="P1059 [NOIP2006 普及组] 明明的随机数"></a>P1059 [NOIP2006 普及组] 明明的随机数</h2><blockquote><p>数组去重排序</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;cin &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> a[m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)  cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a, a + m);  <span class="comment">// 排序</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">unique</span>(a, a + m) - a;  <span class="comment">//去重</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//unique(a, a+m)的返回值是a[m]的地址</span></span><br></pre></td></tr></table></figure><hr><h1 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h1><h3 id="bm1-反转链表"><a href="#BM1-反转链表" class="headerlink" title="BM1 反转链表"></a>BM1 反转链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pHead || !pHead-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ListNode *p = pHead,*r = pHead-&gt;next, *q = p;</span><br><span class="line">        <span class="keyword">while</span>(r-&gt;next)&#123;</span><br><span class="line">            p-&gt;next = r-&gt;next;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            q = r;</span><br><span class="line">            r = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        r-&gt;next = q;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pHead = r;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="二分查找x2f排序"><a href="#二分查找-x2F-排序" class="headerlink" title="二分查找&#x2F;排序"></a>二分查找&#x2F;排序</h2><h3 id="bm17-二分查找"><a href="#BM17-二分查找" class="headerlink" title="BM17 二分查找"></a>BM17 二分查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> high = nums.<span class="built_in">size</span>(), mid = high / <span class="number">2</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!high)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= high)&#123;</span><br><span class="line">            mid = (left + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="bm18-二维数组中的查找"><a href="#BM18-二维数组中的查找" class="headerlink" title="BM18 二维数组中的查找"></a>BM18 二维数组中的查找</h3><p>​在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p><p>[[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]]</p><p>给定 target &#x3D; 7，返回 true；给定 target &#x3D; 3，返回 false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; array,<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m, n, x, y;</span><br><span class="line">        m = array.<span class="built_in">size</span>();<span class="comment">//行数</span></span><br><span class="line">        n = array[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//列数</span></span><br><span class="line">        x = m<span class="number">-1</span>;y = <span class="number">0</span>;<span class="comment">//坐标定在左下角</span></span><br><span class="line">        <span class="keyword">while</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &lt;= n<span class="number">-1</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(target &lt; array[x][y])</span><br><span class="line">                   x--;<span class="comment">//遇小上移</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[x][y])</span><br><span class="line">                   y++;<span class="comment">//遇大右移</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="bm19-寻找峰值"><a href="#BM19-寻找峰值" class="headerlink" title="BM19 寻找峰值"></a>BM19 寻找峰值</h3><p>​给定一个长度为n的数组nums，请找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。</p><p>1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于</p><p>2.假设 nums[-1] &#x3D; nums[n] &#x3D; -\infty−∞</p><p>3.对于所有有效的 i 都有 nums[i] !&#x3D; nums[i + 1]</p><p>4.你可以使用O(logN)的时间复杂度实现此问题吗？</p><p>输入[2,4,1,2,7,8,4]时，会形成两个山峰，一个是索引为1，峰值为4的山峰，另一个是索引为5，峰值为8的山峰。</p><p><code>二分查找</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分法 fast-template</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//右边是往下，不一定有坡峰</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="comment">//右边是往上，一定能找到波峰</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其中一个波峰</span></span><br><span class="line">        <span class="keyword">return</span> right;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="bm20-数组中的逆序对"><a href="#BM20-数组中的逆序对" class="headerlink" title="BM20 数组中的逆序对"></a>BM20 数组中的逆序对</h3><p><strong>描述：</strong>数组中两个数，如果前一个数字大于后面的数字，则这两数组成一个逆序对。</p><p>输入一个数组,求出这个数组中的逆序对的总数P。输出P mod 1000000007的结果。</p><p><strong>要求：</strong>空间复杂度 O(n)，时间复杂度 O(nlogn)</p><p><strong>输入描述：</strong>题目保证输入的数组中没有的相同的数字</p><table><thead><tr><th align="center">输入示例</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">[1,2,3,4,5,6,7,0]</td><td align="center">7</td></tr><tr><td align="center">[1,2,3]</td><td align="center">0</td></tr></tbody></table><blockquote><p>归并排序</p></blockquote><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202208191238848.gif" alt="img"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> kmod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 在最外层开辟数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(data.size())</span></span>;</span><br><span class="line">        <span class="built_in">merge_sort__</span>(data, tmp, <span class="number">0</span>, data.<span class="built_in">size</span>() - <span class="number">1</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge_sort__</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, vector&lt;<span class="type">int</span>&gt; &amp;tmp, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> &amp;ret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">merge_sort__</span>(arr, tmp, l, mid, ret);</span><br><span class="line">        <span class="built_in">merge_sort__</span>(arr, tmp, mid + <span class="number">1</span>, r, ret);</span><br><span class="line">        <span class="built_in">merge__</span>(arr, tmp, l, mid, r, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge__</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, vector&lt;<span class="type">int</span>&gt; &amp;tmp, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r, <span class="type">int</span> &amp;ret)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                tmp[k++] = arr[j++];</span><br><span class="line">                ret += (mid - i + <span class="number">1</span>);</span><br><span class="line">                ret %= kmod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>, i = l; i &lt;= r; ++i, ++k)</span><br><span class="line">            arr[i] = tmp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm21-旋转数组的最小数字"><a href="#BM21-旋转数组的最小数字" class="headerlink" title="BM21 旋转数组的最小数字"></a>BM21 旋转数组的最小数字</h3><p><strong>描述</strong></p><p>有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p><p>要求：空间复杂度：O(1)，时间复杂度：O(logn)</p><p>输入：[3,4,5,1,2]返回值：1</p><p>输入：[3,100,200,3]返回值：3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = rotateArray.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//最小的数字在mid右边</span></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[right]) </span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//无法判断，一个一个试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] == rotateArray[right]) </span><br><span class="line">                right--;</span><br><span class="line">            <span class="comment">//最小数字要么是mid要么在mid左边</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rotateArray.<span class="built_in">size</span>(); i++) </span><br><span class="line">            <span class="comment">//每次维护最小值</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, rotateArray[i]); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm22-比较版本号"><a href="#BM22-比较版本号" class="headerlink" title="BM22 比较版本号"></a>BM22 比较版本号</h3><p>**描述:**比较版本号version1和version2的大小。</p><p>版本号是由修订号组成，修订号与修订号之间由一个”.”连接。1个修订号可能有多位数字组成，修订号可能包含前导0，且是合法的。例如，1.02.11，0.1，0.2都是合法的版本号。每个版本号至少包含1个修订号。修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。</p><p><strong>比较规则：</strong></p><p>一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如”0.1”和”0.01”的版本号是相等的</p><p>二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，”1.1”的版本号小于”1.1.1”。因为”1.1”的版本号相当于”1.1.0”，第3位修订号的下标为0，小于1</p><p>三. version1 &gt; version2 返回1，如果 version1 &lt; version2 返回-1，不然返回0.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;1.1&quot;,&quot;1.01&quot;返回值：0</span><br><span class="line">说明：version2忽略前导0，为&quot;1.1&quot;，和version相同，返回0 </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1 = version1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n2 = version2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//直到某个字符串结束</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n1 || j &lt; n2)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> num1 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从下一个点前截取数字</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; n1 &amp;&amp; version1[i] != <span class="string">&#x27;.&#x27;</span>)&#123; </span><br><span class="line">                num1 = num1 * <span class="number">10</span> + (version1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳过点</span></span><br><span class="line">            i++; </span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从下一个点前截取数字</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n2 &amp;&amp; version2[j] != <span class="string">&#x27;.&#x27;</span>)&#123; </span><br><span class="line">                num2 = num2 * <span class="number">10</span> + (version2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳过点</span></span><br><span class="line">            j++; </span><br><span class="line">            <span class="comment">//比较数字大小</span></span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num1 &lt; num2)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//版本号相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="bm27-按之字形顺序打印二叉树"><a href="#BM27-按之字形顺序打印二叉树" class="headerlink" title="BM27 按之字形顺序打印二叉树"></a>BM27 按之字形顺序打印二叉树</h3><p><strong>翻转数组！！！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">reverse</span>(row.<span class="built_in">begin</span>(), row.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p><em>栈方法</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        if (pRoot == NULL)   //如果是空，则直接返回空vector</span><br><span class="line">            return res;</span><br><span class="line">        stack&lt;TreeNode*&gt; q, q2;     //队列存储，进行层次遍历</span><br><span class="line">        q.push(pRoot);</span><br><span class="line">        TreeNode* cur;</span><br><span class="line">        int tag = 1;</span><br><span class="line">        while (!q.empty() || !q2.empty()) &#123;</span><br><span class="line">            //记录二叉树的某一行</span><br><span class="line">            vector&lt;int&gt; row;</span><br><span class="line">            int n = tag ? q.size() : q2.size();</span><br><span class="line">            //因先进入的是根节点，故每层节点多少，队列大小就是多少</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                cur = (tag) ? q.top() : q2.top();</span><br><span class="line">                if (tag)  q.pop();</span><br><span class="line">                else  q2.pop();</span><br><span class="line">                row.push_back(cur-&gt;val);</span><br><span class="line">                //若是左右孩子存在，则存入左右孩子作为下一个层次</span><br><span class="line">                if (tag) &#123;</span><br><span class="line">                    if (cur-&gt;left)</span><br><span class="line">                        q2.push(cur-&gt;left);</span><br><span class="line">                    if (cur-&gt;right)</span><br><span class="line">                        q2.push(cur-&gt;right);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (cur-&gt;right)</span><br><span class="line">                        q.push(cur-&gt;right);</span><br><span class="line">                    if (cur-&gt;left)</span><br><span class="line">                        q.push(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tag = !tag;</span><br><span class="line">            //每一层加入输出</span><br><span class="line">            res.push_back(row);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm28-二叉树的最大深度"><a href="#BM28-二叉树的最大深度" class="headerlink" title="BM28 二叉树的最大深度"></a>BM28 二叉树的最大深度</h3><p>求给定二叉树的最大深度，深度是指树的根节点到任一叶子节点路径上节点的数量。</p><p>最大深度是所有叶子节点的深度的最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param root TreeNode类</span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm29-二叉树中和为某一值的路径一"><a href="#BM29-二叉树中和为某一值的路径-一" class="headerlink" title="BM29 二叉树中和为某一值的路径(一)"></a>BM29 二叉树中和为某一值的路径(一)</h3><p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p><p>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点</p><p>2.叶子节点是指没有子节点的节点</p><p>3.路径只能从父节点到子节点，不能从子节点到父节点</p><p>4.总节点数目为n</p><p><em>递归</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点，且路径和为sum</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span> &amp;&amp; sum - root-&gt;val == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归进入子节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="堆x2f栈x2f队列"><a href="#堆-x2F-栈-x2F-队列" class="headerlink" title="堆&#x2F;栈&#x2F;队列"></a>堆&#x2F;栈&#x2F;队列</h2><h3 id="bm42-用两个栈实现队列"><a href="#BM42-用两个栈实现队列" class="headerlink" title="BM42 用两个栈实现队列"></a>BM42 用两个栈实现队列</h3><p>保证操作合法，即保证pop操作时队列内已有元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">                stack1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> node = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm43-包含min函数的栈"><a href="#BM43-包含min函数的栈" class="headerlink" title="BM43 包含min函数的栈"></a>BM43 包含min函数的栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(value);</span><br><span class="line">        <span class="keyword">if</span>(s2.<span class="built_in">empty</span>() || s2.<span class="built_in">top</span>() &gt; value)&#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(s2.<span class="built_in">top</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">pop</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm44-有效括号序列"><a href="#BM44-有效括号序列" class="headerlink" title="BM44 有效括号序列"></a>BM44 有效括号序列</h3><p>给出一个仅包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’,的字符串，判断给出的字符串是否是合法的括号序列<br>括号必须以正确的顺序关闭，”()”和”()[]{}”都是合法的括号序列，但”(]”和”([)]”不合法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//辅助栈</span></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st; </span><br><span class="line">        <span class="comment">//遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)&#123; </span><br><span class="line">            <span class="comment">//遇到左小括号</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) </span><br><span class="line">                <span class="comment">//期待遇到右小括号</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>); </span><br><span class="line">            <span class="comment">//遇到左中括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;[&#x27;</span>) </span><br><span class="line">                <span class="comment">//期待遇到右中括号</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>); </span><br><span class="line">            <span class="comment">//遇到左打括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="comment">//期待遇到右打括号 </span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>); </span><br><span class="line">            <span class="comment">//必须有左括号的情况下才能遇到右括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//右括号匹配则弹出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st.<span class="built_in">top</span>() == s[i]) </span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈中是否还有元素</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm45-滑动窗口的最大值"><a href="#BM45-滑动窗口的最大值" class="headerlink" title="BM45 滑动窗口的最大值"></a>BM45 滑动窗口的最大值</h3><ol><li>遍历数组的每一个元素，</li><li>如果容器为空，则直接将当前元素加入到容器中。</li><li>如果容器不为空，则让当前元素和容器的最后一个元素比较，如果大于，则将容器的最后一个元素删除，然后继续将当前元素和容器的最后一个元素比较</li><li>如果当前元素小于容器的最后一个元素，则直接将当前元素加入到容器的末尾</li><li>如果容器头部的元素已经不属于当前窗口的边界，则应该将头部元素删除</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxInWindows</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; num, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">size</span>() == <span class="number">0</span> || size &lt; <span class="number">1</span> || num.<span class="built_in">size</span>() &lt; size) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="type">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">           deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">               <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; num[dq.<span class="built_in">back</span>()] &lt; num[i]) &#123;</span><br><span class="line">                   dq.<span class="built_in">pop_back</span>();</span><br><span class="line">               &#125;</span><br><span class="line">               dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">               <span class="comment">// 判断队列的头部的下标是否过期</span></span><br><span class="line">               <span class="keyword">if</span> (dq.<span class="built_in">front</span>() + size &lt;= i) &#123;</span><br><span class="line">                   dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否形成了窗口</span></span><br><span class="line">               <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= size) &#123;</span><br><span class="line">                   ret.<span class="built_in">push_back</span>(num[dq.<span class="built_in">front</span>()]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ret; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm46-最小的k个数"><a href="#BM46-最小的K个数" class="headerlink" title="BM46 最小的K个数"></a>BM46 最小的K个数</h3><p>给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。</p><p><em>方法一：直接排序</em></p><p>直接排序，取前k个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span> || k&gt;input.<span class="built_in">size</span>()) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="built_in">sort</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;input.<span class="built_in">begin</span>(), input.<span class="built_in">begin</span>()+k&#125;);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>方法二：堆排序</em></p><p>建立一个容量为k的大根堆的<em>优先队列</em>。遍历一遍元素，如果队列大小&lt;k，就直接入队，否则，让当前元素与队顶元素相比，如果队顶元素大，则出队，将当前元素入队</p><p><strong>优先队列</strong> <a href="https://zhuanlan.zhihu.com/p/32225189">优先队列 - 知乎</a></p><blockquote><p>优先队列中，队列中的数据被赋予了优先级。当访问元素时，优先级最高的会先被删除。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span> || k &gt; input.<span class="built_in">size</span>()) <span class="keyword">return</span> ret;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> val : input) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (val &lt; pq.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                    pq.<span class="built_in">pop</span>();</span><br><span class="line">                    pq.<span class="built_in">push</span>(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>());</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>方法三：快排思想</em></p><p><strong>快速排序</strong>  <a href="https://www.bilibili.com/video/BV1K44y1k79z?share_source=copy_pc">视频讲解</a></p><blockquote><p>分治法思想</p></blockquote><p>对数组[l, r]一次快排partition过程可得到，[l, p), p, [p+1, r)三个区间,[l,p)为小于等于p的值<br>[p+1,r)为大于等于p的值。然后再判断p，利用二分法</p><ol><li>如果[l,p), p，也就是p+1个元素（因为下标从0开始），如果p+1 &#x3D;&#x3D; k, 找到答案</li><li>如果p+1 &lt; k, 说明答案在[p+1, r)区间内，</li><li>如果p+1 &gt; k , 说明答案在[l, p)内</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;input, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot = input[r<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> i = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=l; j&lt;r<span class="number">-1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[j] &lt; pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(input[i++], input[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(input[i], input[r<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span> || k &gt; input.<span class="built_in">size</span>()) <span class="keyword">return</span> ret;</span><br><span class="line">         <span class="type">int</span> l = <span class="number">0</span>, r = input.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">partition</span>(input, l, r);</span><br><span class="line">            <span class="keyword">if</span> (p+<span class="number">1</span> == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;input.<span class="built_in">begin</span>(), input.<span class="built_in">begin</span>()+k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p+<span class="number">1</span> &lt; k) &#123;</span><br><span class="line">                l = p + <span class="number">1</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;c</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="寻找第k大"><a href="#寻找第K大" class="headerlink" title="寻找第K大"></a>寻找第K大</h3><p>有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。</p><p>给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partion</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123; <span class="comment">//常规的快排划分，但这次是大数在左</span></span><br><span class="line">        <span class="type">int</span> temp = a[low];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &lt;= temp)</span><br><span class="line">                high--;</span><br><span class="line">            <span class="keyword">if</span>(low == high)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                a[low] = a[high];</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &gt;= temp)</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">if</span>(low == high)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                a[high] = a[low];</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = temp;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> K)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">partion</span>(a, low, high); <span class="comment">//先进行一轮划分，p下标左边的都比它大，下标右边都比它小</span></span><br><span class="line">        <span class="keyword">if</span>(K == p - low + <span class="number">1</span>)  <span class="comment">//若p刚好是第K个点，则找到</span></span><br><span class="line">            <span class="keyword">return</span> a[p];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p - low + <span class="number">1</span> &gt; K)  <span class="comment">//从头到p超过k个数组，则目标在左边</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSort</span>(a, low, p - <span class="number">1</span>, K);  <span class="comment">//递归左边</span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSort</span>(a, p + <span class="number">1</span>, high, K - (p - low + <span class="number">1</span>));  <span class="comment">//否则，在右边,递归右边,但是需要减去左边更大的数字的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> n, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm48-数据流中的中位数"><a href="#BM48-数据流中的中位数" class="headerlink" title="BM48 数据流中的中位数"></a>BM48 数据流中的中位数</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><blockquote><p>插入排序</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//记录输入流</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; val;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="comment">//val中没有数据，直接加入</span></span><br><span class="line">            val.<span class="built_in">push_back</span>(num); </span><br><span class="line">        <span class="comment">//val中有数据，需要插入排序</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历找到插入点</span></span><br><span class="line">            <span class="keyword">for</span>(; i &lt; val.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= val[i])&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            val.<span class="built_in">insert</span>(val.<span class="built_in">begin</span>() + i, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = val.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//奇数个数字</span></span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123; </span><br><span class="line">            <span class="comment">//类型转换</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">double</span>(val[n / <span class="number">2</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//偶数个数字</span></span><br><span class="line">        <span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="type">double</span> a = val[n / <span class="number">2</span>];</span><br><span class="line">            <span class="type">double</span> b = val[n / <span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><blockquote><p>堆排序（优先队列）</p></blockquote><ul><li>一个大根堆，存中位数左边的数据，</li><li>一个小根堆，存中位数右边的数据，</li><li>动态维护两个数据结构的大小，即最多只相差一个。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//大顶堆，元素数值较小</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; min; </span><br><span class="line">    <span class="comment">//小顶堆，元素数值都比大顶堆大</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; max;</span><br><span class="line">    <span class="comment">//维护两个堆，取两个堆顶部即可</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;       </span><br><span class="line">        <span class="comment">//先加入较小部分 </span></span><br><span class="line">        min.<span class="built_in">push</span>(num);</span><br><span class="line">        <span class="comment">//将较小部分的最大值取出，送入到较大部分</span></span><br><span class="line">        max.<span class="built_in">push</span>(min.<span class="built_in">top</span>());  </span><br><span class="line">        min.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//平衡两个堆的数量</span></span><br><span class="line">        <span class="keyword">if</span>(min.<span class="built_in">size</span>() &lt; max.<span class="built_in">size</span>())&#123;  </span><br><span class="line">            min.<span class="built_in">push</span>(max.<span class="built_in">top</span>());</span><br><span class="line">            max.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//奇数个</span></span><br><span class="line">        <span class="keyword">if</span>(min.<span class="built_in">size</span>() &gt; max.<span class="built_in">size</span>())  </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)min.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//偶数个</span></span><br><span class="line">            <span class="built_in">return</span> (<span class="type">double</span>)(min.<span class="built_in">top</span>() + max.<span class="built_in">top</span>()) / <span class="number">2</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm49-表达式求值"><a href="#BM49-表达式求值" class="headerlink" title="BM49 表达式求值"></a>BM49 表达式求值</h3><p>请写一个整数计算器，支持加减乘三种运算和括号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">function</span><span class="params">(string s, <span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack; </span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = index; i &lt; s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">//数字转换成int数字</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(i != s.<span class="built_in">length</span>() - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//碰到&#x27;(&#x27;时，把整个括号内的当成一个数字处理</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//递归处理括号</span></span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">function</span>(s, i + <span class="number">1</span>);</span><br><span class="line">                num = res[<span class="number">0</span>];</span><br><span class="line">                i = res[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(i != s.<span class="built_in">length</span>() - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;           </span><br><span class="line">            <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">            <span class="comment">//加减号先入栈</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: </span><br><span class="line">                stack.<span class="built_in">push</span>(num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="comment">//相反数</span></span><br><span class="line">                stack.<span class="built_in">push</span>(-num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//优先计算乘号</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:  </span><br><span class="line">                <span class="type">int</span> temp = stack.<span class="built_in">top</span>();</span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">                stack.<span class="built_in">push</span>(temp * num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//右括号结束递归</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                op = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//栈中元素相加</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())&#123;  </span><br><span class="line">            sum += stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;sum, i&#125;; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">function</span>(s, <span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="bm-50-两数之和"><a href="#BM-50-两数之和" class="headerlink" title="BM 50 两数之和"></a>BM 50 两数之和</h3><p><em>哈希表</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = numbers.<span class="built_in">size</span>(); </span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// unordered_map是用哈希表实现的，复杂度为O(1)，而map是用红黑树实现的</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashmap; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.<span class="built_in">find</span>(target - numbers[i]) != hashmap.<span class="built_in">end</span>()) &#123; </span><br><span class="line">                <span class="comment">// find函数返回hashmap.end()代表未找到，否则代表找到</span></span><br><span class="line">                <span class="comment">// 将结果存入数组</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(hashmap[target - numbers[i]] + <span class="number">1</span>); </span><br><span class="line">                res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashmap[numbers[i]] = i; <span class="comment">// 将未找到的值插入哈希表中，继续遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm51-数组中出现次数超过一半的数字"><a href="#BM51-数组中出现次数超过一半的数字" class="headerlink" title="BM51 数组中出现次数超过一半的数字"></a>BM51 数组中出现次数超过一半的数字</h3><p><em>哈希表</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> val : numbers) ++mp[val];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> val : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[val] &gt; numbers.<span class="built_in">size</span>() / <span class="number">2</span> ) <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)</span></span><br></pre></td></tr></table></figure><p><em>排序法</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> cond = numbers[numbers.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> k :numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cond == k) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; numbers.<span class="built_in">size</span>() / <span class="number">2</span>) <span class="keyword">return</span> cond;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(nlongn)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure><p><em>候选法</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cond = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                cond = numbers[i];</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cond == numbers[i]) ++cnt;</span><br><span class="line">                <span class="keyword">else</span> --cnt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> k :numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cond == k) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; numbers.<span class="built_in">size</span>() / <span class="number">2</span>) <span class="keyword">return</span> cond;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure><h3 id="bm52-数组中只出现一次的两个数字"><a href="#BM52-数组中只出现一次的两个数字" class="headerlink" title="BM52 数组中只出现一次的两个数字"></a>BM52 数组中只出现一次的两个数字</h3><p><em>哈希表</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>(); i++) </span><br><span class="line">            <span class="comment">//统计每个数出现的频率</span></span><br><span class="line">            mp[array[i]]++; </span><br><span class="line">        <span class="comment">//再次遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>(); i++) </span><br><span class="line">            <span class="comment">//找到频率为1的两个数</span></span><br><span class="line">            <span class="keyword">if</span>(mp[array[i]] == <span class="number">1</span>) </span><br><span class="line">                res.<span class="built_in">push_back</span>(array[i]);</span><br><span class="line">        <span class="comment">//整理次序</span></span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>] &lt; res[<span class="number">1</span>]) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> &#123;res[<span class="number">1</span>], res[<span class="number">0</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(n)，其中n为数组长度，两次单独的遍历数组每个元素</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)，哈希表的长度应该为(n−2)/2</span></span><br></pre></td></tr></table></figure><p><em>异或运算</em></p><p>​异或运算满足交换率，且相同的数字作异或会被抵消掉，比如：a⊕b⊕c⊕b⊕c&#x3D;a，且任何数字与0异或还是原数字，该题目里面所有数字异或运算就会得到a⊕b，也即得到了两个只出现一次的数字的异或和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历数组得到a^b</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) </span><br><span class="line">    temp ^= array[i];</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历数组得到a^b</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>(); i++) </span><br><span class="line">            temp ^= array[i];</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找到两个数不相同的第一位</span></span><br><span class="line">        <span class="keyword">while</span>((k &amp; temp) == <span class="number">0</span>) </span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">//遍历数组，对每个数分类</span></span><br><span class="line">            <span class="keyword">if</span>((k &amp; array[i]) == <span class="number">0</span>) </span><br><span class="line">                res[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[<span class="number">1</span>] ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//整理次序</span></span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>] &lt; res[<span class="number">1</span>]) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> &#123;res[<span class="number">1</span>], res[<span class="number">0</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(n)，遍历两次数组，找到两个数不相同的第一位循环为常数次</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)，常数级变量使用，无额外辅助空间</span></span><br></pre></td></tr></table></figure><h3 id="bm53-缺失的第一个正整数"><a href="#BM53-缺失的第一个正整数" class="headerlink" title="BM53 缺失的第一个正整数"></a>BM53 缺失的第一个正整数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberDisappeared</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="comment">//哈希表记录数组中出现的每个数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            mp[nums[i]]++;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从1开始找到哈希表中第一个没有出现的正整数</span></span><br><span class="line">        <span class="keyword">while</span>(mp.<span class="built_in">find</span>(res) != mp.<span class="built_in">end</span>()) </span><br><span class="line">            res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)</span></span><br></pre></td></tr></table></figure><p><em>原地哈希</em></p><ul><li>step 1：我们可以先遍历数组将所有的负数都修改成n+1。</li><li>step 2：然后再遍历数组，每当遇到一个元素绝对值不超过n时，则表示这个元素是1～n中出现的元素，我们可以将这个数值对应的下标里的元素改成负数，相当于每个出现过的正整数，我们把与它值相等的下标都指向一个负数，这就是类似哈希表的实现原理的操作。</li><li>step 3：最后遍历数组的时候碰到的第一个非负数，它的下标就是没有出现的第一个正整数，因为它在之前的过程中没有被修改，说明它这个下标对应的正整数没有出现过。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberDisappeared</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            <span class="comment">//负数全部记为n+1</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= <span class="number">0</span>) </span><br><span class="line">                nums[i] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="comment">//对于1-n中的数字</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[i]) &lt;= n) </span><br><span class="line">                <span class="comment">//这个数字的下标标记为负数</span></span><br><span class="line">                nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>] = <span class="number">-1</span> * <span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>]); </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="comment">//找到第一个元素不为负数的下标</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;num) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ans;</span><br><span class="line">        <span class="keyword">if</span>(num.<span class="built_in">size</span>()&lt;<span class="number">3</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>() - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] == num[i<span class="number">-1</span>] &amp;&amp; i)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> l = i + <span class="number">1</span>,r = num.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[l] + num[r] == -num[i])&#123;</span><br><span class="line">                    <span class="comment">//若指针i 加指针j 等于当前数x 则答案为x 和指针i 与j 的三元组</span></span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;num[i],num[l],num[r]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(num[l]==num[l+<span class="number">1</span>] &amp;&amp; l + <span class="number">1</span>&lt;r)l++;</span><br><span class="line">                    <span class="keyword">while</span>(num[r]==num[r<span class="number">-1</span>] &amp;&amp; r<span class="number">-1</span> &gt; l)r--;</span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(num[l]+num[r]&gt;-num[i])&#123;</span><br><span class="line">                    r--;<span class="comment">//若指针l 加指针r 大于当前数-num[i]则指针r--</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> l++;<span class="comment">//若指针l 加指针r 小于当前数-num[i]则指针l++，</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209270849014.gif" alt="alt"></p><hr><h2 id="递归x2f回溯"><a href="#递归-x2F-回溯" class="headerlink" title="递归&#x2F;回溯"></a>递归&#x2F;回溯</h2><h3 id="bm55-没有重复项数字的全排列"><a href="#BM55-没有重复项数字的全排列" class="headerlink" title="BM55 没有重复项数字的全排列"></a>BM55 没有重复项数字的全排列</h3><p>给出一组数字，返回该组数字的所有排列：</p><p>例如：</p><p>[1,2,3]的所有排列如下<br>[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2], [3,2,1].<br>（以数字在数组中的位置靠前为优先级，按字典序排列输出。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;res, vector&lt;<span class="type">int</span>&gt; &amp;num, <span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//分枝进入结尾，找到一种排列</span></span><br><span class="line">        <span class="keyword">if</span>(index == num.<span class="built_in">size</span>() - <span class="number">1</span>) </span><br><span class="line">            res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//遍历后续的元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; num.<span class="built_in">size</span>(); i++)&#123; </span><br><span class="line">                <span class="comment">//交换二者</span></span><br><span class="line">                <span class="built_in">swap</span>(num[i], num[index]); </span><br><span class="line">                <span class="comment">//继续往后找</span></span><br><span class="line">                <span class="built_in">recursion</span>(res, num, index + <span class="number">1</span>); </span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                <span class="built_in">swap</span>(num[i], num[index]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt; &amp;num) &#123;</span><br><span class="line">        <span class="comment">//先按字典序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>()); </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="comment">//递归获取</span></span><br><span class="line">        <span class="built_in">recursion</span>(res, num, <span class="number">0</span>); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209271648264.gif" alt="alt"></p><hr><h3 id="bm56-有重复项数字的全排列"><a href="#BM56-有重复项数字的全排列" class="headerlink" title="BM56 有重复项数字的全排列"></a>BM56 有重复项数字的全排列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;res, vector&lt;<span class="type">int</span>&gt; &amp;num, vector&lt;<span class="type">int</span>&gt; &amp;temp, vector&lt;<span class="type">int</span>&gt; &amp;vis)</span></span>&#123;</span><br><span class="line">        <span class="comment">//临时数组满了加入输出</span></span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>() == num.<span class="built_in">size</span>())&#123; </span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历所有元素选取一个加入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i++)&#123; </span><br><span class="line">            <span class="comment">//如果该元素已经被加入了则不需要再加入了</span></span><br><span class="line">            <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; num[i - <span class="number">1</span>] == num[i] &amp;&amp; !vis[i - <span class="number">1</span>]) </span><br><span class="line">                <span class="comment">//当前的元素num[i]与同一层的前一个元素num[i-1]相同且num[i-1]已经用过了</span></span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            <span class="comment">//标记为使用过</span></span><br><span class="line">            vis[i] = <span class="number">1</span>;  </span><br><span class="line">            <span class="comment">//加入数组</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(num[i]); </span><br><span class="line">            <span class="built_in">recursion</span>(res, num, temp, vis);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            vis[i] = <span class="number">0</span>; </span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt; &amp;num) &#123;</span><br><span class="line">        <span class="comment">//先按字典序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>()); </span><br><span class="line">        <span class="comment">//标记每个位置的元素是否被使用过</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(num.size(), <span class="number">0</span>)</span></span>; </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp; </span><br><span class="line">        <span class="comment">//递归获取</span></span><br><span class="line">        <span class="built_in">recursion</span>(res, num, temp, vis); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209271654636.gif" alt="alt"></p><hr><h3 id="bm57-岛屿数量"><a href="#BM57-岛屿数量" class="headerlink" title="BM57 岛屿数量"></a>BM57 岛屿数量</h3><p>给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。</p><p>例如：输入(注：存储的01数据其实是字符’0’,’1’)</p><p>[[1,1,0,0,0],</p><p>[0,1,0,1,1],</p><p>[0,0,0,1,1],</p><p>[0,0,0,0,0],</p><p>[0,0,1,1,1]]</p><p>对应的输出为3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//深度优先遍历与i，j相邻的所有1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; </span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();<span class="comment">//行</span></span><br><span class="line">        <span class="type">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//列</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;  <span class="comment">//置为0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//后续四个方向遍历</span></span><br><span class="line">        <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">            <span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">            <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>,j);</span><br><span class="line">        <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">            <span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; m &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">            <span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//空矩阵的情况</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//记录岛屿数</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line">        <span class="comment">//遍历矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                <span class="comment">//遍历到1的情况</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123; </span><br><span class="line">                    <span class="comment">//计数</span></span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j); <span class="comment">//将与这个1相邻的所有1置为0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209291530913.gif" alt="alt"></p><hr><h3 id="bm58-字符串的排列"><a href="#BM58-字符串的排列" class="headerlink" title="BM58 字符串的排列"></a>BM58 字符串的排列</h3><p>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。</p><p>例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。</p><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209291541100.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(vector&lt;string&gt; &amp;res, string &amp;str, string &amp;temp, vector&lt;<span class="type">int</span>&gt; &amp;vis)</span></span>&#123;</span><br><span class="line">        <span class="comment">//临时字符串满了加入输出</span></span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">length</span>() == str.<span class="built_in">length</span>())&#123; </span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历所有元素选取一个加入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)&#123; </span><br><span class="line">            <span class="comment">//如果该元素已经被加入了则不需要再加入了</span></span><br><span class="line">            <span class="keyword">if</span>(vis[i]) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; str[i - <span class="number">1</span>] == str[i] &amp;&amp; !vis[i - <span class="number">1</span>])</span><br><span class="line">                <span class="comment">//当前的元素str[i]与同一层的前一个元素str[i-1]相同且str[i-1]已经用过了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//标记为使用过  </span></span><br><span class="line">            vis[i] = <span class="number">1</span>;  </span><br><span class="line">            <span class="comment">//加入临时字符串</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(str[i]); </span><br><span class="line">            <span class="built_in">recursion</span>(res, str, temp, vis);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            vis[i] = <span class="number">0</span>; </span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先按字典序排序，使重复字符串相邻</span></span><br><span class="line">        <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>()); </span><br><span class="line">        <span class="comment">//标记每个位置的字符是否被使用过s</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(str.size(), <span class="number">0</span>)</span></span>; </span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="comment">//递归获取</span></span><br><span class="line">        <span class="built_in">recursion</span>(res, str, temp, vis); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm59-n皇后问题"><a href="#BM59-N皇后问题" class="headerlink" title="BM59 N皇后问题"></a>BM59 N皇后问题</h3><p>N皇后问题是指在 n * n 的棋盘上要摆 n 个皇后，要求：任何两个皇后不同行，不同列也不在同一条斜线上，求给一个整数 n ，返回 n 皇后的摆法数。</p><p><em>常规代码</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//判断皇后是否符合条件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;pos, <span class="type">int</span> row, <span class="type">int</span> col)</span></span>&#123; </span><br><span class="line">        <span class="comment">//遍历所有已经记录的行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123; </span><br><span class="line">            <span class="comment">//不能同行同列同一斜线</span></span><br><span class="line">            <span class="keyword">if</span>(row == i || col == pos[i] || <span class="built_in">abs</span>(row - i) == <span class="built_in">abs</span>(col - pos[i])) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归查找皇后种类</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, vector&lt;<span class="type">int</span>&gt; &amp; pos, <span class="type">int</span> &amp;res)</span></span>&#123; </span><br><span class="line">        <span class="comment">//完成全部行都选择了位置</span></span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123; </span><br><span class="line">            res++; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历所有列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; </span><br><span class="line">            <span class="comment">//检查该位置是否符合条件</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(pos, row, i))&#123; </span><br><span class="line">                <span class="comment">//加入位置</span></span><br><span class="line">                pos[row] = i; </span><br><span class="line">                <span class="comment">//递归继续查找</span></span><br><span class="line">                <span class="built_in">recursion</span>(n, row + <span class="number">1</span>, pos, res); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Nqueen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">//下标为行号，元素为列号，记录皇后位置 </span></span><br><span class="line">        <span class="built_in">recursion</span>(n, <span class="number">0</span>, pos, res);  <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><em>位运算</em></p><ol><li>如对 col &#x3D; 0100 对应第二列已有皇后，那么下一行的第一列和第三列都不能选<br>对应 pos &#x3D; 0010，也就是col右移一位；对应neg &#x3D; 1000，也就是col左移一位<br>pre &#x3D; ~ (col | pos | neg) &amp; ((1 &lt;&lt; n) - 1) 代表可以放皇后的位置<br>~ (col | pos | neg)：col、pos、neg取或运算后0表示可以放皇后的位置，取反后1表示可以放皇后的位置((1 &lt;&lt; n) - 1) ：是为了保证pre不大于n位</li><li>然后对pre中所有的1进行遍历，从最后一个1开始往前遍历，在当前行放置了一个皇后之后进入下一行，对col、pos、neg做出相应的处理，其余操作与上一个方法相同</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Nqueen</span> <span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        limit = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, limit);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> col, <span class="type">int</span> pos, <span class="type">int</span> neg, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//标记放皇后的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> ~(col | pos | neg) &amp; (limit);</span><br><span class="line">        <span class="comment">//遍历pre</span></span><br><span class="line">        <span class="keyword">while</span>(pre &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> pre &amp; (-pre);</span><br><span class="line">            <span class="comment">//当前行放置了一个皇后之后进入下一行</span></span><br><span class="line">            backtrack(i + <span class="number">1</span>, col | cur, (pos | cur) &gt;&gt; <span class="number">1</span>, (neg | cur) &lt;&lt; <span class="number">1</span>, limit);</span><br><span class="line">            pre &amp;= pre - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209291548386.gif" alt="alt"></p><hr><h3 id="bm60-括号生成"><a href="#BM60-括号生成" class="headerlink" title="BM60 括号生成"></a>BM60 括号生成</h3><p>给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。</p><p>例如，给出n&#x3D;3，解集为：”((()))”, “(()())”, “(())()”, “()()()”, “()(())”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, string temp, vector&lt;string&gt; &amp;res, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//左右括号都用完了，就加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(left == n &amp;&amp; right == n)&#123; </span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用一次左括号</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; n) </span><br><span class="line">            <span class="built_in">recursion</span>(left + <span class="number">1</span>, right, temp + <span class="string">&quot;(&quot;</span>, res, n);</span><br><span class="line">        <span class="comment">//使用右括号个数必须少于左括号</span></span><br><span class="line">        <span class="keyword">if</span>(right &lt; n &amp;&amp; left &gt; right) </span><br><span class="line">            <span class="built_in">recursion</span>(left, right + <span class="number">1</span>, temp + <span class="string">&quot;)&quot;</span>, res, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录结果</span></span><br><span class="line">        vector&lt;string&gt; res; </span><br><span class="line">        <span class="comment">//记录每次组装的字符串</span></span><br><span class="line">        string temp; </span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="built_in">recursion</span>(<span class="number">0</span>, <span class="number">0</span>, temp, res, n); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209291555095.gif" alt="alt"></p><hr><h3 id="bm61-矩阵最长递增路径"><a href="#BM61-矩阵最长递增路径" class="headerlink" title="BM61 矩阵最长递增路径"></a>BM61 矩阵最长递增路径</h3><p>给定一个 n 行 m 列矩阵 matrix ，矩阵内所有数均为非负整数。 你需要在矩阵中找到一条最长路径，使这条路径上的元素是递增的。并输出这条最长路径的长度。</p><p>这个路径必须满足以下条件：</p><p>1.每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。</p><p>2.你不能走重复的单元格。即每个格子最多只能走一次。</p><p><em><strong>思路</strong></em>既然是查找最长的递增路径长度，那我们首先要找到这个路径的起点，起点不好直接找到，就从上到下从左到右遍历矩阵的每个元素。然后以每个元素都可以作为起点查找它能到达的最长递增路径。</p><p>如何查找以某个点为起点的最长递增路径呢？我们可以考虑深度优先搜索，因为我们查找递增路径的时候，每次选中路径一个点，然后找到与该点相邻的递增位置，相当于进入这个相邻的点，继续查找递增路径，这就是递归的子问题。因此递归过程如下：</p><ul><li><em>终止条件</em> 进入路径最后一个点后，四个方向要么是矩阵边界，要么没有递增的位置，路径不能再增长，返回上一级。</li><li><em>返回值</em> 每次返回的就是本级之后的子问题中查找到的路径长度加上本级的长度。</li><li><em>本级任务</em> 每次进入一级子问题，先初始化后续路径长度为0，然后遍历四个方向（可以用数组表示，下标对数组元素的加减表示去往四个方向），进入符合不是边界且在递增的邻近位置作为子问题，查找子问题中的递增路径长度。因为有四个方向，所以最多有四种递增路径情况，因此要维护当级子问题的最大值。</li></ul><p><em><strong>具体做法</strong></em></p><ol><li>使用一个dp数组记录i，j处的单元格拥有的最长递增路径，这样在递归过程中如果访问到就不需要重复访问。</li><li>遍历矩阵每个位置，都可以作为起点，并维护一个最大的路径长度的值。</li><li>对于每个起点，使用dfs查找最长的递增路径：只要下一个位置比当前的位置数字大，就可以深入，同时累加路径长度。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;<span class="comment">//记录四个方向</span></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="comment">//深度优先搜索，返回最大单元格数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;matrix, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;dp, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)<span class="keyword">return</span> dp[i][j];</span><br><span class="line">        dp[i][j]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">            <span class="type">int</span> nexti = i + dirs[k][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nextj = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//判断条件</span></span><br><span class="line">            <span class="keyword">if</span> (nexti &gt;= <span class="number">0</span> &amp;&amp; nexti &lt; n &amp;&amp; nextj &gt;= <span class="number">0</span> &amp;&amp; nextj &lt; m &amp;&amp; matrix[nexti][nextj] &gt; matrix[i][j]) </span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], <span class="built_in">dfs</span>(matrix, dp, nexti, nextj) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//矩阵不为空</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//i，j处的单元格拥有的最长递增路径</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span> (n, vector &lt;<span class="type">int</span>&gt; (m));  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="comment">//更新最大值</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(matrix, dp, i, j)); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210021320667.gif" alt="alt"></p><hr><p><strong>BFS</strong> → <code>有向图的最长路径</code> → <code>拓扑排序</code></p><p><em>思路</em>将矩阵看成一个有向图，一个元素到另一个元素递增，代表有向图的箭头。这样我们可以根据有向图的出度入度找到最长的路径，且这个路径在矩阵中就是递增的。</p><p><em>具体做法</em></p><ol><li>计算每个单元格所对应的出度（符合边界条件且递增），作为边界条件的单元格的出度都为0。利用一个二维矩阵记录每个单元格的出度</li><li>利用拓扑排序的思想，从所有出度为0的单元格开始进行广度优先搜索。</li><li>用队列进行bfs，队列中每次加入出度为0的点，即路径最远点，每次从A点到B点，便将A点出度减一。</li><li>每次搜索都会遍历当前层所有单元格，更新其余单元格出度，将出度变为0的单元格加入下一层搜索。</li><li>搜索结束时，搜索的总层数即为矩阵中的最长递增路径的长度，因为bfs的层数就是路径增长的层数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//记录四个方向</span></span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;<span class="comment">//以单元格建立坐标系</span></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        n = matrix.<span class="built_in">size</span>();<span class="comment">//行</span></span><br><span class="line">        m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//列</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录每个单元的出度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">outdegrees</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (m)); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> nexti = i + dirs[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> nextj = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (nexti &gt;= <span class="number">0</span> &amp;&amp; nexti &lt; n &amp;&amp; nextj &gt;= <span class="number">0</span> &amp;&amp; nextj &lt; m &amp;&amp; matrix[nexti][nextj] &gt; matrix[i][j]) &#123;</span><br><span class="line">                        <span class="comment">//符合条件，记录出度</span></span><br><span class="line">                        outdegrees[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) </span><br><span class="line">                <span class="keyword">if</span> (outdegrees[i][j] == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//找到出度为0的入队列</span></span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; size; x++) &#123;</span><br><span class="line">                pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; temp = q.<span class="built_in">front</span>(); </span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> i = temp.first;</span><br><span class="line">                <span class="type">int</span> j = temp.second;</span><br><span class="line">                <span class="comment">//四个方向</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123; </span><br><span class="line">                    <span class="type">int</span> nexti = i + dirs[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> nextj = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">//逆向搜索，所以下一步是小于</span></span><br><span class="line">                    <span class="keyword">if</span> (nexti &gt;= <span class="number">0</span> &amp;&amp; nexti &lt; n &amp;&amp; nextj &gt;= <span class="number">0</span> &amp;&amp; nextj &lt; m &amp;&amp; matrix[nexti][nextj] &lt; matrix[i][j]) &#123;</span><br><span class="line">                        <span class="comment">//符合条件，出度递减</span></span><br><span class="line">                        outdegrees[nexti][nextj]--; </span><br><span class="line">                        <span class="keyword">if</span> (outdegrees[nexti][nextj] == <span class="number">0</span>) &#123;</span><br><span class="line">                            q.<span class="built_in">push</span>(&#123;nexti, nextj&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209291605039.gif" alt="图片说明"></p><hr><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="bm62-斐波那契数列"><a href="#BM62-斐波那契数列" class="headerlink" title="BM62 斐波那契数列"></a>BM62 斐波那契数列</h3><p><strong>描述</strong>斐波那契数列，输入一个正整数 n ，输出斐波那契数列的第 n 项。</p><p>$$fib(x)&#x3D; \begin{cases} 1&amp; \text{x&#x3D;0,2}\ fib(x-1)+fib(x-2)&amp; \text{x&gt;2} \end{cases}$$</p><p>要求：空间复杂度 O(1)，时间复杂度 O(n)，本题也有时间复杂度 O(logn)的解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记忆化搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> f[<span class="number">50</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (f[n] &gt; <span class="number">0</span>)<span class="keyword">return</span> f[n];</span><br><span class="line">        <span class="keyword">return</span> f[n] = (<span class="built_in">Fibonacci</span>(n<span class="number">-1</span>)+<span class="built_in">Fibonacci</span>(n<span class="number">-2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">50</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>, dp[<span class="number">2</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span> ; i &lt;= n ; i ++) dp[i] = dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span> , b = <span class="number">1</span> , c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span> ; i &lt;= n ; i ++) &#123;</span><br><span class="line">            c = a+b , a = b , b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm63-跳台阶"><a href="#BM63-跳台阶" class="headerlink" title="BM63 跳台阶"></a>BM63 跳台阶</h3><p><strong>描述</strong><em>同斐波那契数列</em></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p>要求：时间复杂度：O(n)，空间复杂度： O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span> , b = <span class="number">1</span> , c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> ; i &lt;= number ; i ++) &#123;</span><br><span class="line">            c = a+b , a = b , b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm64-最小花费爬楼梯"><a href="#BM64-最小花费爬楼梯" class="headerlink" title="BM64 最小花费爬楼梯"></a>BM64 最小花费爬楼梯</h3><p><strong>描述</strong>给定一个整数数组 cost，其中 cost[i]是从楼梯第i个台阶向上爬需要支付的费用，下标从0开始。</p><p>一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]表示爬到第i阶楼梯需要的最小花费</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cost.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="comment">//每次选取最小的方案</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]); </span><br><span class="line">        <span class="keyword">return</span> dp[cost.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm65-最长公共子序列"><a href="#BM65-最长公共子序列" class="headerlink" title="BM65 最长公共子序列"></a>BM65 最长公共子序列</h3><p><strong>描述</strong>给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回”-1”。目前给出的数据，仅仅会存在一个最长的公共子序列</p><p>输入：”1A2C3D4B56”,”B1D23A456A”</p><p>输出：”123456”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">LCS</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">empty</span>() || s2.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> dp[s1.<span class="built_in">size</span>()+<span class="number">1</span>][s2.<span class="built_in">size</span>()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s1.<span class="built_in">size</span>(); i++) </span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= s2.<span class="built_in">size</span>(); j++) </span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s2.<span class="built_in">size</span>(); j++) </span><br><span class="line">                dp[i][j] = (s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) ? dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>: <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s1.<span class="built_in">size</span>(), j = s2.<span class="built_in">size</span>(); dp[i][j] &gt;= <span class="number">1</span>;) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                res += s1[i<span class="number">-1</span>];</span><br><span class="line">                i--;j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j] &gt;= dp[i][j<span class="number">-1</span>]) i--;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">empty</span>() ? <span class="string">&quot;-1&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm66-最长公共子串"><a href="#BM66-最长公共子串" class="headerlink" title="BM66 最长公共子串"></a>BM66 最长公共子串</h3><p>给定两个字符串str1和str2,输出两个字符串的最长公共子串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">LCS</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示到str1第i个个到str2第j个为止的公共子串长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(str1.<span class="built_in">length</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(str2.<span class="built_in">length</span>() + <span class="number">1</span>, <span class="number">0</span>)); </span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= str1.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= str2.<span class="built_in">length</span>(); j++)&#123;</span><br><span class="line">                <span class="comment">//如果该两位相同</span></span><br><span class="line">                <span class="keyword">if</span>(str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>])&#123; </span><br><span class="line">                    <span class="comment">//则增加长度</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; </span><br><span class="line">                    <span class="comment">//该位置为0</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新最大长度</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt; max)&#123; </span><br><span class="line">                    max = dp[i][j];</span><br><span class="line">                    pos = i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.<span class="built_in">substr</span>(pos - max + <span class="number">1</span>, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bm67-不同路径的数目一"><a href="#BM67-不同路径的数目-一" class="headerlink" title="BM67 不同路径的数目(一)"></a>BM67 不同路径的数目(一)</h3><p>一个机器人在m×n大小的地图的左上角（起点）。</p><p>机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。</p><p>可以有多少种不同的路径从起点走到终点？</p><table><thead><tr><th align="center">起点</th><th></th><th></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"></td><td></td><td></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td></td><td></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td></td><td></td><td align="center"></td><td align="center">终点</td></tr></tbody></table><p>要求：空间复杂度 O(nm)，时间复杂度 O(nm)</p><p>进阶：空间复杂度 O(1)，时间复杂度 O(min(n,m))</p><hr><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209080806006.gif" alt="34"></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">       vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">       <span class="comment">//第一行初始化，只有一条路径</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//第一列初始化，只有一条路径</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">               <span class="comment">//转移方程</span></span><br><span class="line">               dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//数学求解</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = n, y = <span class="number">1</span>; y &lt; m; ++x, ++y) &#123;</span><br><span class="line">        <span class="comment">//组合公式的循环求解</span></span><br><span class="line">        ret = ret * x / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bm68-矩阵的最小路径和"><a href="#BM68-矩阵的最小路径和" class="headerlink" title="BM68 矩阵的最小路径和"></a>BM68 矩阵的最小路径和</h3><p><strong>描述</strong>给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。</p><p>要求：时间复杂度 O(nm)</p><p>例如：当输入[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]时，对应的返回值为12，</p><p>所选择的最小累加和路径如下图所示：</p><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209080819199.png" alt="img" style="zoom:50%;"><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202209080824148.gif" alt="alt" style="zoom: 20%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();  </span><br><span class="line">        <span class="comment">//dp[i][j]表示以当前i，j位置为终点的最短路径长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//处理第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//处理第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j] + dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//其他按照公式来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123; </span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++)&#123;</span><br><span class="line">              dp[i][j] = matrix[i][j] + (dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>] ? dp[i][j - <span class="number">1</span>] : dp[i - <span class="number">1</span>][j]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;洛谷&quot;&gt;&lt;a href=&quot;#洛谷&quot; class=&quot;headerlink&quot; title=&quot;洛谷&quot;&gt;&lt;/a&gt;洛谷&lt;/h1&gt;&lt;h2 id=&quot;p1059-noip2006-普及组-明明的随机数&quot;&gt;&lt;a href=&quot;#P1059-NOIP2006-普及组-明明的随机数&quot; c</summary>
      
    
    
    
    <category term="算法" scheme="http://dezeem.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>局域网</title>
    <link href="http://dezeem.github.io/2022/07/30/2022-07-29-%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
    <id>http://dezeem.github.io/2022/07/30/2022-07-29-%E5%B1%80%E5%9F%9F%E7%BD%91/</id>
    <published>2022-07-29T16:10:00.000Z</published>
    <updated>2022-10-18T01:24:11.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="arp协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><h2 id="mac地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>MAC（或称LAN地址，物理地址，以太网地址）</p><ul><li>作用：用于局域网内标识一个帧从哪个接口出发，到达哪个物理相连的其他接口</li><li>48为MAC地址（用于大部分LANs）,固化在网卡的ROM中，有时也可以软件设置</li><li>例子：1A-2F-BB-76-09-AD（16进制）</li></ul><h2 id="arp协议"><a href="#ARP协议-1" class="headerlink" title="ARP协议"></a>ARP协议</h2><p><strong>地址解析协议</strong></p><p><strong>ARP表</strong>：LAN中的每个IP结点（主机&#x2F;路由器）维护一个表</p><ul><li>存储某些LAN结点的IP&#x2F;MAC地址映射关系 &lt;IP地址；MAC地址；TTL&gt;</li><li>TTL（Time To Live）经过这个时间以后该映射关系会被遗弃</li></ul><p><strong>ARP是“即插即用”协议：结点自主创建ARP表，无需干预</strong></p><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><p>“统治地位”的有线LAN技术：</p><ul><li>造价低廉</li><li>应用最广泛的LAN技术</li><li>比令牌局域网和ATM等简单</li><li>满足网络速率需求：10 Mbps~10 Gbps</li></ul><p>……</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>网络设备对比</p><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202207291729233.png" alt="image-20220729172900992"></p><p>……</p><h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>……</p><h1 id="ppp协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h1><h1 id="80211无线局域网"><a href="#802-11无线局域网" class="headerlink" title="802.11无线局域网"></a>802.11无线局域网</h1><p>802.11b</p><ul><li>2.4-2.5GHz频段</li><li>最高速率：11 Mbps</li><li>物理层采用直接序列扩频技术（DSSS）技术</li></ul><p>802.11a</p><ul><li>5-6GHz频段</li><li>最高速率：54 Mbps</li></ul><p>802.11g</p><ul><li>2.4-2.5GHz频段</li><li>最高速率：54 Mbps</li></ul><p>802.11n：多天线（MIMO）</p><ul><li>2.4-2.5GHz频段</li><li>最高速率：600 Mbps</li></ul><blockquote><p>均使用CSMA&#x2F;CA多路访问控制协议</p><p>均有基础设施（基站）网络模式和特定网（自组网）网络模式</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;arp协议&quot;&gt;&lt;a href=&quot;#ARP协议&quot; class=&quot;headerlink&quot; title=&quot;ARP协议&quot;&gt;&lt;/a&gt;ARP协议&lt;/h1&gt;&lt;h2 id=&quot;mac地址&quot;&gt;&lt;a href=&quot;#MAC地址&quot; class=&quot;headerlink&quot; title=&quot;MAC</summary>
      
    
    
    
    <category term="计网" scheme="http://dezeem.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="http://dezeem.github.io/2022/07/29/2022-07-29-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://dezeem.github.io/2022/07/29/2022-07-29-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2022-07-29T10:25:00.000Z</published>
    <updated>2022-10-18T01:24:15.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>相关术语：</strong></p><ul><li>主机和路由器：结点（nodes）</li><li>连接相邻结点的通信信道：链路（links）<ul><li>有线链路（wired links）</li><li>无线链路（wireless links）</li><li>局域网（LANs）</li></ul></li><li>链路层（第二层）数据分组：帧（frame），封装网络层数据报</li></ul><p><strong>数据链路层</strong>负责通过一条链路从一个节点向另一个物理链路直接相连的相邻结点传送数据报</p><hr><h2 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h2><ul><li><p>组帧（framing）</p><ul><li>封装数据报构成数据帧，加首部和尾部</li><li>帧同步</li></ul></li><li><p>链路接入（link access）</p><ul><li>如果是共享介质们需要解决信道接入（channel access）</li><li>帧首部中的“MAC”地址，用于表示帧的源和目的<ul><li><em>不同于IP地址</em></li></ul></li></ul></li><li><p>相邻结点间的可靠交付</p><ul><li>在低误码率的有线链路上很少采用（如：光纤）</li><li>无线链路，需要可靠交付</li></ul></li><li><p>流量控制</p><ul><li>协调（pacing）相邻的发送结点和接收</li></ul></li><li><p>差错检测</p><ul><li>信号衰减和噪声会引起差错</li><li>接收端检测到差错：<ul><li>通知发送端重传或者直接丢弃帧</li></ul></li></ul></li><li><p>差错纠正</p><ul><li>接收端直接纠正比特差错</li></ul></li><li><p>全双工和半双工通信控制</p><ul><li>全双工：链路两端结点<em>同时</em>双向传输</li><li>半双工：链路两端结点<em>交替</em>双向传输</li></ul></li></ul><h1 id="差错编码"><a href="#差错编码" class="headerlink" title="差错编码"></a>差错编码</h1><h1 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h1><h2 id="mac"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p><strong>两个或以上结点同时传输时→冲突：结点同时接收两个或多个信号（接受失败）</strong></p><p><strong>MAC（mulitple access control protocol）多路访问控制协议</strong></p><ul><li><p>点对点链路</p><ul><li>拨号接入PPP</li><li>以太网交换机与主机间的点对点链路</li></ul></li><li><p>广播链路（共享介质）</p><ul><li>早期的总线以太网</li><li>HFC的上行链路</li><li>802.11无线局域网</li></ul></li><li><p><strong>MAC分类</strong></p><ul><li><p>信道划分（channel partitioning）MAC协议</p><ul><li>多路复用技术</li><li>TDMA、FDMA、CDMA、WDMA等</li></ul></li><li><p>随机访问（random access）MAC协议</p></li><li><p>信道不划分，允许冲突</p><ul><li>采用冲突“恢复”机制</li></ul></li><li><p>轮转MAC协议</p></li><li><p>结点轮流使用信道</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;相关术语：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机和路由器：结点（nodes）&lt;/li&gt;
&lt;li&gt;连接相邻结点的通</summary>
      
    
    
    
    <category term="计网" scheme="http://dezeem.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="http://dezeem.github.io/2022/07/19/2022-07-18-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://dezeem.github.io/2022/07/19/2022-07-18-%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2022-07-18T20:30:00.000Z</published>
    <updated>2022-10-18T01:24:06.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1><p><strong>主要任务：</strong>实现网络互联，进而实现数据包在各个网络之间的传输</p><p>主要问题：</p><ul><li>网络层向传输层提供怎样的服务（可靠or不可靠）</li><li>网络层寻址问题</li></ul><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ul><li>转发（forwarding）：将分组从路由器的输出端口转移到合适的输出端口<ul><li>路由器转发表（确定在本路由器如何转发分组）</li></ul></li><li>路由（routing）：确定分组从源到目的经过的路径<ul><li>路由算法（协议）（routing algorithms）：确定通过网络的端到端路径</li></ul></li><li>连接建立（ATM、帧中继、X.25）<ul><li>数据分组传输之前两端主机需要首先建立虚拟&#x2F;逻辑连接<ul><li>网络设备（如路由器）参与连接的建立</li></ul></li></ul></li></ul><h2 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h2><ul><li>无连接服务（connecting-less service）<ul><li>不事先为系列分组的传输确定传输路径</li><li>每个分组独立确定传输路径</li><li>不同分组可能传输路径不同</li><li><strong>数据报网络（datagram network）</strong></li></ul></li><li>连接服务<ul><li>首先为系列分组的传输确定从源到目的经过的路径</li><li>然后沿该路径（连接）传输系列分组</li><li>系列分组传输路径相同</li><li>传输结束后拆除连接</li><li><strong>虚电路网络（virtual-circuit network）</strong></li></ul></li></ul><h2 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h2><h3 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h3><p>虚电路：一条从源主机到目的主机。类似于电路的路径（逻辑连接）</p><ul><li>分组交换</li><li>每个分组的传输利用链路的全部带宽</li><li>源到目的路径经过的网络层设备共同完成虚电路功能</li></ul><h2 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h2><ul><li>网络层无连接</li><li>每个分组携带目的地址</li><li>路由器根据分组的目的地址转发分组<ul><li>基于路由协议&#x2F;算法构建转发表</li><li>检索转发表</li><li>每个分组独立选路</li></ul></li></ul><h3 id="转发表"><a href="#转发表" class="headerlink" title="转发表"></a>转发表</h3><blockquote><p>最长前缀匹配优先</p></blockquote><h1 id="ipv4协议"><a href="#IPv4协议" class="headerlink" title="IPv4协议"></a>IPv4协议</h1><h2 id="internet网络层"><a href="#Internet网络层" class="headerlink" title="Internet网络层"></a>Internet网络层</h2><p><img src="https://s2.loli.net/2022/07/19/otKin2WuyeY91RL.png" alt="image.png"></p><h2 id="ip数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h2><p><img src="https://s2.loli.net/2022/07/19/rSGZUFIX4s6mj5x.png" alt="image.png"></p><ul><li><strong>版本号</strong>：IP协议的版本号</li><li><strong>首部长度</strong>：IP分组首部长度</li><li><strong>服务类型（TOS）</strong>：指示期望获得哪种类型的服务<ul><li>1998年改名为<strong>区分服务</strong></li><li>只有网络提供区分服务（DiffServ）时使用</li><li>一般情况下不使用，通常IP分组的该字段的值为00H</li></ul></li><li><strong>总长度</strong>：IP分组的总字节数（首部+数据）<ul><li>最大IP分组的总长度：65535B</li><li>最小的IP分组首部：20B</li><li>IP分组可以封装的最大数据：65535 - 20 &#x3D; 65515B</li></ul></li><li></li><li><strong>生存时间（TTL）</strong>：IP分组在网络中可以通过的路由器数（或跳步数）<ul><li>路由器转发一次分组，TTL减一</li><li>如果TTL &#x3D; 0，路由器则丢弃该IP分组</li></ul></li><li>协议：指示IP分组封装的是哪个协议的数据包<ul><li>实现复用&#x2F;分解</li><li>6——TCP</li><li>17——UDP</li></ul></li><li><strong>首部校验和</strong>：实现对IP分组首部的差错检验<ul><li>计算校验和时，该字段置全0</li><li>采用反码算数运算求和，和的反码作为首部校验和字段</li></ul></li><li><strong>源IP地址、目的IP地址</strong>：分别标识发送分组的源主机&#x2F;路由器（网络接口）和接收分组的目的主机&#x2F;路由器（网络接口）的IP地址</li><li><strong>选项字段</strong>：携带安全、源选路径、时间戳和路有记录等内容（很少使用）</li><li><strong>填充</strong>：补齐首部（32位）</li></ul><hr><h2 id="ip数据分片"><a href="#IP数据分片" class="headerlink" title="IP数据分片"></a>IP数据分片</h2><p><strong>最大传输单元（MTU）</strong>：网络链路层存在MTU——链路层数据帧可封装数据的上限</p><h3 id="ip分片与重组"><a href="#IP分片与重组" class="headerlink" title="IP分片与重组"></a>IP分片与重组</h3><blockquote><p>大IP分组向较小MTU链路转发时，可以被“分片”</p><ul><li>一个IP分组分为多片IP分组</li><li>IP分片到达目的主机后进行“重组”</li></ul><p>IP首部的相关字段用于标识分片以及确定分片的相对顺序</p><ul><li>总长度、标识、标志位和片偏移</li></ul></blockquote><ul><li><p><strong>标识</strong>：标识一个IP分组</p><ul><li>IP协议利用一个计数器，每产生IP分组计数器加1，作为该IP分组的标识</li></ul></li><li><p><strong>标志位</strong>：</p><table><thead><tr><th align="center">保留</th><th align="left">DF（Don’t Fragment）</th><th>MF（More Fragment）</th></tr></thead><tbody><tr><td align="center"></td><td align="left">DF &#x3D; 1：禁止分片；<br>DF &#x3D; 0：允许分片</td><td>MF &#x3D; 1：非最后一片；<br>MF &#x3D; 0：最后一片（或未分片）</td></tr></tbody></table></li><li><p>片偏移：一个IP分组分片封装原IP分组数据的相对偏移量</p><ul><li>片偏移字段以8字节为单位</li></ul></li></ul><h2 id="ip编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>interface：主机&#x2F;路由器与物理链路的连接</p><ul><li>实现网络层功能</li><li>路由器通常有多个接口</li><li>主机通常只有一个或两个接口（如：有线的以太网接口，无线的802.11接口）</li></ul><h3 id="ip地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><blockquote><p>32比特（IPv4）：编号标识主机、路由器的接口</p></blockquote><ul><li>IP地址与每个接口关联<ul><li><strong>网络号（NetID）</strong>——高位比特</li><li><strong>主机号（HostID）</strong>——低位比特</li></ul></li></ul><h2 id="有类ip地址"><a href="#有类IP地址" class="headerlink" title="有类IP地址"></a>有类IP地址</h2><p><img src="https://s2.loli.net/2022/07/20/UNwb9s26IQxuaD5.png" alt="image.png"></p><h2 id="ip子网"><a href="#IP子网" class="headerlink" title="IP子网"></a>IP子网</h2><ul><li>IP地址具有相同网络号的设备接口</li><li>不跨越路由器（第三及以上层网络设备）可以彼此物理联通的接口</li></ul><h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><ul><li><strong>网络号（NetID）</strong>——高位比特</li><li><strong>子网号（SubID）</strong>——原网络主机号部分比特</li><li><strong>主机号（HostID）</strong>——低位比特</li></ul><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><ul><li>形如IP地址<ul><li>32位</li><li>点分十进制形式</li></ul></li><li>取值<ul><li>NetID、SubID位全取1</li><li>HostID全取0</li></ul></li><li>例如<ul><li>A网的默认子网掩码为：255.0.0.0</li><li>B网的默认子网掩码为：255.255.0.0</li><li>C网的默认子网掩码为：255.255.255.0</li><li>借用3比特划分子网的B网的子网掩码为：255.255.224.0</li></ul></li></ul><blockquote><p><strong>子网地址+子网掩码-&gt;准确确定子网大小</strong></p></blockquote><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><strong>将IP分组的目的IP地址与子网掩码按位与运算，提取子网地址</strong></p><p><img src="https://s2.loli.net/2022/07/20/UAfoj7QGOS4CF1q.png" alt="image.png"></p><h2 id="cidr"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><p>无类域间路由（Classless InterDomain Routing）</p><ul><li>消除传统的A、B、C类地址界限<ul><li>NetID+SubID→Network Prefix <strong>可以任意长度</strong></li></ul></li><li>融合子网地址与子网掩码，方便子网划分<ul><li>无类地址格式：a.b.c.d&#x2F;x，其中x为前缀长度</li></ul></li><li>提高IPv4地址空间分配效率</li><li>提高路由效率<ul><li>将多个子网聚合为一个较大的子网</li><li>构造超网（supernetting）</li><li>路由聚合（route aggregation）</li></ul></li></ul><h2 id="dhcp协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p>获取IP地址</p><ul><li>静态配置</li><li>DHCP</li></ul><p><strong>DHCP（Dynamic Host Configuration Protocol）动态主机配置协议</strong></p><ul><li>从服务器动态获取：<ul><li>IP地址</li><li>子网掩码</li><li>默认网关地址</li><li>DNS服务器名称与IP地址</li></ul></li><li>“即插即用”</li><li>允许地址重用</li><li>支持在用地址续租</li><li>支持移动用户加入网络</li></ul><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p><img src="https://s2.loli.net/2022/07/27/fYPlZnrTkEVeNou.png" alt="image.png"></p><h2 id="nat"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p><strong>NAT（Network Address Translate）网络地址转换</strong></p><p><img src="https://s2.loli.net/2022/07/27/hTnkPWR8BMqH63z.png" alt="image.png"></p><ul><li>只需从ISP申请一个IP地址<ul><li>IPv4地址耗尽</li></ul></li><li>本地网络设备IP地址的变更，无需通告外界网络</li><li>变更ISP时，无需修改内部网络设备IP地址</li><li>内部网络设备对外界网络不可见，即不可直接寻址（安全）</li></ul><p><strong>实现：</strong></p><ul><li>替换<ul><li>利用（NAT IP地址，新端口号）替换每个外出IP数据报的（源IP地址，源端口号）</li></ul></li><li>记录<ul><li>将每对（NAT IP地址，新端口号）与（源IP地址，源端口号）的替换信息存储到NAT转换表中</li></ul></li><li>替换<ul><li>根据NAT转换表，利用（源IP地址，源端口号）替换每进入内网IP数据报的（目的IP地址，目的端口号），即（NAT IP地址，新端口号）</li></ul></li></ul><p><strong>关于NAT穿透的技术</strong></p><h2 id="icmp协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><p><strong>ICMP（Internet Control Message Protocol）互联网控制报文协议</strong></p><p><strong>支持主机或路由器：</strong></p><ul><li>差错（或异常）报告</li><li>网络探询</li></ul><p><strong>两类ICMP报文</strong></p><ul><li>差错报告报文：<ul><li>目的不可达</li><li>源抑制（Source Quench）</li><li>超时&#x2F;超期</li><li>参数问题</li><li>重定向</li></ul></li><li>网络探询报文<ul><li>回声（Echo）请求与应答报文（Reply）</li><li>时间戳请求与应答报文</li></ul></li></ul><p><em>ICMP报文：类型+编码（查表）</em></p><p><img src="https://s2.loli.net/2022/07/27/zkle8QHpV9xfdCi.png" alt="image.png"></p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p><img src="https://s2.loli.net/2022/07/27/L48zebE2NaxkOId.png" alt="image.png"></p><h3 id="差错报告报文"><a href="#差错报告报文" class="headerlink" title="差错报告报文"></a>差错报告报文</h3><p><img src="https://s2.loli.net/2022/07/27/7TUHydPWJbnOMu3.png" alt="image.png"></p><h1 id="ipv6协议"><a href="#IPv6协议" class="headerlink" title="IPv6协议"></a>IPv6协议</h1><p><strong>最初动机：IPv4地址空间已经分配殆尽</strong></p><p>其他动机：</p><ul><li>快速处理&#x2F;转发数据报</li><li>支持QoS</li></ul><p>IPv6数据报格式：</p><ul><li>固定长度的40字节基本首部</li><li>不允许分片</li></ul><p><strong>对比IPv4</strong></p><ul><li>校验和：彻底移除，以减少每跳处理时间</li><li>选项：允许，但是从基本首部移出，定义多个选项首部，通过“下一个字段首部”字段指示</li><li>ICMPv6：新版ICMP<ul><li>附加报文类型</li><li>多播组管理功能</li></ul></li></ul><p>……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络层概述&quot;&gt;&lt;a href=&quot;#网络层概述&quot; class=&quot;headerlink&quot; title=&quot;网络层概述&quot;&gt;&lt;/a&gt;网络层概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;主要任务：&lt;/strong&gt;实现网络互联，进而实现数据包在各个网络之间的传输&lt;/p&gt;
&lt;p&gt;主要问题</summary>
      
    
    
    
    <category term="计网" scheme="http://dezeem.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>云开发</title>
    <link href="http://dezeem.github.io/2022/07/15/2022-07-15-%E4%BA%91%E5%BC%80%E5%8F%91/"/>
    <id>http://dezeem.github.io/2022/07/15/2022-07-15-%E4%BA%91%E5%BC%80%E5%8F%91/</id>
    <published>2022-07-15T15:50:00.000Z</published>
    <updated>2022-10-18T01:24:00.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="云开发基础"><a href="#云开发基础" class="headerlink" title="云开发基础"></a>云开发基础</h1><blockquote><p>云开发是微信团队联合腾讯云提供的原生 Serverless 云服务，致力于帮助更多的开发者快速实现小程序业务的开发，怏速迭代。</p></blockquote><h2 id="云开发-vs-传统开发"><a href="#云开发-VS-传统开发" class="headerlink" title="云开发 VS 传统开发"></a>云开发 VS 传统开发</h2><h3 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h3><p>产品经理 → 后端开发 → 部署上线 → 前端开发 → 正式发布</p><h3 id="云开发"><a href="#云开发" class="headerlink" title="云开发"></a>云开发</h3><p>产品经理 → 前端开发 → 正式发布</p><hr><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210101103205.png" alt="image-20221010110301907"></p><hr><h2 id="云开发能力"><a href="#云开发能力" class="headerlink" title="云开发能力"></a>云开发能力</h2><ul><li><p>存储：在小程序端直接上传&#x2F;下载云端文件，可视化管理</p></li><li><p>云函数：在云端运行的代码，微信私有天然鉴权，开发者只需编写自身业务逻辑代码</p></li><li><p>云数据库：一个既可在小程序前端操作，也能在云函数中读写的JSON数据库</p></li><li><p>音视频服务：提供互通高品质实时音视频通话服务，支持互动白板，美颜滤镜，高清视频通话等，基于云开发快速接入</p></li><li><p>智能图像服务：集成智能鉴黄、人脸识别、人脸识别、人脸核身等AI视觉能力，基于云开发怏速接入。</p></li></ul><h2 id="数据存储能力"><a href="#数据存储能力" class="headerlink" title="数据存储能力"></a>数据存储能力</h2><h4 id="一行代码创建数据"><a href="#一行代码创建数据" class="headerlink" title="一行代码创建数据"></a>一行代码创建数据</h4><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210101124080.png" alt="image-20221010112430016"></p><h4 id="一行代码查询数据"><a href="#一行代码查询数据" class="headerlink" title="一行代码查询数据"></a>一行代码查询数据</h4><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210101125600.png" alt="image-20221010112511509"></p><h2 id="云开发-api"><a href="#云开发-API" class="headerlink" title="云开发 API"></a>云开发 API</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><em>小程序</em></p><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210101641909.png" alt="image-20221010164153802"></p><p><em>服务端</em></p><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210101642412.png" alt="image-20221010164238346"></p><blockquote><p>初始化选项 env 支持传入一个 Object，指定服务使用的默认环境 </p></blockquote><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>云开发 API 同时支持callback 风格和promise 风格</li><li>云开发 API 初始化时如果没有设置 ID，默认使用先创建的那个</li><li>在服务端可以借助云开发 SDK 内置的 getWXContext 来获取到用户的身份信息</li></ul><h2 id="数组查询"><a href="#数组查询" class="headerlink" title="数组查询"></a>数组查询</h2><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210101655606.png" alt="image-20221010165337966" style="zoom:80%;"><h2 id="字段查询"><a href="#字段查询" class="headerlink" title="字段查询"></a>字段查询</h2><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210101656638.png" alt="image-20221010165635563"></p><h2 id="正则查询"><a href="#正则查询" class="headerlink" title="正则查询"></a>正则查询</h2><p><img src="https://raw.githubusercontent.com/Dezeem/Note-img/main/img/202210101700858.png" alt="image-20221010170041762"></p><h2 id="地理位置索引"><a href="#地理位置索引" class="headerlink" title="地理位置索引"></a>地理位置索引</h2><p>减少开发压力，只需要一个字段。</p><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>存储于云端，可以生成临时链接。</p><h2 id="云函数定时触发器"><a href="#云函数定时触发器" class="headerlink" title="云函数定时触发器"></a>云函数定时触发器</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span><span class="string">&quot;Timer&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;TriggerName&quot;</span><span class="punctuation">:</span><span class="string">&quot;EveryDay&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;Time&quot;</span><span class="punctuation">:</span><span class="string">&quot;2019-02-21T11:49:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;Message&quot;</span><span class="punctuation">:</span><span class="string">&quot;user define msg body&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="todo项目实战"><a href="#Todo项目实战" class="headerlink" title="Todo项目实战"></a>Todo项目实战</h1><h2 id="vant-ui"><a href="#Vant-UI" class="headerlink" title="Vant UI"></a>Vant UI</h2><p><strong>导入<a href="http://vant3.uihtm.com/#/zh-CN/quickstart">Vant UI</a></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//安装</span><br><span class="line">npm i vant</span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line">//安装组件</span><br><span class="line">npm i @vant/weapp@1.3.3 -S --production</span><br></pre></td></tr></table></figure><p>​删除<code>app.json</code>中的<code>&quot;style&quot;:&quot;v2&quot;</code>。防止微信中的样式与 vant 中的样式发生冲突。</p><p>在<code>project.config.json</code>中的<code>setting</code>节点中修改以下两项：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;packNpmManually&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;packNpmRelationList&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;packageJsonPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./package.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;miniprogramNpmDistDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p><em>构建 npm</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;van-button&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@vant/weapp/button/index&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="组件引入"><a href="#组件引入" class="headerlink" title="组件引入"></a>组件引入</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;vant-button&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;@vant/weapp/button&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;van-cell&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;@vant/weapp/cell&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;van-cell-group&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;@vant/weapp/cell-group&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h2><p><code>index.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;enablePullDownRefresh&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure><p><code>index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">onPullDownRefresh</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getdata</span>();</span><br><span class="line">    wx.<span class="title function_">stopPullDownRefresh</span>()</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="选择位置"><a href="#选择位置" class="headerlink" title="选择位置"></a>选择位置</h2><p><code>app.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;requiredPrivateInfos&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;chooseLocation&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;permission&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;scope.userLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你的位置信息将用于小程序位置接口&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>addtodo.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">chooseLocation</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  wx.<span class="title function_">chooseLocation</span>(&#123;</span><br><span class="line">    <span class="attr">latitude</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">longitude</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">      <span class="keyword">let</span> <span class="title class_">LocationObj</span> = &#123;</span><br><span class="line">        <span class="attr">latitude</span>:res.<span class="property">latitude</span>,</span><br><span class="line">        <span class="attr">longitude</span>:res.<span class="property">longitude</span>,</span><br><span class="line">        <span class="attr">name</span>:res.<span class="property">name</span>,</span><br><span class="line">        <span class="attr">address</span>:res.<span class="property">address</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">pagedata</span>.<span class="property">LocationObj</span> = <span class="title class_">LocationObj</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">complete</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p><code>todoInfo.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">viewLocation</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    wx.<span class="title function_">openLocation</span>(&#123;</span><br><span class="line">      <span class="attr">latitude</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">task</span>.<span class="property">location</span>.<span class="property">latitude</span>,</span><br><span class="line">      <span class="attr">longitude</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">task</span>.<span class="property">location</span>.<span class="property">longitude</span>,</span><br><span class="line">      <span class="attr">address</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">task</span>.<span class="property">location</span>.<span class="property">address</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">task</span>.<span class="property">location</span>.<span class="property">name</span>,</span><br><span class="line">      <span class="attr">scale</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">      <span class="attr">fail</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">      <span class="attr">complete</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><em>注意传送LocationObj对象</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;云开发基础&quot;&gt;&lt;a href=&quot;#云开发基础&quot; class=&quot;headerlink&quot; title=&quot;云开发基础&quot;&gt;&lt;/a&gt;云开发基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;云开发是微信团队联合腾讯云提供的原生 Serverless 云服务，致力于帮助更多的开发者</summary>
      
    
    
    
    <category term="微信小程序" scheme="http://dezeem.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>传输层(下)</title>
    <link href="http://dezeem.github.io/2022/07/13/2022-07-07-%E4%BC%A0%E8%BE%93%E5%B1%82(%E4%B8%8B)/"/>
    <id>http://dezeem.github.io/2022/07/13/2022-07-07-%E4%BC%A0%E8%BE%93%E5%B1%82(%E4%B8%8B)/</id>
    <published>2022-07-12T17:10:00.000Z</published>
    <updated>2022-10-18T01:23:45.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcp概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h1><ul><li>点对点<ul><li>一个发送方，一个接收方</li></ul></li><li>可靠的、按序的字节流</li><li>流水线机制<ul><li>TCP拥塞控制和流量控制机制设置窗口尺寸</li></ul></li><li>发送方&#x2F;接收方缓存</li><li>全双工（full-duplex）<ul><li>同一连接中能够传输双向数据流</li></ul></li><li>面向连接<ul><li>通信双方在发送数据之前必须建立连接</li><li>连接状态只在连接的两端中维护，在沿途节点中并不维护状态</li><li>TCP连接包括：两台主机上的缓存、连接状态变量、socket等</li></ul></li><li>流量控制机制</li></ul><h2 id="tcp段结构"><a href="#TCP段结构" class="headerlink" title="TCP段结构"></a>TCP段结构</h2><p><img src="https://s2.loli.net/2022/07/12/ku5sBcjrzgvl1tE.png" alt="image-20220712172112715" style="zoom: 80%;"><img src="https://s2.loli.net/2022/07/12/3rJtIUoDTKQCSkY.png" alt="image-20220712172835102" style="zoom: 67%;"></p><h3 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a><strong>序列号</strong></h3><ul><li>序列号指的是segment中第一个字节的编号，而不是segment的编号</li><li>建立TCP连接时，双方随机选择序列号</li></ul><h3 id="acks"><a href="#ACKs" class="headerlink" title="ACKs"></a><strong>ACKs</strong></h3><ul><li>希望接收到的下一个字节的序列号</li><li>累计确认：该序列号之前的所有字节均已被正确接收到</li></ul><h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><ul><li>TCP在IP层提供的不可靠服务基础上实现可靠数据传输服务</li><li>流水线机制</li><li>累计确认</li><li>TCP使用单一重传定时器</li><li>触发重传的事件<ul><li>超时</li><li>收到重复ACK</li></ul></li><li>渐进式</li></ul><h3 id="rtt和超时"><a href="#RTT和超时" class="headerlink" title="RTT和超时"></a>RTT和超时</h3><h3 id="tcp发送方事件"><a href="#TCP发送方事件" class="headerlink" title="TCP发送方事件"></a>TCP发送方事件</h3><ul><li>从应用层收到数据<ul><li>创建Segment</li><li>序列号是Segment第一个字节的编号</li><li>开启计时器</li><li>设置超时时间：Timeout</li></ul></li><li>超时<ul><li>重传引起超时的Segment</li><li>重启计时器</li></ul></li><li>收到ACK<ul><li>如果确认此前未确认的Segment<ul><li>更新SendBase</li><li>如果窗口中还有未被确认的分组，重启定时器</li></ul></li></ul></li></ul><blockquote><p><strong>图例</strong></p></blockquote><h3 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h3><h2 id="tcp流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><h2 id="tcp连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><ul><li>一次握手：<code>客户端</code>发送带有 <code>SYN</code> 标志的<code>连接请求数据包</code>给服务端</li><li>二次握手：<code>服务端</code>发送带有 <code>SYN+ACK</code> 标志的<code>连接请求和应答数据包</code>给客户端</li><li>三次握手：<code>客户端</code>发送带有 <code>ACK</code> 标志的<code>应答数据包</code>给服务端(可以携带数据了)</li></ul><img src="https://s2.loli.net/2022/07/18/7anpz4PAYJT3mQs.png" style="zoom:50%;"><h1 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h1><blockquote><p><strong>拥塞（Congestion）</strong></p></blockquote><ul><li>表现<ul><li>分组丢失（路由器缓存溢出）</li><li>分组延迟过大（在路由器缓存中排队）</li></ul></li><li>拥塞控制 vs 流量控制</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>端到端拥塞控制<ul><li>网络层不需要显式的提供支持</li><li>端系统通过观察loss、delay等网络行为判断是否发生拥塞</li><li>TCP采用这种方法</li></ul></li><li>网络辅助的拥塞控制<ul><li>路由器向发送方显式地反馈网络拥塞信息</li><li>简单的拥塞指示</li><li>指示发送方应该采取何种速率</li><li><strong>案例：ATM ABR拥塞控制</strong></li></ul></li></ul><h1 id="tcp拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tcp概述&quot;&gt;&lt;a href=&quot;#TCP概述&quot; class=&quot;headerlink&quot; title=&quot;TCP概述&quot;&gt;&lt;/a&gt;TCP概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;点对点&lt;ul&gt;
&lt;li&gt;一个发送方，一个接收方&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可靠的、按序的</summary>
      
    
    
    
    <category term="计网" scheme="http://dezeem.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>小程序开发</title>
    <link href="http://dezeem.github.io/2022/02/21/2022-02-20-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <id>http://dezeem.github.io/2022/02/21/2022-02-20-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</id>
    <published>2022-02-20T16:30:00.000Z</published>
    <updated>2022-10-18T01:23:40.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​小程序是一种不需要下载的安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念。用户不用关心是否安装太多应用的问题。应用无处不在，随时可用，但又无需安装卸载。——Allenzhang</p><p><strong>特点：</strong></p><ul><li><strong>速度快</strong>：无需下载安装，加载速度快于HTML5，微信登录，随时可用</li><li><strong>无需适配</strong>：一次开发。多端兼容，免除了对各种手机型的适配</li><li><strong>社交分享</strong>：支持直接或App分享给微信好友和群聊</li><li><strong>出色体验</strong>：可以达到近乎原生App的操作体验和流畅度，在离线状态亦可使用</li><li><strong>用完即走</strong>：通过扫码、长按、微信搜索、公众号、好友推荐等方式快速获取服务，用完即走</li><li><strong>低门槛</strong>：已有公众号的组织可以快速注册、可快速生成门店小程序</li></ul><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p><strong>小程序的技术模型：</strong></p><img src="https://s2.loli.net/2022/02/20/1boPZHW9EYVScQT.png" alt="image.png" style="zoom: 50%;"><p><strong>小程序的程序语言</strong>：</p><ul><li>渲染层：WXML + WXSS（类似HTML + CSS）</li><li>逻辑层：JavaScript</li><li>配置：JSON</li></ul><h2 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h2><ul><li>友好：重点突出；流程明确</li><li>清晰：导航明确；减少等待；异常反馈</li><li>便捷：减少输入；避免误操作；操作流畅</li><li>统一：视觉统一；WeUI</li></ul><h2 id="运营规范"><a href="#运营规范" class="headerlink" title="运营规范"></a>运营规范</h2><h1 id="开发项目"><a href="#开发项目" class="headerlink" title="开发项目"></a>开发项目</h1><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html">全局配置</a></h2><p>​小程序根目录下的 <code>app.json</code> 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。</p><p>以下是一个包含了部分常用配置选项的 <code>app.json</code> ：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;pages&quot;: [</span><br><span class="line"><span class="code">    &quot;pages/index/index&quot;,</span></span><br><span class="line"><span class="code">    &quot;pages/logs/index&quot;</span></span><br><span class="line"><span class="code">  ],</span></span><br><span class="line"><span class="code">  &quot;window&quot;: &#123;</span></span><br><span class="line"><span class="code">    &quot;navigationBarTitleText&quot;: &quot;Demo&quot;</span></span><br><span class="line"><span class="code">  &#125;,</span></span><br><span class="line"><span class="code">  &quot;tabBar&quot;: &#123;</span></span><br><span class="line"><span class="code">    &quot;list&quot;: [&#123;</span></span><br><span class="line"><span class="code">      &quot;pagePath&quot;: &quot;pages/index/index&quot;,</span></span><br><span class="line"><span class="code">      &quot;text&quot;: &quot;首页&quot;</span></span><br><span class="line"><span class="code">    &#125;, &#123;</span></span><br><span class="line"><span class="code">      &quot;pagePath&quot;: &quot;pages/logs/index&quot;,</span></span><br><span class="line"><span class="code">      &quot;text&quot;: &quot;日志&quot;</span></span><br><span class="line"><span class="code">    &#125;]</span></span><br><span class="line"><span class="code">  &#125;,</span></span><br><span class="line"><span class="code">  &quot;networkTimeout&quot;: &#123;</span></span><br><span class="line"><span class="code">    &quot;request&quot;: 10000,</span></span><br><span class="line"><span class="code">    &quot;downloadFile&quot;: 10000</span></span><br><span class="line"><span class="code">  &#125;,</span></span><br><span class="line"><span class="code">  &quot;debug&quot;: true</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html">页面配置</a></h2><p>​每一个小程序页面也可以使用同名 <code>.json</code> 文件来对本页面的窗口表现进行配置，页面中配置项会覆盖 <code>app.json</code> 的 <code>window</code> 中相同的配置项。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,</span><br><span class="line">  &quot;navigationBarTextStyle&quot;: &quot;black&quot;,</span><br><span class="line">  &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,</span><br><span class="line">  &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,</span><br><span class="line">  &quot;backgroundTextStyle&quot;: &quot;light&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><image src></image>图片标记：路径可以使用http或相对路径</p><p><view></view>作为容器元素</p></blockquote><h2 id="应用弹性盒子布局"><a href="#应用弹性盒子布局" class="headerlink" title="应用弹性盒子布局"></a>应用弹性盒子布局</h2><ul><li><strong>传统方式布局</strong><ul><li><strong>目标的实现属性赋值非常分散</strong></li><li>严重依赖于<strong>页面结构与内容的实际大小</strong></li></ul></li></ul><p><strong>弹性盒子布局</strong>（统一，灵活）</p><p><strong>盒子属性</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display:flex;</span><br><span class="line">flex-direction:column;//垂直布局</span><br><span class="line">justify-content:space-around;//自上而下放置时素材均匀分布</span><br><span class="line">align-items:center;//元素在水平方向上居中显示</span><br></pre></td></tr></table></figure><h2 id="响应式长度单位rpx"><a href="#响应式长度单位rpx" class="headerlink" title="响应式长度单位rpx"></a>响应式长度单位rpx</h2><p><strong>让元素大小适配不同宽度屏幕</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.images &#123;</span><br><span class="line"><span class="code">width:375rpx;</span></span><br><span class="line"><span class="code">height:375rpx;</span></span><br><span class="line"><span class="code">border-radius:50%;//圆形图片</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="导航链接"><a href="#导航链接" class="headerlink" title="导航链接"></a>导航链接</h2><p><strong>navigator组件</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">style</span>=<span class="string">&quot;display:inline&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">open-type</span>=<span class="string">&quot;redirect&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">url</span>=<span class="string">&quot;/pages/logs/logs&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">hover-class</span>=<span class="string">&quot;nav-hover&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">class</span>=<span class="string">&quot;nav-default&quot;</span>&gt;</span></span></span><br><span class="line">启动日志</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">//style=&quot;display:inline&quot;设置为内联元素</span><br><span class="line">//open-type=&quot;redirect&quot;重定向，不可返回；默认为navigate</span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">.nav-hover &#123;</span></span><br><span class="line"><span class="code">color:red;</span></span><br><span class="line"><span class="code">&#125;//点击态</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">.nav-default &#123;</span><br><span class="line"><span class="code">color:blue;</span></span><br><span class="line"><span class="code">&#125;//显示态</span></span><br><span class="line"><span class="code">//交换两者才可实现点击态</span></span><br></pre></td></tr></table></figure><h2 id="配置tabbar底部标签栏"><a href="#配置tabBar（底部标签栏）" class="headerlink" title="配置tabBar（底部标签栏）"></a>配置tabBar（底部标签栏）</h2><p><code>app.json</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;tabBar&quot;: &#123;</span><br><span class="line">  &quot;list&quot;: [</span><br><span class="line"><span class="code">    &#123;</span></span><br><span class="line"><span class="code">      &quot;text&quot;: &quot;启动日志&quot;,</span></span><br><span class="line"><span class="code">      &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,</span></span><br><span class="line"><span class="code">      &quot;iconPath&quot;: &quot;images/icons/person.jpg&quot;,</span></span><br><span class="line"><span class="code">      &quot;selectedIconPath&quot;: &quot;images/icons/iperson.jpg&quot;</span></span><br><span class="line"><span class="code">    &#125;,</span></span><br><span class="line"><span class="code">    &#123;</span></span><br><span class="line"><span class="code">      &quot;text&quot;: &quot;主页&quot;,</span></span><br><span class="line"><span class="code">      &quot;pagePath&quot;: &quot;pages/index/index&quot;,</span></span><br><span class="line"><span class="code">      &quot;iconPath&quot;: &quot;images/icons/home.jpg&quot;,</span></span><br><span class="line"><span class="code">      &quot;selectedIconPath&quot;: &quot;images/icons/ihome.jpg&quot;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">  ],</span></span><br><span class="line"><span class="code">  &quot;color&quot;:&quot;#000&quot;,</span></span><br><span class="line"><span class="code">  &quot;selectedColor&quot;:&quot;#00f&quot;</span></span><br><span class="line"><span class="code">&#125;,</span></span><br></pre></td></tr></table></figure><p><strong>此时navigate失效，需要修改。</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">&quot;/pages/logs/logs&quot;</span> <span class="attr">open-type</span>=<span class="string">&quot;switchTab&quot;</span>&gt;</span></span>启动日志<span class="language-xml"><span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="配置全局导航栏样式"><a href="#配置全局导航栏样式" class="headerlink" title="配置全局导航栏样式"></a>配置全局导航栏样式</h2><p><code>app.json</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;window&quot;: &#123;</span><br><span class="line"><span class="code">    &quot;backgroundTextStyle&quot;: &quot;light&quot;,</span></span><br><span class="line"><span class="code">    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,</span></span><br><span class="line"><span class="code">    &quot;navigationBarTitleText&quot;: &quot;关于&quot;,   </span></span><br><span class="line"><span class="code">    &quot;navigationBarTextStyle&quot;: &quot;black&quot;,</span></span><br><span class="line"><span class="code">    &quot;enablePullDownRefresh&quot;: true</span></span><br><span class="line"><span class="code">  &#125;,</span></span><br></pre></td></tr></table></figure><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p><code>weather.js</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    todayweather:&#123;</span><br><span class="line">      city:&quot;武汉&quot;,</span><br><span class="line">      weather:&quot;晴&quot;,</span><br><span class="line">      temperature:&quot;2℃&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="小程序的运行环境与基本架构"><a href="#小程序的运行环境与基本架构" class="headerlink" title="小程序的运行环境与基本架构"></a>小程序的运行环境与基本架构</h2><p>​<strong>每个小程序都是运行在它的微信客户端上的，通过微信客户端给它提供的运行环境，小程序可以直接获取微信客户端的原生体验和原生能力。</strong></p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>在框架中，使用 <code>wx:if=&quot;&quot;</code> 来判断是否需要渲染该代码块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;condition&#125;&#125;&quot;</span>&gt;</span> True <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以用 <code>wx:elif</code> 和 <code>wx:else</code> 来添加一个 else 块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;</span>&gt;</span> 2 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span> 3 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为 <code>wx:if</code> 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 <code>&lt;block/&gt;</code> 标签将多个组件包装起来，并在上边使用 <code>wx:if</code> 控制属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;true&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span> view1 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span> view2 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;block/&gt;</code> 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。</p><p><strong>wx:if vs hidden</strong></p><p>因为 <code>wx:if</code> 之中的模板也可能包含数据绑定，所以当 <code>wx:if</code> 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。同时 <code>wx:if</code> 也是<strong>惰性的</strong>，如果在初始渲染条件为 <code>false</code>，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。</p><p>相比之下，<code>hidden</code> 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。</p><p>一般来说，<code>wx:if</code> 有更高的切换消耗而 <code>hidden</code> 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 <code>hidden</code> 更好，如果在运行时条件不大可能改变则 <code>wx:if</code> 较好。</p><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h3 id="swiper组件"><a href="#swiper组件" class="headerlink" title="swiper组件"></a>swiper组件</h3><p><strong>幻灯片轮播展示</strong></p><h2 id="页面的生命周期函数"><a href="#页面的生命周期函数" class="headerlink" title="页面的生命周期函数"></a>页面的生命周期函数</h2><p><code>&lt;swiper&gt;&lt;/swiper&gt;</code>添加属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current=&quot;&#123;&#123; array.length - 1 &#125;&#125;&quot;//切换到最后一张幻灯片(有缺陷)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>js文件</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">current=&quot;&#123;&#123; currentIndex &#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">//初始化数据</span><br><span class="line">//生命周期函数</span><br><span class="line">onload:function(options) &#123;</span><br><span class="line">this.setData(&#123;</span><br><span class="line">currentIndex:this.data.array.length - 1</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">//还包括其他的生命周期函数</span><br></pre></td></tr></table></figure><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;f0&quot;</span>&gt;</span>按钮<span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//更新数据不能直接赋值</span><br><span class="line">f0:function(event)&#123;</span><br><span class="line">console.log(this.data.count)//读取</span><br><span class="line">this.setData(&#123;</span><br><span class="line">    count:this.data.count + 1</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//this.serData可以动态设置变量</span><br></pre></td></tr></table></figure><h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button bindtap=&quot;f0&quot;&gt;按钮&lt;button&gt;//会向上冒泡传递，父元素函数会被调用</span><br><span class="line"></span><br><span class="line">&lt;button catchtap=&quot;f1&quot;&gt;按钮&lt;button&gt;//不会向上冒泡传递，父元素函数不会被调用</span><br></pre></td></tr></table></figure><h2 id="组件自定义数据属性"><a href="#组件自定义数据属性" class="headerlink" title="组件自定义数据属性"></a>组件自定义数据属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f1:function(event)&#123;</span><br><span class="line">wx.navigateTo(&#123;</span><br><span class="line">url:&#x27;/pages/index/index&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;//点击页面相同</span><br><span class="line"></span><br><span class="line">f1:function(event)&#123;</span><br><span class="line">wx.navigateTo(&#123;</span><br><span class="line">url:&#x27;/pages/index/index?id=77&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;//点击页面相同</span><br></pre></td></tr></table></figure><h2 id="动态导航栏"><a href="#动态导航栏" class="headerlink" title="动态导航栏"></a>动态导航栏</h2><p><code>index.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onShareAppMessage: function()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">title:&quot;向你推荐&quot; + this.data.movie.title</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h1><h2 id="自定义组件itemjs"><a href="#自定义组件item-js" class="headerlink" title="自定义组件item.js"></a>自定义组件item.js</h2><p><code>item.json</code>将组件属性设置true</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;component&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>item.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">    <span class="attr">options</span>: &#123; <span class="comment">// 组件配置</span></span><br><span class="line">        <span class="attr">addGlobalClass</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 指定所有 _ 开头的数据字段为纯数据字段</span></span><br><span class="line">        <span class="comment">// 纯数据字段是一些不用于界面渲染的 data 字段，可以用于提升页面更新性能</span></span><br><span class="line">        <span class="attr">pureDataPattern</span>: <span class="regexp">/^_/</span>, </span><br><span class="line">        <span class="attr">multipleSlots</span>: <span class="literal">true</span> <span class="comment">// 在组件定义时的选项中启用多slot支持</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">properties</span>: &#123;</span><br><span class="line">        <span class="attr">vtabs</span>: &#123;<span class="attr">type</span>: <span class="title class_">Array</span>, <span class="attr">value</span>: []&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">currentView</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">observers</span>: &#123; <span class="comment">// 监测</span></span><br><span class="line">        <span class="attr">activeTab</span>: <span class="keyword">function</span>(<span class="params">activeTab</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">scrollTabBar</span>(activeTab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="attr">relations</span>: &#123;  <span class="comment">// 关联的子/父组件</span></span><br><span class="line">        <span class="string">&#x27;../vtabs-content/index&#x27;</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;child&#x27;</span>, <span class="comment">// 关联的目标节点应为子节点</span></span><br><span class="line">            <span class="attr">linked</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">calcVtabsCotentHeight</span>(target);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">unlinked</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">_contentHeight</span>[target.<span class="property">data</span>.<span class="property">tabIndex</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">lifetimes</span>: &#123; <span class="comment">// 组件声明周期</span></span><br><span class="line">        <span class="attr">created</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 组件实例刚刚被创建好时</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">attached</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 在组件实例进入页面节点树时执行</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">detached</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 在组件实例被从页面节点树移除时执行</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123; <span class="comment">// 组件方法</span></span><br><span class="line">        <span class="title function_">calcVtabsCotentHeight</span>(<span class="params">target</span>) &#123;&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;​		</summary>
      
    
    
    
    <category term="微信小程序" scheme="http://dezeem.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>传输层(上)</title>
    <link href="http://dezeem.github.io/2022/02/17/2022-02-17-%E4%BC%A0%E8%BE%93%E5%B1%82(%E4%B8%8A)/"/>
    <id>http://dezeem.github.io/2022/02/17/2022-02-17-%E4%BC%A0%E8%BE%93%E5%B1%82(%E4%B8%8A)/</id>
    <published>2022-02-17T11:40:00.000Z</published>
    <updated>2022-10-18T01:23:34.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传输层服务"><a href="#传输层服务" class="headerlink" title="传输层服务"></a>传输层服务</h1><h2 id="传输层服务和协议"><a href="#传输层服务和协议" class="headerlink" title="传输层服务和协议"></a>传输层服务和协议</h2><p><img src="https://s2.loli.net/2022/02/17/QjB2W7VwPI4fJMO.png" alt="image.png"></p><h2 id="传输层-vs-网络层"><a href="#传输层-VS-网络层" class="headerlink" title="传输层 VS 网络层"></a>传输层 VS 网络层</h2><ul><li>网络层：提供主机之间的逻辑通信机制</li><li>传输层：提供应用进程之间的逻辑通信机制<ul><li>位于网络之上</li><li>依赖于网络层服务</li><li>对于网络层服务进行（可能的）增强</li></ul></li></ul><hr><p><strong>类比：12个孩子给12个孩子发信</strong></p><ul><li>应用进程 &#x3D; 孩子</li><li>应用消息 &#x3D; 信封里的信</li><li>主机 &#x3D; 房子</li><li>传输层协议 &#x3D; 李雷和韩梅梅</li><li>网络层协议 &#x3D; 邮政服务</li></ul><h2 id="internet传输层协议"><a href="#Internet传输层协议" class="headerlink" title="Internet传输层协议"></a>Internet传输层协议</h2><ul><li>可靠、按序的交付服务（TCP）<ul><li>拥塞控制</li><li>流量控制</li><li>连接建立</li></ul></li><li>不可靠的交付服务（UDP）<ul><li>基于”尽力而为（Best-effort）“的网络层，没有做（可靠性方面的）扩展</li></ul></li><li>两种服务均不保证<ul><li>延迟</li><li>带宽</li></ul></li></ul><h1 id="复用和分用"><a href="#复用和分用" class="headerlink" title="复用和分用"></a>复用和分用</h1><blockquote><blockquote><p><strong>Why</strong>？</p><p>如果某层的一个协议对应直接上层的多个协议&#x2F;实体，则需要多路复用&#x2F;分用。</p></blockquote><p><img src="https://s2.loli.net/2022/02/17/52eMXtVSoxifuj3.png" alt="image.png"></p></blockquote><h2 id="分用如何工作"><a href="#分用如何工作？" class="headerlink" title="分用如何工作？"></a>分用如何工作？</h2><ul><li>主机接收到IP数据报（datagram）<ul><li>每个数据报携带源IP地址、目的IP地址</li><li>每个数据报携带一个传输层的段（Segment）<ul><li><img src="https://s2.loli.net/2022/02/17/9xJj3d6ZuqCpome.png" alt="image.png"></li></ul></li><li>每个段携带源端口号和目的端口号</li></ul></li><li>主机收到Segment之后，传输层协议提取IP地址和端口号信息，将Segment导向相应的Socket<ul><li>TCP做更多处理</li></ul></li></ul><h3 id="无连接分用"><a href="#无连接分用" class="headerlink" title="无连接分用"></a>无连接分用</h3><p><img src="https://s2.loli.net/2022/02/17/uREOPJmTjafXdUA.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/02/17/9DgBzhtjrmG7YCv.png" alt="image.png"></p><h3 id="面向连接的分用"><a href="#面向连接的分用" class="headerlink" title="面向连接的分用"></a>面向连接的分用</h3><p><img src="https://s2.loli.net/2022/02/17/GroPs1FRWKhn6xS.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/02/17/kweS9dJpuX3bnGR.png" alt="image.png"></p><blockquote><p>多线程Web服务器</p></blockquote><p><img src="https://s2.loli.net/2022/02/17/3M9NOYEKautxSg1.png" alt="image.png"></p><h1 id="无连接传输协议udp"><a href="#无连接传输协议—UDP" class="headerlink" title="无连接传输协议—UDP"></a>无连接传输协议—UDP</h1><p><strong>UDP：User Datagram Protocol</strong></p><ul><li>基于IP协议<ul><li>复用&#x2F;分用</li><li>简单的错误校验</li></ul></li><li>”Best effort“服务，UDP段可能<ul><li>丢失</li><li>非按序到达</li></ul></li><li>无连接<ul><li>UDP发送方和接受方之间不需要握手</li><li>每个UDP的段处理独立于其他段</li></ul></li></ul><blockquote><p><strong>UDP为什么存在？</strong></p><ul><li>无需建立连接（减少延迟）</li><li>实现简单：无需维持连接状态</li><li>头部开销少</li><li>没有拥塞控制：应用可以更好地控制发送时间和速率</li></ul></blockquote><ul><li>常用于流媒体应用<ul><li>容忍丢失</li><li>速率敏感</li></ul></li><li>UDP还用于<ul><li>DNS</li><li>SNMP</li></ul></li><li>在UDP上实现可靠数据传输<ul><li>在应用层增加可靠性机制</li><li>应用特定的错误恢复机制</li></ul></li></ul><p><img src="https://s2.loli.net/2022/02/17/yRiON8ugvAYDPj4.png" alt="image.png"></p><h2 id="udp校验和checksum"><a href="#UDP校验和（checksum）" class="headerlink" title="UDP校验和（checksum）"></a>UDP校验和（checksum）</h2><p><img src="https://s2.loli.net/2022/02/17/VX7OlFHjkmLd9cS.png" alt="image.png"></p><h1 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h1><h2 id="可靠数据传输协议"><a href="#可靠数据传输协议" class="headerlink" title="可靠数据传输协议"></a>可靠数据传输协议</h2><h3 id="基本结构接口"><a href="#基本结构：接口" class="headerlink" title="基本结构：接口"></a>基本结构：接口</h3><p><img src="https://s2.loli.net/2022/07/03/OHztSiZbnojAEpY.png" alt="image.png"></p><p><strong>Rdt 2.0 -&gt; Rdt 2.1 -&gt; Rdt3.0</strong> </p><h4 id="rdt-30性能"><a href="#Rdt-3-0性能" class="headerlink" title="Rdt 3.0性能"></a>Rdt 3.0性能</h4><p><img src="https://s2.loli.net/2022/07/06/xqcj5dMOmwPCilY.png" alt="image.png"></p><h1 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h1><p><img src="https://s2.loli.net/2022/07/07/hr5v7jkQtBdbolc.png" alt="image.png"></p><h2 id="gbngo-back-n协议"><a href="#GBN（Go-Back-N协议）" class="headerlink" title="GBN（Go-Back-N协议）"></a>GBN（Go-Back-N协议）</h2><h2 id="srselective-repeat协议"><a href="#SR（Selective-Repeat协议）" class="headerlink" title="SR（Selective Repeat协议）"></a>SR（Selective Repeat协议）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传输层服务&quot;&gt;&lt;a href=&quot;#传输层服务&quot; class=&quot;headerlink&quot; title=&quot;传输层服务&quot;&gt;&lt;/a&gt;传输层服务&lt;/h1&gt;&lt;h2 id=&quot;传输层服务和协议&quot;&gt;&lt;a href=&quot;#传输层服务和协议&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="计网" scheme="http://dezeem.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>应用层(下)</title>
    <link href="http://dezeem.github.io/2022/02/17/2022-02-16-%E5%BA%94%E7%94%A8%E5%B1%82(%E4%B8%8B)/"/>
    <id>http://dezeem.github.io/2022/02/17/2022-02-16-%E5%BA%94%E7%94%A8%E5%B1%82(%E4%B8%8B)/</id>
    <published>2022-02-16T21:50:00.000Z</published>
    <updated>2022-10-18T01:23:29.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h3 id="p2p应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h3><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><img src="https://s2.loli.net/2022/01/31/XuTgCmhrvA3Ptak.png" alt="image.png"></p><h4 id="文件分发客户机x2f服务器-vs-p2p"><a href="#文件分发：客户机-x2F-服务器-vs-P2P" class="headerlink" title="文件分发：客户机&#x2F;服务器 vs P2P"></a>文件分发：客户机&#x2F;服务器 vs P2P</h4><p><img src="https://s2.loli.net/2022/01/31/WNbS5CPonFzODgL.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/01/31/k1rgw4aKE9pVjTX.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/01/31/2ErN4Wm6npdHUPG.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/01/31/9CdcwzJ8KvVGqIL.png" alt="image.png"></p><p><strong>实例：BitTorrent</strong></p><h4 id="索引技术"><a href="#索引技术" class="headerlink" title="索引技术"></a>索引技术</h4><p><strong>P2P系统的索引：信息到节点位置（IP+端口号）的映射</strong></p><p><strong>文件共享（电驴）</strong></p><ul><li>利用索引动态跟踪节点所共享的文件的位置</li><li>节点需要告诉索引它拥有哪些文件</li><li>节点搜索索引，从而获知能够得到哪些文件</li></ul><p><strong>即时消息（QQ）</strong></p><ul><li>索引负责将用户名映射到位置</li><li>当用户开启IM应用时，需要通知索引它的位置</li><li>节点检索索引，确定用户的IP地址</li></ul><h5 id="集中式索引"><a href="#集中式索引" class="headerlink" title="集中式索引"></a>集中式索引</h5><p><img src="https://s2.loli.net/2022/01/31/IsmMqCRzAgG6EBr.png" alt="image.png"></p><blockquote><p><strong>内容和文件传输是分布式的，但是内容定位是高度集中式的。</strong></p></blockquote><ul><li>单点失效问题</li><li>性能瓶颈</li><li>版权问题</li></ul><h5 id="洪泛式查询query-flooding"><a href="#洪泛式查询：Query-flooding" class="headerlink" title="洪泛式查询：Query flooding"></a>洪泛式查询：Query flooding</h5><ul><li>完全分布式架构</li><li>Gnutella采用这种架构</li><li>每个节点对它共享的文件进行索引，且只对她共享的文件进行索引</li></ul><p><strong>覆盖网络</strong></p><ul><li>节点X与Y之间如果有TCP连接，那么构成一个边</li><li>所有的活动节点和边构成覆盖网络</li><li>边：虚拟链路</li><li>节点一般邻居数少于10个</li></ul><p><img src="https://s2.loli.net/2022/01/31/ql6QWuINcPm2nYZ.png" alt="image.png"></p><h5 id="层次式覆盖网络"><a href="#层次式覆盖网络" class="headerlink" title="层次式覆盖网络"></a>层次式覆盖网络</h5><p><img src="https://s2.loli.net/2022/01/31/yg7UorWSwjcxaVG.png" alt="image.png"></p><p><strong>案例：Skype</strong></p><h3 id="scoket应用"><a href="#Scoket应用" class="headerlink" title="Scoket应用"></a>Scoket应用</h3><p><img src="https://s2.loli.net/2022/02/16/LmQ24FG3tPjgdif.png" alt="image.png"></p><h4 id="应用编程接口api"><a href="#应用编程接口API" class="headerlink" title="应用编程接口API"></a>应用编程接口API</h4><p><img src="https://s2.loli.net/2022/02/16/T14ctMDIPnJxSRX.png" alt="image.png"></p><blockquote><p><strong>就是应用进程的控制权和操作系统的控制权进行转换的一个系统调用接口</strong>。</p></blockquote><p><strong>几种典型的应用编程接口：</strong></p><ul><li>Berkeley UNIX操作系统定义了一种API，称为套接字接口（socket interface），简称套接字（socket）。</li><li>微软公司在其操作系统中采用了套接字接口API，形成了一个稍微不同的API，并称之为Windows Socket Interface，WINSOCK。</li><li>AT&amp;T为其UNIX系统V定义了一种API，简写为TLI（Transport Layer Interface）。</li></ul><h4 id="socket-api"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h4><ul><li><p>最初设计</p><ul><li>面向BSD UNIX-Berkley</li><li>面向TCP&#x2F;IP协议栈接口</li></ul></li><li><p>目前</p><ul><li>事实上的工业标准</li><li>绝大多数操作系统都支持</li></ul></li><li><p>Internet网络应用最典型的API接口</p></li><li><p>通信模型</p><ul><li>客户&#x2F;服务器（C&#x2F;S）</li></ul></li><li><p>应用进程间通信的抽象机制</p></li></ul><p><img src="https://s2.loli.net/2022/02/16/wsgXQSbBCG1UD9f.png" alt="image.png"></p><h5 id="socket抽象"><a href="#Socket抽象" class="headerlink" title="Socket抽象"></a>Socket抽象</h5><p><img src="https://s2.loli.net/2022/02/16/J8CHFkj6hYGgDWQ.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/02/16/2c9AbD65zSYdwjk.png" alt="image.png"></p><h5 id="socket-api-函数没听懂详解"><a href="#Socket-API-函数（没听懂）详解" class="headerlink" title="Socket API 函数（没听懂）详解"></a><strong>Socket API 函数</strong>（没听懂）<a href="https://blog.csdn.net/virlhs/article/details/19043333">详解</a></h5><p><strong>Socket面向TCP&#x2F;IP的服务类型</strong></p><p><img src="C:\Users\28190\AppData\Roaming\Typora\typora-user-images\image-20220216200318662.png" alt="image-20220216200318662"></p><h4 id="网络字节顺序"><a href="#网络字节顺序" class="headerlink" title="网络字节顺序"></a>网络字节顺序</h4><ul><li>TCP&#x2F;IP定义了标准的用于协议中的二进制整数表示：网络字节顺序（network byte order）</li><li>某些Socket API函数的参数需要存储为网络字节顺序（如IP地址、端口号等）</li><li>可以实现本地字节顺序与网络字节顺序间转换的函数<ul><li>htons：本地字节顺序-&gt;网络字节顺序（16bits）</li><li>ntohs：网络字节顺序-&gt;本地字节顺序（16bits）</li><li>htonl：本地字节顺序-&gt;网络字节顺序（32bits）</li><li>ntohl：网络字节顺序-&gt;本地字节顺序（32bits）</li></ul></li></ul><p><strong>网络应用的Socket API（TCP）调用的基本流程</strong></p><p><img src="https://s2.loli.net/2022/02/16/Cesgkrp5yHAKnqc.png" alt="image.png"></p><h4 id="解析服务器ip地址"><a href="#解析服务器IP地址" class="headerlink" title="解析服务器IP地址"></a>解析服务器IP地址</h4><p><img src="https://s2.loli.net/2022/02/16/JhX1WfjrmpezN5B.png" alt="image.png"></p><p><strong>解析服务器端口号</strong></p><p><img src="https://s2.loli.net/2022/02/16/psfteZQ26kWiuMN.png" alt="image.png"></p><p><strong>解析协议号</strong></p><p><img src="https://s2.loli.net/2022/02/16/sfBDhm4gtqHv5zW.png" alt="image.png"></p><h4 id="tcp客户端软件流程"><a href="#TCP客户端软件流程" class="headerlink" title="TCP客户端软件流程"></a>TCP客户端软件流程</h4><p><img src="https://s2.loli.net/2022/02/16/8XRWBe7kyziAd3r.png" alt="image.png"></p><h4 id="udp客户端软件流程"><a href="#UDP客户端软件流程" class="headerlink" title="UDP客户端软件流程"></a>UDP客户端软件流程</h4><p><img src="https://s2.loli.net/2022/02/16/q9tTDZNezPmgjw7.png" alt="image.png"></p><h4 id="4种类型的基本服务器"><a href="#4种类型的基本服务器" class="headerlink" title="4种类型的基本服务器"></a>4种类型的基本服务器</h4><ul><li>循环无连接服务器</li><li>循环面向连接服务器</li><li>并发无连接服务器</li><li>并发面向连接服务器</li></ul><p>。。。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;应用层&quot;&gt;&lt;a href=&quot;#应用层&quot; class=&quot;headerlink&quot; title=&quot;应用层&quot;&gt;&lt;/a&gt;应用层&lt;/h1&gt;&lt;h3 id=&quot;p2p应用&quot;&gt;&lt;a href=&quot;#P2P应用&quot; class=&quot;headerlink&quot; title=&quot;P2P应用&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="计网" scheme="http://dezeem.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>应用层(上)</title>
    <link href="http://dezeem.github.io/2022/01/30/2022-01-29-%E5%BA%94%E7%94%A8%E5%B1%82(%E4%B8%8A)/"/>
    <id>http://dezeem.github.io/2022/01/30/2022-01-29-%E5%BA%94%E7%94%A8%E5%B1%82(%E4%B8%8A)/</id>
    <published>2022-01-29T21:33:00.000Z</published>
    <updated>2022-10-18T01:23:24.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="1网络应用的体系结构"><a href="#1-网络应用的体系结构" class="headerlink" title="1.网络应用的体系结构"></a>1.网络应用的体系结构</h2><p>​<strong>网络应用：</strong>百度、QQ、email、迅雷、支付宝、微信、百度云、淘宝网、网易。</p><h3 id="体系结构"><a href="#体系结构：" class="headerlink" title="体系结构："></a>体系结构：</h3><h4 id="1客户机x2f服务器结构client-servercx2fs"><a href="#（1）客户机-x2F-服务器结构（Client-Server，C-x2F-S）" class="headerlink" title="（1）客户机&#x2F;服务器结构（Client-Server，C&#x2F;S）"></a>（1）客户机&#x2F;服务器结构（Client-Server，C&#x2F;S）</h4><p>​<strong>服务器：</strong></p><p>​7*24小时提供服务</p><p>​永久性访问地址&#x2F;域名</p><p>​利用大量服务器实现可扩展性</p><p>​<strong>客户机：</strong></p><p>​与服务器通信，使用服务器提供的服务</p><p>​间歇性的接入网络</p><p>​可能使用动态IP地址</p><p>​不会与其他客户机直接通信</p><p>​<strong>例子：Web</strong> </p><pre><code>    ![image.png](https://i.loli.net/2021/11/12/Wyd5468XE97D3vS.png)</code></pre><h4 id="2点对点结构peer-to-peerp2p"><a href="#（2）点对点结构（Peer-to-peer，P2P）" class="headerlink" title="（2）点对点结构（Peer-to-peer，P2P）"></a>（2）点对点结构（Peer-to-peer，P2P）</h4><p>​没有永远在线的服务器</p><p>​任意端系统&#x2F;节点之间可以直接通讯</p><p>​节点间歇性接入网络，可能改变IP地址</p><p>​<strong>优点：</strong>高度可伸缩；<strong>缺点：</strong>难于管理</p><h4 id="3混合结构hybrid"><a href="#（3）混合结构（Hybrid）" class="headerlink" title="（3）混合结构（Hybrid）"></a>（3）混合结构（Hybrid）</h4><p>​ 利用前两者的优点，规避两者的缺点。</p><p>​ <strong>Napster：</strong>文件传输使用P2P结构；文件的搜索采用C&#x2F;S结构——集中式</p><p>​<img src="https://i.loli.net/2021/11/12/T2AcdBGaulseStP.png" alt="image.png" style="zoom: 67%;"></p><h3 id="网络应用进程通信"><a href="#网络应用进程通信：" class="headerlink" title="网络应用进程通信："></a>网络应用进程通信：</h3><p>​<strong>网络应用的基础：进程间的通信</strong></p><p>​<strong>进程：</strong>主机上运行的程序</p><p>​<strong>同一主机</strong>的进程之间的通信方式：进程间通信机制，操作系统提供。<strong>不同主机</strong>：消息交换（报文交换）</p><hr><p>​    客户机进程：发起通信的进程</p><p>​服务器进程：等待通信请求的进程</p><hr><h4 id="套接字socket"><a href="#套接字：Socket" class="headerlink" title="套接字：Socket"></a><strong>套接字：Socket</strong></h4><img src="https://i.loli.net/2021/11/12/ziQj7CKecGqk1hx.png" alt="image.png" style="zoom:67%;"><p><strong>进程间通信利用socket发送&#x2F;接收消息实现</strong></p><p>​<strong>类似于寄信：</strong></p><p>​发送方将消息送到门外邮箱</p><p>​发送方依赖（门外的）传输基础设施将消息传到接收方所在的主机，并送到接收方的门外</p><p>​接收方从门外获取消息</p><p>​<strong>传输基础设施向进程提供API:</strong></p><p>​传输协议的选择；参数的设置</p><h4 id="如何寻址进程"><a href="#如何寻址进程" class="headerlink" title="如何寻址进程"></a>如何寻址进程</h4><p>不同主机上的进程间通信，每个进程必须拥有<strong>标识符</strong></p><p>如何寻址主机——<strong>IP地址</strong></p><p>Q：主机的IP地址是否足以定位进程？</p><p>A：否。同一主机上可能同时有多个进程需要通信。</p><p><strong>端口号&#x2F;Port number</strong></p><ul><li><p>为主机上每个需要通信的进程分配一个端口号</p></li><li><p>HTTP Server：80</p></li><li><p>Mail Server：25</p><p><strong>进程的标识符&#x3D;IP地址+端口号</strong></p></li></ul><h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><p>网络应用需要遵顼应用层协议</p><p><strong>公开协议：</strong></p><p>​由RFC（Request For Comments）定义</p><p>​允许互操作</p><p>​HTTP、SMTP……</p><p><strong>私有协议：</strong></p><p>​多数P2P文件共享应用</p><h4 id="协议内容"><a href="#协议内容" class="headerlink" title="协议内容"></a>协议内容</h4><p><strong>消息的类型：</strong>请求消息、响应消息。</p><p><strong>消息的语法（Syntax）&#x2F;格式：</strong>消息中有哪些字段（field）、字段如何描述</p><p><strong>字段的语义（semantics）：</strong>字段中信息的含义</p><p><strong>规则（rules）：</strong>进程何时发送&#x2F;响应消息</p><h2 id="2网络应用的服务需求"><a href="#2-网络应用的服务需求" class="headerlink" title="2.网络应用的服务需求"></a>2.网络应用的服务需求</h2><p><strong>数据丢失（data loss）&#x2F;可靠性（reliability）</strong></p><ul><li>​某些网络应用能够容忍一定的数据丢失：网络电话</li><li>​某些网络应用要求100%可靠的数据传输：文件传输，telnet</li></ul><p><strong>时间（timing）&#x2F;延迟（delay）</strong></p><ul><li>​有些应用只有在延迟足够低时才“有效”</li><li>​网络电话&#x2F;网络游戏</li></ul><p><strong>带宽（bandwith）</strong></p><ul><li>某些应用只有在带宽达到最低要求时才“有效”：网络视频</li><li>某些应用能够适应任何带宽——弹性应用：email</li></ul><p><strong>典型网络应用对传输服务的需求：</strong></p><p><img src="https://i.loli.net/2021/11/12/kxXHiIqlOFuo4wL.png" alt="image.png"></p><h2 id="3internet传输层服务模型"><a href="#3-Internet传输层服务模型" class="headerlink" title="3.Internet传输层服务模型"></a>3.Internet传输层服务模型</h2><h3 id="internet提供的传输服务"><a href="#Internet提供的传输服务" class="headerlink" title="Internet提供的传输服务"></a>Internet提供的传输服务</h3><p><img src="https://i.loli.net/2021/11/12/DcwX5anpjdIFYkq.png" alt="image.png"></p><h3 id="典型网络应用所使用的传输层服务"><a href="#典型网络应用所使用的传输层服务" class="headerlink" title="典型网络应用所使用的传输层服务"></a><strong>典型网络应用所使用的传输层服务</strong></h3><p><img src="https://i.loli.net/2021/11/12/ams3t6JbzgNZpAG.png" alt="image.png"></p><h2 id="4特定网络应用及协议"><a href="#4-特定网络应用及协议" class="headerlink" title="4.特定网络应用及协议"></a>4.特定网络应用及协议</h2><h3 id="web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h3><h4 id="关于web"><a href="#关于Web" class="headerlink" title="关于Web"></a><strong>关于Web</strong></h4><p><strong>World Wide Web:Tim Berners-Lee</strong></p><ul><li>网页</li><li>网页互相链接</li></ul><p><strong>网页（Web Page）包含多个对象（objects）</strong></p><ul><li>​对象：HTML文件、JPEG图片、视频文件、动态脚本等</li><li>​基本HTML文件：包含对其他对象引用的链接</li></ul><p> 对象的寻址（addressing）</p><p>URL（Uniform Resoure Locator）：统一资源定位器</p><p>Scheme：&#x2F;&#x2F;host：port&#x2F;path</p><h4 id="http"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p><strong>HTTP协议：</strong>万维网应用遵循<strong>超文本传输协议</strong>（HyperText Transfer Protocol）</p><p><strong>C&#x2F;S结构</strong></p><ul><li>客户——Browser：请求、接收、展示Web对象</li><li>服务器——Web Server：响应客户的请求，发送对象。（Apache Web Server）</li></ul><p><strong>HTTP版本：</strong>1.0：RFC1945，1.1：RFC2068</p><p><strong>使用TCP传输服务：</strong></p><ul><li>服务器在80端口等待客户的请求</li><li>浏览器发起到服务器的TCP连接（创建套接字Socket）</li><li>服务器接受来自浏览器的TCP连接</li><li>浏览器（HTTP客户端）与Web服务器（HTTP服务器）交换HTTP消息</li><li>关闭TCP连接</li></ul><p><strong>无状态（stateless）：</strong>服务器不维护任何有关客户端过去所发请求的信息</p><p><strong>有状态的协议</strong>更复杂：需要维护状态（历史信息）、如果客户或服务器失效，会产生状态的不一致，解决这种问题代价高</p><h5 id="http连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h5><p><strong>非持久性连接（Nonpersistent HTTP）</strong>：每个TCP连接最多允许传输一个对象；HTTP 1.0版本使用非持久性连接。</p><p><img src="https://i.loli.net/2021/11/12/4LuIbDASHGgqrYp.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/11/12/bvYnAystu14rHW2.png" alt="image.png"></p><h6 id="响应时间分析与建模"><a href="#响应时间分析与建模" class="headerlink" title="响应时间分析与建模"></a>响应时间分析与建模</h6><p><strong>RTT（Round Trip Time）</strong>：从客户端发送一个很小的数据包到服务器并返回所经历的时间</p><p>响应时间（Response time）</p><p>​发起、建立TCP连接：1个RTT</p><p>​发送HTTP请求消息到HTTP响应消息的前几个字节到达：1个RTT</p><p>​响应消息中所含文件&#x2F;对象传输时间</p><p>​Total &#x3D; 2RTT + 文件发送时间</p><p>​<img src="https://i.loli.net/2021/11/12/F2SA5aBWHxlfOU6.png" alt="image.png"></p><p><strong>非持久性连接存在一些问题：</strong></p><p>​每个对象需要2个RTT</p><p>​操作系统需要为每个TCP连接开销资源（overhead）</p><p>​ </p><ul><li><strong>持久性连接（persistent HTTP）</strong>：每个TCP连接最多允许传输多个对象；HTTP 1.1版本默认使用持久性连接</li></ul><p>发送响应后，服务器保持TCP连接的打开</p><p>后续的HTTP消息可以通过这个连接发送</p><ul><li><strong>无流水（pipelining）的持久性连接</strong><ul><li>客户端只有收到前一个响应后才发送新的请求</li><li>每个被引用的对象耗时1个RTT</li></ul></li><li><strong>带有流水机制的持久性连接</strong><ul><li>HTTP 1.1的默认选项</li><li>客户端只要遇到一个引用对象就尽快发出请求</li><li>理想请求下，收到所有的引用对象只需耗时约1个RTT</li></ul></li></ul><h5 id="http消息格式"><a href="#HTTP消息格式" class="headerlink" title="HTTP消息格式"></a>HTTP消息格式</h5><ul><li>请求消息<ul><li>ASCII码：人直接可读</li></ul></li></ul><p><img src="https://i.loli.net/2021/11/28/1d9fbOwySEFxgVq.png" alt="image.png"></p><p>上传输入的方法：</p><p>​POST方法：网页经常需要填写表格（form）&#x2F;在请求消息的消息体（entity body）中上传客户端的输入</p><p>​URL方法：使用GET方法&#x2F;输入信息通过request行的URL字段上传</p><p><img src="https://i.loli.net/2021/11/28/jZbC38q9JScfmzv.png" alt="image.png"></p><ul><li>响应消息</li></ul><p><img src="https://i.loli.net/2021/11/28/6CMy7RsVkHpnowv.png" alt="image.png"></p><h4 id="cookie技术"><a href="#Cookie技术" class="headerlink" title="Cookie技术"></a>Cookie技术</h4><p>HTTP协议无状态，很多应用需要服务器掌握客户端的状态，如：网上购物</p><ul><li>某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。</li></ul><h5 id="cookie的组件"><a href="#Cookie的组件" class="headerlink" title="Cookie的组件"></a>Cookie的组件</h5><ul><li>HTTP响应消息的cookie头部行</li><li>HTTP请求消息的cookie头部行</li><li>保存在客户端主机上的cookie文件，由浏览器管理</li><li>Web服务器端的后台数据</li></ul><h5 id="cookie的原理"><a href="#Cookie的原理" class="headerlink" title="Cookie的原理"></a>Cookie的原理</h5><p><img src="https://i.loli.net/2021/12/03/3N6KWmhL14Rupkq.png" alt="image.png"></p><h5 id="cookie的作用"><a href="#Cookie的作用" class="headerlink" title="Cookie的作用"></a>Cookie的作用</h5><ul><li>身份认证</li><li>购物车</li><li>推荐</li><li>Web e-mail ……</li></ul><p><strong>Cookie技术存在一定的隐私问题</strong></p><h4 id="web缓存x2f代理服务器技术"><a href="#Web缓存-x2F-代理服务器技术" class="headerlink" title="Web缓存&#x2F;代理服务器技术"></a>Web缓存&#x2F;代理服务器技术</h4><p>​<strong>功能：在不访问服务器的前提下满足客户端的HTTP请求</strong></p><p><strong>为什么要发明这种技术？</strong></p><ul><li>缩短客户请求的响应时间</li><li>减少机构。组织的流量</li><li>在大范围内(Internet)实现有效的内容分发</li></ul><h5 id="关于该技术"><a href="#关于该技术" class="headerlink" title="关于该技术"></a>关于该技术</h5><ul><li><p><strong>用户设定浏览器通过缓存进行Web访问</strong></p></li><li><p><strong>浏览器向缓存&#x2F;代理服务器发送所有的HTTP请求</strong></p><ul><li>如果所请求对象在缓存中，缓存返回对象</li><li>否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后返回给客户端并保存该对象</li></ul></li></ul><p><strong>缓存既充当客户端，也充当服务器</strong></p><p><strong>一般由ISP(Internet服务提供商)假设</strong></p><h5 id="条件性get方法"><a href="#条件性GET方法" class="headerlink" title="条件性GET方法"></a>条件性GET方法</h5><p><img src="https://i.loli.net/2021/12/03/BC3PMmiOoLtvWZT.png" alt="image.png"></p><h3 id="email应用"><a href="#Email应用" class="headerlink" title="Email应用"></a>Email应用</h3><h4 id="构成组件"><a href="#构成组件" class="headerlink" title="构成组件"></a>构成组件</h4><ul><li>邮件客户端（user agent）</li><li>邮件服务器</li><li>SMTP协议（Simple Mail Transfer Protocol）</li></ul><h4 id="邮件客户端"><a href="#邮件客户端" class="headerlink" title="邮件客户端"></a>邮件客户端</h4><ul><li>读、写Email消息</li><li>与服务器交互，收、发Email消息</li><li>Outlook，Foxmail，Thunderbird</li><li>Web客户端</li></ul><h4 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h4><ul><li>邮箱：存储发给该用户的Email</li><li>消息队列（message queue）：存储等待发送的Email</li></ul><h4 id="smtp协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h4><ul><li>邮件服务器之间传递消息所使用的协议</li><li>客户端：发送消息的服务器</li><li>服务器：接受消息的服务器</li></ul><p><strong>采取TCP进行email消息的可靠传输</strong></p><p><strong>端口25</strong></p><p><strong>传输过程的三个阶段：握手-&gt;消息的传输-&gt;关闭</strong></p><p><strong>命令&#x2F;响应交互模式：</strong></p><p><strong>命令（command）：ASCII文本</strong></p><p><strong>响应（response）：状态代码和语句</strong></p><p><strong>Email消息只能包含7位ASCII码</strong></p><ul><li>使用持久性连接</li><li>消息必须由7位ASCII码构成</li><li>SMTP服务器利用CRLF.CRLF确定消息的结束</li></ul><h5 id="smtp-vs-http"><a href="#SMTP-vs-HTTP" class="headerlink" title="SMTP vs HTTP"></a>SMTP vs HTTP</h5><p>SMTP：退式（push） HTTP：拉式（pull）</p><p>都使用命令&#x2F;响应交互模式</p><p>命令和状态代码都是ASCII码</p><p><strong>HTTP：</strong>每个对象封装在独立的响应消息中</p><p><strong>SMTP：</strong>多个对象在由多个部分构成的消息中发送</p><h4 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h4><p><img src="https://i.loli.net/2021/12/03/PzuLh9Knlw8FCp6.png" alt="image.png"></p><h5 id="多媒体扩展"><a href="#多媒体扩展" class="headerlink" title="多媒体扩展"></a>多媒体扩展</h5><p><img src="https://i.loli.net/2021/12/03/YjCXwieSypHGhOu.png" alt="image.png"></p><h4 id="邮件访问协议从服务器获取邮件"><a href="#邮件访问协议：从服务器获取邮件" class="headerlink" title="邮件访问协议：从服务器获取邮件"></a>邮件访问协议：从服务器获取邮件</h4><p><strong>POP：Post Office Protocol</strong></p><ul><li>认证&#x2F;授权（客户端&lt;–&gt;服务器）和下载</li><li>……</li></ul><p>IMAP：Internet Mail Access Protocol</p><p>HTTP：163，QQ Mail等</p><h3 id="dns应用"><a href="#DNS应用" class="headerlink" title="DNS应用"></a>DNS应用</h3><p><strong>DNS（Domain Name System）：解决Internet上主机&#x2F;路由器的识别问题</strong></p><ul><li>IP地址</li><li>域名：<a href="http://www.baidu.com/">www.baidu.com</a></li></ul><p>如何解决域名和IP地址之间的映射？</p><ul><li><strong>域名解析系统DNS</strong><ul><li>多层命名服务器构成的分布式数据库</li><li>应用层协议：完成名字的解析<ul><li>internet核心功能，用应用层协议实现</li><li>网络边界复杂</li></ul></li></ul></li></ul><h5 id="dns服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h5><ul><li>域名向IP地址的翻译</li><li>主机别名</li><li>邮件服务器别名</li><li>负载均衡：Web服务器</li></ul><p>为什么不适应集中式的DNS？</p><ul><li>单点失败问题</li><li>流量问题</li><li>距离问题</li><li>维护性问题</li></ul><p><strong>分布式层次式数据库</strong></p><p><img src="https://s2.loli.net/2022/01/30/bTfAOjkpUgc7rhF.png" alt="image.png"></p><h4 id="本地域名解析服务器"><a href="#本地域名解析服务器：" class="headerlink" title="本地域名解析服务器："></a>本地域名解析服务器：</h4><ul><li>不严格属于层级体系</li><li>每个ISP有一个本地域名服务器<ul><li>默认域名解析服务器</li></ul></li><li>当主机进行DNS查询时，查询被发送到本地域名服务器<ul><li>作为代理（proxy），将查询转发给（层级式）域名服务器解析系统</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/30/UYLvGO57jXMqJVa.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/01/31/nmjaNg6KRfU7hZw.png" alt="image.png"></p><h4 id="dns记录缓存和更新"><a href="#DNS记录缓存和更新" class="headerlink" title="DNS记录缓存和更新"></a>DNS记录缓存和更新</h4><ul><li>只要域名解析服务器获得域名—IP映射，即缓存这一映射<ul><li>一段时间过后，缓存条目失效（删除）</li><li>本地域名服务器一般会缓存顶级域名服务器的映射<ul><li>因此根域名服务器不会被经常访问</li></ul></li></ul></li></ul><h4 id="dns记录和消息格式"><a href="#DNS记录和消息格式" class="headerlink" title="DNS记录和消息格式"></a>DNS记录和消息格式</h4><p><img src="https://s2.loli.net/2022/01/31/jZ1DAhz2dVgluXS.png" alt="image.png"></p><p><strong>DNS协议</strong></p><ul><li>查询（query）和回复（reply）消息</li><li>消息格式相同</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;应用层&quot;&gt;&lt;a href=&quot;#应用层&quot; class=&quot;headerlink&quot; title=&quot;应用层&quot;&gt;&lt;/a&gt;应用层&lt;/h1&gt;&lt;h2 id=&quot;1网络应用的体系结构&quot;&gt;&lt;a href=&quot;#1-网络应用的体系结构&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="计网" scheme="http://dezeem.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>SSL</title>
    <link href="http://dezeem.github.io/2021/10/30/2021-10-21-12/"/>
    <id>http://dezeem.github.io/2021/10/30/2021-10-21-12/</id>
    <published>2021-10-29T21:39:00.000Z</published>
    <updated>2024-05-08T13:02:33.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验十二"><a href="#实验十二" class="headerlink" title="实验十二"></a>实验十二</h1><p>​<img src="https://i.loli.net/2021/10/29/r7oKa5uW6tFRYIc.png" alt="image.png"></p><p>1.对于前 8个以太网帧，请分别指出每一个帧的来源（客户端和服务器），确定每个帧包含的SSL记录的数量，并且列出包含SSL记录的类型。绘制客户端和服务器含有箭头指向的时序图。</p><p><img src="https://i.loli.net/2021/10/29/uWHFYlKdyz5OJQB.png" alt="image.png"></p><p>2.每个 SSL记录都以相同的三个字段（可能具有不同的值）开头。 其中一个 字段是“内容类型”，长度为一个字节。 请列出所有三个字段及其长度。</p><p>​<img src="https://i.loli.net/2021/10/29/Ll9UrxhIvQCEDHB.png" alt="image.png"></p><p>​Content Type字段为1字节，Version字段为2字节，Length字段为2字节:</p><p>3.展开 ClientHello记录（如果您的跟踪包含多个 ClientHello记录，请展开包 含第一个记录的以太网帧），内容类型的值是多少？</p><p>​Content Type: Handshake(22)</p><p>4.ClientHello记录是否包含随机数（也称为“挑战码”（ challenge））？ 如果是 这样，十六进制的挑战码值是多少？</p><p>​包含</p><p>5.ClientHello记录是否通知了它所支持密码加密套件（suite）？如果是这样， 请在第一个密码套件， 分别指出非对称密钥加密算法，对称密钥加密算法，哈希算法分别都是什么？<strong>（待补充）</strong></p><p>​<img src="https://i.loli.net/2021/10/29/oPWDlueUQjhG1sp.png" alt="image.png"></p><p>6.找到 ServerHello SSL记录。 此记录是否指定了之前的密码套件之一？ 选择的密码套件中有哪些算法？</p><p>​<img src="https://i.loli.net/2021/10/29/yOQ3w2HPEVKtZs5.png" alt="image.png"></p><p>​指定了哈希加密算法（SHA哈希函数）</p><p>7.此记录是否包含随机数？如果有，它有多长？SSL中客户端和服务器段随机数用来干什么？</p><p>​包含，有32字节，也就是用64个16进制数来表示。多次随机数生成为未来生成对话密钥提高安全性能。</p><p>8.此记录是否包含会话 ID？ 会话 ID的目的是什么？</p><p>​包含（有的可能不会包含，也就是可以有也可以没有）</p><p>​目的：用一定时间内端口连接快速恢复连接过程。</p><p>9.此记录是否包含证书，或者证书是否包含在单独的记录中。 证书是否适合一个单独的以太网帧传输？</p><p>10.找到客户端密钥交换记录。 此记录是否包含前主密钥(pre-master secret)？ 这个前主密钥用于什么？ 前主密钥加密了吗？ 如果是这样，为什么？ 加密的前主密钥有多长？</p><p>​1）包含<br>​3）使用EC Diffie-Hellman（ECDH加密算法）进行加密传输，使用的是服务器公钥加密，用以给服务器让服务器用私钥解密并且使用前面两个hello过程的随机数生成本次的会话加密密钥。<br>​4）32个字节</p><p>11.编码改变记录目的是什么？在您的跟踪中本记录有多少字节？</p><p>​告诉服务器已经计算好加密密钥，以后将会用商定的加密方式和密钥加密传输了，在我的跟踪中该记录有6个字节。</p><p>12.在加密的握手记录中，什么是加密的？ 为什么？</p><p>​消息校验码是加密的，这个校验码是包含之前所有连接消息的摘要加密格式，只有服务器可以解开，因为在建立连接中，存在可能连接消息被侦听和更改的情况，因此还需要进行信息摘要计算和加密传输，判断是否存在异常，如果异常，将会直接关闭连接。</p><p>13.服务器是否还向客户端发送更改编码记录和加密的握手记录？ 这些记录与客户发送的记录有何不同？</p><p>14.如何加密应用程序数据？ 包含应用程序数据的记录是否包含消息认证码 MAC？ Wireshark是否区分加密的应用程序数据和消息认证码 MAC？</p><p>​<img src="https://i.loli.net/2021/10/29/9vI8LyXZGQhm71P.png" alt="image.png"></p><p>​使用本次对话协商和交换好对称加密密钥应用程序数据，这个数据里同时包括消息本身和消息认证码，所以比消息本身要长，但是加密过，所以无法区分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验十二&quot;&gt;&lt;a href=&quot;#实验十二&quot; class=&quot;headerlink&quot; title=&quot;实验十二&quot;&gt;&lt;/a&gt;实验十二&lt;/h1&gt;&lt;p&gt;​		&lt;img src=&quot;https://i.loli.net/2021/10/29/r7oKa5uW6tFRYIc.png</summary>
      
    
    
    
    <category term="Wireshark" scheme="http://dezeem.github.io/categories/Wireshark/"/>
    
    
    <category term="计网" scheme="http://dezeem.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>802.11 WIFI</title>
    <link href="http://dezeem.github.io/2021/10/30/2021-10-21-11/"/>
    <id>http://dezeem.github.io/2021/10/30/2021-10-21-11/</id>
    <published>2021-10-29T21:13:00.000Z</published>
    <updated>2024-05-08T13:02:40.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验十一"><a href="#实验十一" class="headerlink" title="实验十一"></a>实验十一</h1><h2 id="信标框架"><a href="#信标框架" class="headerlink" title="信标框架"></a>信标框架</h2><p>​<img src="https://i.loli.net/2021/10/29/Tdwt7mhXSWMeskf.png" alt="image.png"></p><ol><li><p>发出此跟踪中大多数信标帧的两个接入点的SSID是什么？</p><p><strong>分别为30 Munroe st   linksys12这两个SSID</strong></p></li><li><p>从linksys_ses_24086接入点发送信标帧之间的时间间隔是多少？</p><p><strong>时间间隔0.102400s beacon Interval处可见</strong></p></li><li><p>Munroe街30号信标帧上的源MAC地址是什么（十六进制表示法）？回想一下本文中的图7.13，源、目标和BSS是802.11帧中使用的三个地址。</p><p><img src="https://i.loli.net/2021/10/29/NG3xRB28p5EHkYL.png" alt="image.png"></p><p><strong>00:16:b6:f7:1d:51</strong></p></li></ol><p>4.Munroe街30号信标帧上的目标MAC地址是什么（十六进制表示法）？</p><p>​<strong>广播帧ff:ff:ff:ff:ff:ff</strong></p><p>5.Munroe街30号信标帧上的MAC BSS id是什么（十六进制表示法）？<br>    <strong>BSS id 还是00:16:b6:f7:1d:51</strong></p><p>6.来自30 Munroe St接入点的信标帧表明接入点可以支持四种数据速率和八种额外的“扩展支持速率”。这些速率是多少？</p><p>​<strong>1B 2B 5.5B 11B</strong></p><p>​<strong>6B 9B 12B 18B 24B 36B 48B 54B</strong></p><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>1.查找包含此第一个TCP会话（下载alice.txt）的SYN TCP段的802.11帧。802.11帧中有哪三个MAC地址字段？此帧中的哪个MAC地址对应于无线主机（给出主机MAC地址的十六进制表示）？到接入点？到第一跳路由器？发送此TCP段的无线主机的IP地址是什么？目标IP地址是什么？此目标IP地址是否对应于主机、接入点、第一跳路由器或其他网络连接设备？解释一下。<br>        主机所在的地址为中间的 00:13:02:d1:b6:4f<br>        AP的MAC地址为第一条00:16:b6:f7:1d:51<br>        路由器的MAC地址为最后一条00:16:b6:f4:eb:a8<br>        目标IP地址为第一条路由器</p><p><img src="https://i.loli.net/2021/10/29/B14ftsbXLx5uyeT.png" alt="image.png"></p><p>2.查找包含此TCP会话的SYNACK段的802.11帧。802.11帧中有哪三个MAC地址字段？此帧中的哪个MAC地址对应于主机？到接入点？到第一跳路由器？帧中的发送方MAC地址是否与发送此数据报中封装的TCP段的设备的IP地址相对应？</p><h2 id="协会x2f脱离关系"><a href="#协会-x2F-脱离关系" class="headerlink" title="协会&#x2F;脱离关系"></a>协会&#x2F;脱离关系</h2><p>1.在t&#x3D;49之后，主机在跟踪中采取了哪两个操作（即发送帧），以结束与30 Munroe St AP的关联，该AP最初在跟踪收集开始时处于适当位置？<br>        这两条 一个是IP层 DHCP 主动Release 一个是802.11层 向我们的AP发出解除关联<br>2.检查跟踪文件并查找从主机发送到AP的身份验证帧，反之亦然。从t&#x3D;49开始，从无线主机向linksys_ses_24086 AP（MAC地址为Cisco_Li_f5:ba:bb）发送多少验证消息。<br>        <strong>15条</strong></p><p>3.主机希望身份验证需要密钥还是打开？</p><p>​希望打开</p><p>4.您是否在跟踪中看到来自linksys_ses_24086 AP的回复身份验证？<br>    <strong>没有</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验十一&quot;&gt;&lt;a href=&quot;#实验十一&quot; class=&quot;headerlink&quot; title=&quot;实验十一&quot;&gt;&lt;/a&gt;实验十一&lt;/h1&gt;&lt;h2 id=&quot;信标框架&quot;&gt;&lt;a href=&quot;#信标框架&quot; class=&quot;headerlink&quot; title=&quot;信标框架&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Wireshark" scheme="http://dezeem.github.io/categories/Wireshark/"/>
    
    
    <category term="计网" scheme="http://dezeem.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>ICMP</title>
    <link href="http://dezeem.github.io/2021/10/30/2021-10-21-9/"/>
    <id>http://dezeem.github.io/2021/10/30/2021-10-21-9/</id>
    <published>2021-10-29T19:44:00.000Z</published>
    <updated>2024-05-08T13:02:45.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验九"><a href="#实验九" class="headerlink" title="实验九"></a>实验九</h1><h2 id="ping-程序"><a href="#Ping-程序" class="headerlink" title="Ping 程序"></a>Ping 程序</h2><ol><li><p>打开cmd</p></li><li><p>启动嗅探器，开始捕获</p></li><li><p>输入“ping –n 10 <a href="http://www.mit.edu”/">www.mit.edu”</a></p><p><img src="https://i.loli.net/2021/10/29/EyXcKetvTF5YkgG.png" alt="image.png"></p><p>​主机上的 ping 程序发送了10 个查询包并收到了 10 响应对于每个响应，源计算往返时间（RTT），数据包平均为 343 毫秒。</p><p>4.Ping 程序终止时，停止在 Wireshark 中捕获数据包。<img src="https://i.loli.net/2021/10/29/vgGBnlrusFWKmzE.png" alt="image.png"></p><p>​数据包列表显示 20 个数据包，说明源发送的 10 个 Ping 查询和源接收的 10 个 Ping 响应。数据包内容区域可以查看此数据包的信息，该数据包中的 IP 数据报的协议号ICMP 的协议号 01，这表示 IP 数据报的有效载荷是 ICMP 数据包。</p><p>​<img src="https://i.loli.net/2021/10/29/xWDZSYTltgV1aHs.png" alt="image.png"></p><p>​<img src="https://i.loli.net/2021/10/29/cztsFDV1xQ38jPw.png" alt="image.png"></p><p>​该 ICMP 包的详情信息，数据包包含校验和，标识符和序列号，该 ICMP 数据包是类型 8 和代码 0，也就是“<strong>回应请求</strong>”数据包。</p></li><li><p>源主机的 IP 地址是多少？目标主机的 IP 地址是多少？</p><p><strong>源主机：192.168.31.79</strong><br><strong>目标主机：23.66.153.41</strong></p></li><li><p>为什么 ICMP 数据包没有源端口号和目的端口号？</p><p><strong>因为 ICMP 报文作为 IP 有效载荷承载的，不需要像 TCP 或 UDP 那样需要端口号。</strong></p></li><li><p>查看任意的请求 ICMP 数据包，ICMP 类型和代码是什么？该 ICMP 数据包还有哪些其他字段？校验和，序列号和标识符字段有多少字节？</p><p><strong>类型 8 和代码 0，也就是回应请求报文，还有校验和，序列号和标识符字段，都是 4 字节。</strong></p></li><li><p>查看任意的响应 ICMP 数据包，ICMP 类型和代码是什么？该 ICMP 数据包还有哪些其他字段？校验和，序列号和标识符字段有多少字节？</p><p><img src="https://i.loli.net/2021/10/29/yw9aFOXqRsLnBfk.png" alt="image.png"></p><p><strong>类型 0 编码 0 是回显应答报文，还有校验和，序列号和标识符字段，都是 4 字节。</strong></p><h2 id="traceroute-命令"><a href="#Traceroute-命令" class="headerlink" title="Traceroute 命令"></a>Traceroute 命令</h2><ol><li><p>打开 cmd</p></li><li><p>启动嗅探器，并开始捕获</p></li><li><p>输入“tracert <a href="http://www.inria.fr”/">www.inria.fr”</a></p></li><li><p>tracert 程序终止时，停止在 Wireshark 中捕获数据包。</p><p><img src="C:\Users\28190\AppData\Roaming\Typora\typora-user-images\image-20211029200859501.png" alt="image-20211029200859501"></p><p><img src="https://i.loli.net/2021/10/29/WpHbgaBkK7zGdhL.png" alt="image.png"></p><p>​对于每个 TTL 值，源程序发送三个探测包。 Traceroute 显示每个探测包的 RTT，以及返回 ICMP TTL 超出消息的路由器的 IP 地址和名称。</p></li></ol></li><li><p>您的主机的 IP 地址是多少？目标目标主机的 IP 地址是多少？</p><p><strong>源主机：192.168.31.70</strong><br><strong>目标主机：128.93.162.83</strong></p></li><li><p>如果 ICMP 发送了 UDP 数据包（如在 Unix &#x2F; Linux 中），那么探测数据包的 IP 协议号仍然是 01 吗？ 如果没有，它会是什么？</p></li><li><p>检查屏幕截图中的 ICMP 响应数据包。这与本实验的前半部分中的 ICMP ping 查询数据包不同吗？如果不同，请解释为什么？</p><p><img src="https://i.loli.net/2021/10/29/1Gf3jY2Ik5DEPlS.png" alt="image.png"></p><p>​<strong>不同，这里的 ICMP 报文时TTL 报文(类型 11 编码 0)，这个是在 Traceroute 程序中，路由器检查到 Traceroute 发出的 IP 数据报中 TTL 正好过期，因此路由器就需要丢包并且发送该警告报文返回源主机。这个与 Ping 程序中所要达成的目的不同，Ping 程序是为了请求响应。</strong></p><p>4.检查屏幕截图中的 ICMP 错误数据包。它具有比 ICMP 响应数据包更多的字段。这个数据包含哪些内容？</p><p>​<img src="https://i.loli.net/2021/10/29/1Gf3jY2Ik5DEPlS.png" alt="image.png"></p><p>​<strong>比响应数据包多了 ICMP 请求数据包的内容。</strong></p><p>5.检查源主机收到的最后三个 ICMP 数据包。这些数据包与 ICMP 错误数据包有何不同？他们为什么不同？</p><p>​<img src="https://i.loli.net/2021/10/29/BV5ehGHoLsK2bzq.png" alt="image.png"></p><p>​<strong>这个是目的主机返回的回显应答报文，因为 tracert 程序的原理是发送 TTL 增加的数据包，当 TTL &#x3D; 1 的包达到路由器，该路由器会将该包丢弃，并且发送 ICMP 错误给请求的机器。而最后一组 3 个数据报时可以到达目的主机的，这时由于是被目的主机接收，目的主机不会丢包，而是确确实实收到的这个探测的数据报并进行了响应。</strong></p><p>6.在 tracert 跟踪测量中，是否有一个连接的延迟比其他连接长得多？是否有连接的延迟明显长于其他连接？根据路由器名称，您能猜出这个连接末端的两个路由器的位置吗？</p><p>​<strong>在第 8 个节点时延突增，之后的节点时延都达到了 250+ ms。之后的路由器名都是英文名，且目的地是法国，那应该是连接到了亚洲转欧洲的分界路由器了。</strong></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验九&quot;&gt;&lt;a href=&quot;#实验九&quot; class=&quot;headerlink&quot; title=&quot;实验九&quot;&gt;&lt;/a&gt;实验九&lt;/h1&gt;&lt;h2 id=&quot;ping-程序&quot;&gt;&lt;a href=&quot;#Ping-程序&quot; class=&quot;headerlink&quot; title=&quot;Ping 程序</summary>
      
    
    
    
    <category term="Wireshark" scheme="http://dezeem.github.io/categories/Wireshark/"/>
    
    
    <category term="计网" scheme="http://dezeem.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>DHCP</title>
    <link href="http://dezeem.github.io/2021/10/28/2021-10-21-8/"/>
    <id>http://dezeem.github.io/2021/10/28/2021-10-21-8/</id>
    <published>2021-10-27T21:13:00.000Z</published>
    <updated>2024-05-08T13:03:28.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验八"><a href="#实验八" class="headerlink" title="实验八"></a>实验八</h1><h2 id="dhcp-实验"><a href="#DHCP-实验" class="headerlink" title="DHCP 实验"></a>DHCP 实验</h2><ol><li><p>打开cmd，输入ipconfig&#x2F;release</p></li><li><p>启动嗅探器并开始捕获。</p></li><li><p>cmd输入ipconfig&#x2F;renew</p></li><li><p>再输入ipconfig&#x2F;release</p></li><li><p>再输入ipconfig&#x2F;renew</p></li><li><p>停止捕获</p><p>​<img src="https://i.loli.net/2021/10/27/Vewb9O5KnHcSmFC.png" alt="image.png"></p><p>​1.DHCP 消息是否通过 UDP 或 TCP 发送？</p><p>​<strong>UDP</strong></p><p>​2.绘制时间数据图，说明客户端和服务器之间第一个四包发现&#x2F;提供&#x2F;请求&#x2F;ACK DHCP 交换的顺序。对于每个数据包，指示源和目的地端口编号。端口编号与此实验室作业中给出的示例相同吗？</p><p><strong>Offer&#x2F;Request&#x2F;ACK&#x2F;release&#x2F;Discover</strong></p><p>​3.主机的链接层（例如以太网）地址是什么？<strong>WIFI无法查看</strong></p><p>​4.DHCP 发现消息中的哪些值将此消息与 DHCP 请求消息区分开来？</p><p>​<img src="https://i.loli.net/2021/10/27/uiyv3zeq5KtOY6X.png" alt="image.png"></p><p>​<strong>Type</strong></p><p>​5.前四条（发现&#x2F;提供&#x2F;请求&#x2F;ACK）DHCP 消息中每个邮件中的交易 ID 值是怎样的？ 第二组 （请求&#x2F;ACK） DHCP 消息中的交易 ID 值是哪些？ 交易 ID 字段的目的是什么？</p><p>​<strong>用于确认是哪条请求 类似于TCP IP的序列号</strong></p><p>​6.主机使用 DHCP 获取 IP 地址，除其他外。但主机的 IP 地址直到四消息交换结束才得到确认！ 如果 IP 地址直到四消息交换结束才设置，那么在四消息交换中的 IP 数据图中使用了哪些值？ 对于四个 DHCP 消息（发现&#x2F;提供&#x2F;请求&#x2F;ACK DHCP），指示封装 IP 数据图中携带的源和目的地 IP 地址。<br>​7.您的 DHCP 服务器的 IP 地址是哪个？</p><p>​<strong>192.168.254.254</strong></p><p>​8.DHCP 服务器在DHCPoffer消息中向主机提供什么IP地址？指示哪个DHCP消息包含提供的 DHCP 地址。<br>​<img src="https://i.loli.net/2021/10/27/AbxCtNkpEIZgY2P.png" alt="image.png"></p><p>​9.在此任务中的示例屏幕截图中，主机和 DHCP 服务器之间没有继电器。跟踪中的哪些值表示缺少继电器？ 你的实验中是否有Agent？如果是，代理的 IP 地址是什么？</p><p>​<strong>没有Agent</strong></p><p>​10.解释 DHCP 提供消息中路由器和子网掩码的目的。</p><p>​<strong>首先告诉路由器IP是因为我们之后得到了路由器IP以后发送一些请求的时候就向我们的路由器发送了等于起到了中间代理的作用</strong></p><p>​<strong>告诉我们子网掩码 是告诉我们当前我们获取子网的大小 告诉我们更多的信息便于以后配置。</strong></p><p>​11.在脚注 2 中注明的 DHCP 跟踪文件中，DHCP 服务器向客户端提供了特定的 IP 地址（参见上面的第 8 个问题）。 在客户对第一个服务器 OFFER 消息的响应中，客户端是否接受此 IP 地址？ 客户请求的地址在客户响应中的位置？</p><p>​接受了IP地址因为发出的Request请求我们请求的IP就是DHCP申请出来的OFFE的那个IP如下图客户端的IP地址请求在选项字段</p><p>​<img src="https://i.loli.net/2021/10/27/Wrl4ScOFT17deX5.png" alt="image.png"></p><p>​</p><p>​12.解释租赁时间的目的。实验中的租赁时间有多长？<br>​<strong>因为DHCP服务器分配是不永久分配的，都是临时分配的且是有时间的如果时间到期就需要重新申请或者续期如果没有重新租赁的话DHCP服务器即自动关闭与其的服务提供</strong><br>​<strong>实验中的话 即租赁时间为1个小时</strong></p><p>​<img src="https://i.loli.net/2021/10/27/kRl7ziJQeTKBoCY.png" alt="image.png"></p><p>​13.DHCPRelease消息的目的是什么？ DHCP 服务器是否确认收到客户的 DHCP 请求？ 如果客户的 DHCP 发布消息丢失，会发生什么情况？<br>​<strong>告诉DHCP我要离开，DHCP收到消息后可以把分配出去的资源给回收并重新分配如果丢失的话那么DHCP分配的资源可能需要等到租赁到期的时候才能收获。</strong></p><p>​14.从您的 Wireshark窗口清除引导过滤器。在DHCP数据包交换期间是否发送或接收了 ARP 数据包？如果是这样，解释这些 ARP 包的目的。<br>​<strong>需要MAC地址DHCP服务器在接受到广播Discover时，如果满足就需要回应，同样需要MAC之后在我们得到了IP地址后同一子网的ARP就会记录我们的IP对应的MAC，ARP就广播给这个子网中的所有主机告诉我们的IP所用的MAC地址。</strong></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验八&quot;&gt;&lt;a href=&quot;#实验八&quot; class=&quot;headerlink&quot; title=&quot;实验八&quot;&gt;&lt;/a&gt;实验八&lt;/h1&gt;&lt;h2 id=&quot;dhcp-实验&quot;&gt;&lt;a href=&quot;#DHCP-实验&quot; class=&quot;headerlink&quot; title=&quot;DHCP 实验</summary>
      
    
    
    
    <category term="Wireshark" scheme="http://dezeem.github.io/categories/Wireshark/"/>
    
    
    <category term="计网" scheme="http://dezeem.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>NAT</title>
    <link href="http://dezeem.github.io/2021/10/27/2021-10-21-7/"/>
    <id>http://dezeem.github.io/2021/10/27/2021-10-21-7/</id>
    <published>2021-10-27T14:48:00.000Z</published>
    <updated>2024-05-08T13:03:31.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验七"><a href="#实验七" class="headerlink" title="实验七"></a>实验七</h1><p>​这个Lab由于我们不好捕捉包 所以我们需要下载别人给的捕获包<a href="http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip">http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip</a></p><p>​要用到的是NAT_home_side NAT_ISP_side</p><p>​一个是在客户机上捕获的一个是由路由器发送到ISP的包，我们<strong>先打开NAT_home_side 客户机的Wireshark文件</strong></p><p>​1.客户的 IP 地址是什么？</p><p>​<strong>192.168.1.100</strong></p><p>​客户端实际上与几个不同的 Google 服务器进行通信，以便实现”安全浏览”。 将服务于谷歌主网页的谷歌主服务器IP地址为 64.233.169.104。 在显示过滤器输入表达”http +ip.addr &#x3D;&#x3D; 64.233.169.104”：</p><p><img src="https://i.loli.net/2021/10/27/7fEQjrVywGmWUYR.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/10/27/Fx84I9VN3T6mQ5f.png" alt="image.png"></p><p>​2.现在考虑 HTTP GET 从客户端发送到 Google 服务器（其 IP 地址为 IP 地址 64.233.169.104），时间 7.109267。 携带此 HTTP GET 的 IP 数据图上的源和目的地 IP 地址以及 TCP 源和目的地端口是什么？</p><ul><li><p>​客户机<strong>Source IP 192.168.1.100 Des IP 64.233.169.104 TCP 端口4335 Dst Port 80</strong></p></li><li><p>​路由器端<strong>Source IP 71.192.34.104 Des IP 64.233.169.104 TCP 端口4335 Dst Port 80</strong></p></li></ul><p>​3.在什么时间收到相应的 200 OK HTTP 消息 from 谷歌服务器？ 携带此 HTTP 200 OK 消息的 IP 数据图上的源和目的地 IP 地址以及 TCP 源和目的地端口是什么？</p><ul><li><p>​时间7.158</p></li><li><p>​客户机    Source IP 64.233.169.104 Des IP 192.168.1.100 TCP 端口4335 Dst Port 80<br>​路由器端    Source IP 64.233.169.104 Des IP 71.192.34.104 TCP 端口4335 Dst Port 80</p></li></ul><p>​4.请记住，在 GET 命令发送到 HTTP 服务器之前，TCP 必须首先使用三向 SYN&#x2F;ACK 握手设置连接。 在什么时间发送的客户端到服务器 TCP SYN 段，该段设置 GET 在 7.109267 时发送的连接？ TCP SYN 段的源和目的地 IP 地址以及源和目的地端口是什么？ ACK 的源和目的地 IP 地址以及响应 SYN 发送的源和目的地端口是什么？ 此 ACK 在客户端收到的时间是哪个时间？</p><ul><li><p>​7.158s</p></li><li><p>​客户机Source IP 64.233.169.104 Des IP 192.168.1.100 TCP 端口4335 Dst Port 80<br>​路由器端Source IP 64.233.169.104 Des IP 71.192.34.104 TCP 端口4335 Dst Port 80</p></li><li><p>​6.117s</p></li></ul><hr><p>​1.在NAT_ISP_side跟踪文件中，找到 HTTP GET 消息是从客户端发送到 Google 服务器的时间 7.109267（其中 t&#x3D;7.109267 是将此发送的时间记录在 NAT_home_side跟踪文件中）。 此消息在什么时间出现在NAT_ISP_side跟踪文件中？ 携带此 HTTP GET 的 IP 数据图上的源和目的地 IP 地址以及 TCP 源和目的地端口（如NAT_ISP_side跟踪文件中的记录）是什么？ 这些字段中哪些领域相同，哪些领域与您对上述问题 3 的回答不同？<br>​<strong>这些在上面对比的时已经写出，基本一样。</strong></p><p>​2.HTTP 获取消息中的任何字段是否已更改？携带 HTTP GET 的 IP 数据图中的哪些字段已更改：版本、头长度、标志、检查表。 如果这些字段中的任何一个已更改，给出一个理由（在一句话中）说明该字段需要更改的原因。<br>​<strong>checksum改变,因为源地址发生了改变。</strong></p><p>​3.在NAT_ISP_side跟踪文件中，从 Google 服务器收到的第一个 200 个 OK HTTP 消息在什么时间？ 携带此 HTTP 200 OK 消息的 IP 数据图上的源和目的地 IP 地址以及 TCP 源和目的地端口是什么？<br>​<strong>一样,除了目的地址</strong></p><p>​4.在NAT_ISP_side跟踪文件中，客户端到服务器 TCP SYN 段和服务器对客户端 TCP ACK 段在什么时间与上述 5 个问题段对应？这两个细分市场的源和目的地 IP 地址以及来源和目的地端口是什么？<br>​<strong>一样同上</strong></p><p>​3.使用您对上面 1-8 的答案，填写上述问题 1-8 中考虑的 HTTP 连接的 NAT 翻译表条目。<br>​<strong>一个是内网地址，一个是外网地址</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验七&quot;&gt;&lt;a href=&quot;#实验七&quot; class=&quot;headerlink&quot; title=&quot;实验七&quot;&gt;&lt;/a&gt;实验七&lt;/h1&gt;&lt;p&gt;​		这个Lab由于我们不好捕捉包 所以我们需要下载别人给的捕获包&lt;a href=&quot;http://gaia.cs.umass.edu</summary>
      
    
    
    
    <category term="Wireshark" scheme="http://dezeem.github.io/categories/Wireshark/"/>
    
    
    <category term="计网" scheme="http://dezeem.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>IP</title>
    <link href="http://dezeem.github.io/2021/10/26/2021-10-21-6/"/>
    <id>http://dezeem.github.io/2021/10/26/2021-10-21-6/</id>
    <published>2021-10-26T14:52:13.000Z</published>
    <updated>2024-05-08T13:03:18.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验六"><a href="#实验六" class="headerlink" title="实验六"></a>实验六</h1><p>​IP 是整个 TCP&#x2F;IP 协议族的核心，也是构成互联网的基础。IP 位于 TCP&#x2F;IP 模型的网络层(相当于OSI模型的网络层)，对上可载送传输层各种协议的信息，例如 TCP、UDP 等；对下可将 IP 信息包放到链路层，通过以太网、令牌环网络等各种技术来传送。为了能适应异构网络，IP 强调适应性、简洁性和可操作性，并在可靠性做了一定的牺牲。IP 不保证分组的交付时限和可靠性，所传送分组有可能出现丢失、重复、延迟或乱序等问题。——百度百科</p><hr><h2 id="1从执行跟踪路线中捕获数据包"><a href="#1-从执行跟踪路线中捕获数据包" class="headerlink" title="1.从执行跟踪路线中捕获数据包"></a>1.从执行跟踪路线中捕获数据包</h2><ul><li>​打开wireshark捕获，</li><li>​设置一下pingplotter 首先是interval设置为10s 然后我们在输入框输入gaia.cs.umass.edu，</li><li>​每次点击之后刷新完了暂停之后去包那里设置packet size为2000 再次点击开始即重新发送reset再暂停再设置为3500再次开始等线再次刷新完了就暂停去把wireshark的捕获暂停下面是我的pingplotter 和 wireshark的捕获截图</li></ul><p><img src="https://i.loli.net/2021/10/26/irbCqRUZyvkmKh5.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/10/26/SuwKhjrD6g8kJBc.png" alt="image.png"></p><h2 id="2查看捕获的痕迹"><a href="#2-查看捕获的痕迹" class="headerlink" title="2.查看捕获的痕迹"></a>2.查看捕获的痕迹</h2><p>​1.选择发送的第一个 ICMP Echo Request 消息，然后在 packet details window 中展开数据包的 Internet 协议部分。您的计算机的 IP 地址是多少？</p><p>​<strong>source &#x3D; 192.168.31.1</strong></p><p>​2.在 IP header中，上层协议字段中值是什么？ </p><p>​<strong>上层协议字段中值是 1</strong></p><p>​3.IP header 有多少 bytes？ IP datagram 的有效负载中有多少 bytes？<br>​<strong>IP header 20 bytes，数据报一共有 56 bytes，因此有效负载中有 36 bytes。</strong></p><p>​4.此 IP 数据报是否已被分段(fragmented)？</p><p>​<strong>应该没有，因为第一个包的 TTL 是 255，如果被分段就会出现多个 TTL 为 255 的包，可是没发现，所以没分段。</strong></p><p>​5.查看第一个 ICMP 及其所有后续 ICMP 消息。</p><p><img src="https://i.loli.net/2021/10/26/kecVQHu8w1yYti3.png" alt="image.png"></p><p>​6.在您的计算器发送的这一系列 ICMP 消息中，IP 数据报中的哪些字段一直改变？</p><p>​<img src="https://i.loli.net/2021/10/26/E9Ldmnk6lzN2gWD.png" alt="image.png"></p><p>​<img src="https://i.loli.net/2021/10/26/WxN4MQi78z1DwhI.png" alt="image.png"></p><p>​<strong>标识符（Identification）、存活时间（Time To Live，TTL）、首部检验和 （Header Checksum）一直在变。</strong></p><p>​7.哪些字段保持不变？哪个字段必须保持不变？哪些字段必须更改？</p><ul><li><p>ID 字段和 TTL 字段的值是多少？</p><p><strong>ID是27749,TTL是1</strong></p></li><li><p>对于第一跳路由器发送到您的计算器的所有 ICMP TTL 超出的回复，这些值是否保持不变？为什么？</p></li><li><p>在将 pingplotter 中的数据包大小更改为 2000 后，查找计算机发送的第一个 ICMP Echo Request 消息。该消息是否已碎片化为多个 IP 数据报？</p><p><img src="https://i.loli.net/2021/10/26/PrtUQVJzCuwdTk8.png" alt="image.png"></p><p><strong>可以看出该消息被碎片化为 2 个 IP 数据报</strong>。</p></li><li><p>IP 数据报的第一个片段。 IP 头中的哪些信息表明数据报已碎片化？ IP 头中的哪些信息表明这是第一个片段还是后一个片段？ 这个 IP 数据报有多长？</p><p><img src="https://i.loli.net/2021/10/26/6HYdApJXgNyL2Kn.png" alt="image.png"></p><p><strong>More fragments字段为 1 表示 Set，即该数据包被分片。通过 ID 字段判断这是第一个片段，分片长度为 1480 bytes。</strong></p></li><li><p>找到碎片 IP 数据报的第二个片段。 IP 标头中的哪些信息表明这不是第一个数据报片段？ 是否还有更多的片段？你是如何知道的？</p><p><img src="https://i.loli.net/2021/10/26/Er3J4czQTbNFHki.png" alt="image.png"></p></li><li><p>在第一个和第二个片段中，IP 标头中哪些字段发生了变化？</p><p><strong>分片偏移 （Fragment Offset）</strong></p></li><li><p>从原始数据报创建了多少个片段？</p><p><img src="https://i.loli.net/2021/10/26/B8u5QNlGKXFTHft.png" alt="image.png"></p><p>​<strong>创建了三个片段</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验六&quot;&gt;&lt;a href=&quot;#实验六&quot; class=&quot;headerlink&quot; title=&quot;实验六&quot;&gt;&lt;/a&gt;实验六&lt;/h1&gt;&lt;p&gt;​		IP 是整个 TCP&amp;#x2F;IP 协议族的核心，也是构成互联网的基础。IP 位于 TCP&amp;#x2F;IP 模型的网络层(相</summary>
      
    
    
    
    <category term="Wireshark" scheme="http://dezeem.github.io/categories/Wireshark/"/>
    
    
    <category term="计网" scheme="http://dezeem.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>UDP</title>
    <link href="http://dezeem.github.io/2021/10/26/2021-10-21-5/"/>
    <id>http://dezeem.github.io/2021/10/26/2021-10-21-5/</id>
    <published>2021-10-26T12:52:13.000Z</published>
    <updated>2024-05-08T13:02:58.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h1><p>​UDP是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。——百度百科</p><p>​1.在 Wireshark 中捕获数据包，然后执行一些会导致主机发送和接收多个 UDP 数据包的操作。（运行python代码发送UDP数据包）</p><p>​2.停止数据包捕获后，设置数据包筛选器，以便 Wireshark 仅显示在主机上发送和接收的 UDP 数据包。 选择其中一个 UDP 数据包并在详细信息窗口中展开 UDP 字段。</p><p>​<img src="https://i.loli.net/2021/10/26/tiCywXKFIuGcYoe.png" alt="image.png"></p><p>​从跟踪中选择一个 UDP 数据包：</p><p>​<strong>UDP 的标头有 4 个字段，一共 7 byte，各字段分别为：</strong></p><p>​<strong>Source Port：源端口号</strong><br><strong>​Destination Port：目的端口号</strong><br><strong>​Length：长度</strong><br><strong>​Checksum：校验和</strong></p><p>​通过查询 Wireshark 的数据包内容字段中显示的信息，UDP 报头字段的长度。<strong>UDP 报头为 8 byte &#x3D; 64 bit。</strong></p><p>​长度字段指示了在 UDP 报文段中的字节数(首部 + 数据)，这是因为数据字段的长度在一个 UDP 段中不同于在另一个段中，因此需要一个明确的长度。如图，报文的长度是 7 byte，加上首部的 8 byte 为 15 byte 刚好是 Length 字段的长度。</p><p>​UDP 有效负载中可包含的最大字节数是多少？</p><p>​简单地说，有效负载就是可变长度的数据部分。由于Length 字段占 2byte &#x3D; 65535 bit，并且其中 8 byte 是 UDP 首部信息。因此有效载荷 &#x3D; 65535 - 8 &#x3D; 65527 bit。</p><p>​最大可能的源端口号是65534。</p><p>​UDP 的协议号是什么？ 以十六进制和十进制表示法给出答案。</p><p>​<img src="https://i.loli.net/2021/10/26/oEy1WwcSvBbfXzd.png" alt="image.png"></p><p>​<strong>UDP 的协议号为 17，十六进制为 0x11。</strong></p><p>​检查主机发送第一个UDP包的一对UDP数据包，第二个UDP数据包是该第一个UDP数据包的回复。（提示：要发送第二个数据包以响应第一个数据包，第一个数据包的发送者应是第二个数据包的目的地）。 描述两个数据包中的端口编号之间的关系。</p><p>​<strong>发送过去的 源端口号 之后就变成了回应时的目的端口号</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实验五&quot;&gt;&lt;a href=&quot;#实验五&quot; class=&quot;headerlink&quot; title=&quot;实验五&quot;&gt;&lt;/a&gt;实验五&lt;/h1&gt;&lt;p&gt;​		UDP是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Int</summary>
      
    
    
    
    <category term="Wireshark" scheme="http://dezeem.github.io/categories/Wireshark/"/>
    
    
    <category term="计网" scheme="http://dezeem.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
</feed>
