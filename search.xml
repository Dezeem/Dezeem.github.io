<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Getting Started</title>
    <url>/2021/10/22/2021-10-21-1/</url>
    <content><![CDATA[ 实验一
✨更新于2022-10-28
 概述
数据包嗅探结构

 Wireshark

Wireshark是由一个国际网络专家团队开发的网络协议分析工具

 实验内容
​		下载并安装好Wireshark，打开软件选择WLAN，启动数据嗅探：
​		然后访问指定网站如下：
​		http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html

​		显示内容如上图所示
​		显示过滤器中输入http，得到HTTP协议的数据传输信息：

​		source 为请求方——本地ip地址
​		Destination 为接收方——服务器ip地址

​		展开可查看详细信息
​		HTTP版本为1.1
​		返回200 OK，请求成功。
OVER
]]></content>
      <categories>
        <category>Wireshark</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>802.11 WIFI</title>
    <url>/2021/10/30/2021-10-21-11/</url>
    <content><![CDATA[ 实验十一
 信标框架
​		


发出此跟踪中大多数信标帧的两个接入点的SSID是什么？
分别为30 Munroe st   linksys12这两个SSID


从linksys_ses_24086接入点发送信标帧之间的时间间隔是多少？
时间间隔0.102400s beacon Interval处可见


Munroe街30号信标帧上的源MAC地址是什么（十六进制表示法）？回想一下本文中的图7.13，源、目标和BSS是802.11帧中使用的三个地址。

00:16:b6:f7:1d:51


4.Munroe街30号信标帧上的目标MAC地址是什么（十六进制表示法）？
​	广播帧ff:ff:ff:ff:ff:ff
5.Munroe街30号信标帧上的MAC BSS id是什么（十六进制表示法）？
BSS id 还是00:16:b6:f7:1d:51
6.来自30 Munroe St接入点的信标帧表明接入点可以支持四种数据速率和八种额外的“扩展支持速率”。这些速率是多少？
​	1B 2B 5.5B 11B
​	6B 9B 12B 18B 24B 36B 48B 54B
 数据传输
1.查找包含此第一个TCP会话（下载alice.txt）的SYN TCP段的802.11帧。802.11帧中有哪三个MAC地址字段？此帧中的哪个MAC地址对应于无线主机（给出主机MAC地址的十六进制表示）？到接入点？到第一跳路由器？发送此TCP段的无线主机的IP地址是什么？目标IP地址是什么？此目标IP地址是否对应于主机、接入点、第一跳路由器或其他网络连接设备？解释一下。
主机所在的地址为中间的 00:13:02:d1:b6:4f
AP的MAC地址为第一条00:16:b6:f7:1d:51
路由器的MAC地址为最后一条00:16:b6:f4:eb:a8
目标IP地址为第一条路由器

2.查找包含此TCP会话的SYNACK段的802.11帧。802.11帧中有哪三个MAC地址字段？此帧中的哪个MAC地址对应于主机？到接入点？到第一跳路由器？帧中的发送方MAC地址是否与发送此数据报中封装的TCP段的设备的IP地址相对应？
 协会/脱离关系
1.在t=49之后，主机在跟踪中采取了哪两个操作（即发送帧），以结束与30 Munroe St AP的关联，该AP最初在跟踪收集开始时处于适当位置？
这两条 一个是IP层 DHCP 主动Release 一个是802.11层 向我们的AP发出解除关联
2.检查跟踪文件并查找从主机发送到AP的身份验证帧，反之亦然。从t=49开始，从无线主机向linksys_ses_24086 AP（MAC地址为Cisco_Li_f5:ba:bb）发送多少验证消息。
15条
3.主机希望身份验证需要密钥还是打开？
​		希望打开
4.您是否在跟踪中看到来自linksys_ses_24086 AP的回复身份验证？
没有
]]></content>
      <categories>
        <category>Wireshark</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL</title>
    <url>/2021/10/30/2021-10-21-12/</url>
    <content><![CDATA[ 实验十二
​		
1.对于前 8个以太网帧，请分别指出每一个帧的来源（客户端和服务器），确定每个帧包含的SSL记录的数量，并且列出包含SSL记录的类型。绘制客户端和服务器含有箭头指向的时序图。

2.每个 SSL记录都以相同的三个字段（可能具有不同的值）开头。 其中一个 字段是“内容类型”，长度为一个字节。 请列出所有三个字段及其长度。
​		
​		Content Type字段为1字节，Version字段为2字节，Length字段为2字节:
3.展开 ClientHello记录（如果您的跟踪包含多个 ClientHello记录，请展开包 含第一个记录的以太网帧），内容类型的值是多少？
​		Content Type: Handshake(22)
4.ClientHello记录是否包含随机数（也称为“挑战码”（ challenge））？ 如果是 这样，十六进制的挑战码值是多少？
​		包含
5.ClientHello记录是否通知了它所支持密码加密套件（suite）？如果是这样， 请在第一个密码套件， 分别指出非对称密钥加密算法，对称密钥加密算法，哈希算法分别都是什么？（待补充）
​		
6.找到 ServerHello SSL记录。 此记录是否指定了之前的密码套件之一？ 选择的密码套件中有哪些算法？
​		
​		指定了哈希加密算法（SHA哈希函数）
7.此记录是否包含随机数？如果有，它有多长？SSL中客户端和服务器段随机数用来干什么？
​		包含，有32字节，也就是用64个16进制数来表示。多次随机数生成为未来生成对话密钥提高安全性能。
8.此记录是否包含会话 ID？ 会话 ID的目的是什么？
​		包含（有的可能不会包含，也就是可以有也可以没有）
​		目的：用一定时间内端口连接快速恢复连接过程。
9.此记录是否包含证书，或者证书是否包含在单独的记录中。 证书是否适合一个单独的以太网帧传输？
10.找到客户端密钥交换记录。 此记录是否包含前主密钥(pre-master secret)？ 这个前主密钥用于什么？ 前主密钥加密了吗？ 如果是这样，为什么？ 加密的前主密钥有多长？
​		1）包含
​		3）使用EC Diffie-Hellman（ECDH加密算法）进行加密传输，使用的是服务器公钥加密，用以给服务器让服务器用私钥解密并且使用前面两个hello过程的随机数生成本次的会话加密密钥。
​		4）32个字节
11.编码改变记录目的是什么？在您的跟踪中本记录有多少字节？
​		告诉服务器已经计算好加密密钥，以后将会用商定的加密方式和密钥加密传输了，在我的跟踪中该记录有6个字节。
12.在加密的握手记录中，什么是加密的？ 为什么？
​		消息校验码是加密的，这个校验码是包含之前所有连接消息的摘要加密格式，只有服务器可以解开，因为在建立连接中，存在可能连接消息被侦听和更改的情况，因此还需要进行信息摘要计算和加密传输，判断是否存在异常，如果异常，将会直接关闭连接。
13.服务器是否还向客户端发送更改编码记录和加密的握手记录？ 这些记录与客户发送的记录有何不同？
14.如何加密应用程序数据？ 包含应用程序数据的记录是否包含消息认证码 MAC？ Wireshark是否区分加密的应用程序数据和消息认证码 MAC？
​		
​		使用本次对话协商和交换好对称加密密钥应用程序数据，这个数据里同时包括消息本身和消息认证码，所以比消息本身要长，但是加密过，所以无法区分。
]]></content>
      <categories>
        <category>Wireshark</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP</title>
    <url>/2021/10/26/2021-10-21-5/</url>
    <content><![CDATA[ 实验五
​		UDP是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。——百度百科
​		1.在 Wireshark 中捕获数据包，然后执行一些会导致主机发送和接收多个 UDP 数据包的操作。（运行python代码发送UDP数据包）
​		2.停止数据包捕获后，设置数据包筛选器，以便 Wireshark 仅显示在主机上发送和接收的 UDP 数据包。 选择其中一个 UDP 数据包并在详细信息窗口中展开 UDP 字段。
​		
​		从跟踪中选择一个 UDP 数据包：
​		UDP 的标头有 4 个字段，一共 7 byte，各字段分别为：
​		Source Port：源端口号
​		Destination Port：目的端口号
​		Length：长度
​		Checksum：校验和
​		通过查询 Wireshark 的数据包内容字段中显示的信息，UDP 报头字段的长度。UDP 报头为 8 byte = 64 bit。
​		长度字段指示了在 UDP 报文段中的字节数(首部 + 数据)，这是因为数据字段的长度在一个 UDP 段中不同于在另一个段中，因此需要一个明确的长度。如图，报文的长度是 7 byte，加上首部的 8 byte 为 15 byte 刚好是 Length 字段的长度。
​		UDP 有效负载中可包含的最大字节数是多少？
​		简单地说，有效负载就是可变长度的数据部分。由于Length 字段占 2byte = 65535 bit，并且其中 8 byte 是 UDP 首部信息。因此有效载荷 = 65535 - 8 = 65527 bit。
​		最大可能的源端口号是65534。
​		UDP 的协议号是什么？ 以十六进制和十进制表示法给出答案。
​		
​		UDP 的协议号为 17，十六进制为 0x11。
​		检查主机发送第一个UDP包的一对UDP数据包，第二个UDP数据包是该第一个UDP数据包的回复。（提示：要发送第二个数据包以响应第一个数据包，第一个数据包的发送者应是第二个数据包的目的地）。 描述两个数据包中的端口编号之间的关系。
​		发送过去的 源端口号 之后就变成了回应时的目的端口号
]]></content>
      <categories>
        <category>Wireshark</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>IP</title>
    <url>/2021/10/26/2021-10-21-6/</url>
    <content><![CDATA[ 实验六
​		IP 是整个 TCP/IP 协议族的核心，也是构成互联网的基础。IP 位于 TCP/IP 模型的网络层(相当于OSI模型的网络层)，对上可载送传输层各种协议的信息，例如 TCP、UDP 等；对下可将 IP 信息包放到链路层，通过以太网、令牌环网络等各种技术来传送。为了能适应异构网络，IP 强调适应性、简洁性和可操作性，并在可靠性做了一定的牺牲。IP 不保证分组的交付时限和可靠性，所传送分组有可能出现丢失、重复、延迟或乱序等问题。——百度百科

 1.从执行跟踪路线中捕获数据包

​		打开wireshark捕获，
​		设置一下pingplotter 首先是interval设置为10s 然后我们在输入框输入gaia.cs.umass.edu，
​		每次点击之后刷新完了暂停之后去包那里设置packet size为2000 再次点击开始即重新发送reset再暂停再设置为3500再次开始等线再次刷新完了就暂停去把wireshark的捕获暂停下面是我的pingplotter 和 wireshark的捕获截图



 2.查看捕获的痕迹
​		1.选择发送的第一个 ICMP Echo Request 消息，然后在 packet details window 中展开数据包的 Internet 协议部分。您的计算机的 IP 地址是多少？
​		source = 192.168.31.1
​		2.在 IP header中，上层协议字段中值是什么？
​		上层协议字段中值是 1
​		3.IP header 有多少 bytes？ IP datagram 的有效负载中有多少 bytes？
​		IP header 20 bytes，数据报一共有 56 bytes，因此有效负载中有 36 bytes。
​		4.此 IP 数据报是否已被分段(fragmented)？
​		应该没有，因为第一个包的 TTL 是 255，如果被分段就会出现多个 TTL 为 255 的包，可是没发现，所以没分段。
​		5.查看第一个 ICMP 及其所有后续 ICMP 消息。

​		6.在您的计算器发送的这一系列 ICMP 消息中，IP 数据报中的哪些字段一直改变？
​		
​		
​		标识符（Identification）、存活时间（Time To Live，TTL）、首部检验和 （Header Checksum）一直在变。
​		7.哪些字段保持不变？哪个字段必须保持不变？哪些字段必须更改？


ID 字段和 TTL 字段的值是多少？
ID是27749,TTL是1


对于第一跳路由器发送到您的计算器的所有 ICMP TTL 超出的回复，这些值是否保持不变？为什么？


在将 pingplotter 中的数据包大小更改为 2000 后，查找计算机发送的第一个 ICMP Echo Request 消息。该消息是否已碎片化为多个 IP 数据报？

可以看出该消息被碎片化为 2 个 IP 数据报。


IP 数据报的第一个片段。 IP 头中的哪些信息表明数据报已碎片化？ IP 头中的哪些信息表明这是第一个片段还是后一个片段？ 这个 IP 数据报有多长？

More fragments字段为 1 表示 Set，即该数据包被分片。通过 ID 字段判断这是第一个片段，分片长度为 1480 bytes。


找到碎片 IP 数据报的第二个片段。 IP 标头中的哪些信息表明这不是第一个数据报片段？ 是否还有更多的片段？你是如何知道的？



在第一个和第二个片段中，IP 标头中哪些字段发生了变化？
分片偏移 （Fragment Offset）


从原始数据报创建了多少个片段？

​	创建了三个片段


]]></content>
      <categories>
        <category>Wireshark</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>NAT</title>
    <url>/2021/10/27/2021-10-21-7/</url>
    <content><![CDATA[ 实验七
​		这个Lab由于我们不好捕捉包 所以我们需要下载别人给的捕获包http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip
​		要用到的是NAT_home_side NAT_ISP_side
​		一个是在客户机上捕获的一个是由路由器发送到ISP的包，我们先打开NAT_home_side 客户机的Wireshark文件
​		1.	客户的 IP 地址是什么？
​		192.168.1.100
​		客户端实际上与几个不同的 Google 服务器进行通信，以便实现&quot;安全浏览&quot;。 将服务于谷歌主网页的谷歌主服务器IP地址为 64.233.169.104。 在显示过滤器输入表达&quot;http +ip.addr == 64.233.169.104&quot;：


​		2.现在考虑 HTTP GET 从客户端发送到 Google 服务器（其 IP 地址为 IP 地址 64.233.169.104），时间 7.109267。 携带此 HTTP GET 的 IP 数据图上的源和目的地 IP 地址以及 TCP 源和目的地端口是什么？


​		客户机	Source IP 192.168.1.100 Des IP 64.233.169.104 TCP 端口4335 Dst Port 80


​		路由器端	Source IP 71.192.34.104 Des IP 64.233.169.104 TCP 端口4335 Dst Port 80


​		3.在什么时间收到相应的 200 OK HTTP 消息 from 谷歌服务器？ 携带此 HTTP 200 OK 消息的 IP 数据图上的源和目的地 IP 地址以及 TCP 源和目的地端口是什么？


​		时间	7.158


​		客户机    Source IP 64.233.169.104 Des IP 192.168.1.100 TCP 端口4335 Dst Port 80
​		路由器端    Source IP 64.233.169.104 Des IP 71.192.34.104 TCP 端口4335 Dst Port 80


​		4.请记住，在 GET 命令发送到 HTTP 服务器之前，TCP 必须首先使用三向 SYN/ACK 握手设置连接。 在什么时间发送的客户端到服务器 TCP SYN 段，该段设置 GET 在 7.109267 时发送的连接？ TCP SYN 段的源和目的地 IP 地址以及源和目的地端口是什么？ ACK 的源和目的地 IP 地址以及响应 SYN 发送的源和目的地端口是什么？ 此 ACK 在客户端收到的时间是哪个时间？


​		7.158s


​		客户机	Source IP 64.233.169.104 Des IP 192.168.1.100 TCP 端口4335 Dst Port 80
​		路由器端	Source IP 64.233.169.104 Des IP 71.192.34.104 TCP 端口4335 Dst Port 80


​		6.117s



​		1.在NAT_ISP_side跟踪文件中，找到 HTTP GET 消息是从客户端发送到 Google 服务器的时间 7.109267（其中 t=7.109267 是将此发送的时间记录在 NAT_home_side跟踪文件中）。 此消息在什么时间出现在NAT_ISP_side跟踪文件中？ 携带此 HTTP GET 的 IP 数据图上的源和目的地 IP 地址以及 TCP 源和目的地端口（如NAT_ISP_side跟踪文件中的记录）是什么？ 这些字段中哪些领域相同，哪些领域与您对上述问题 3 的回答不同？
​		这些在上面对比的时已经写出，基本一样。
​		2.HTTP 获取消息中的任何字段是否已更改？携带 HTTP GET 的 IP 数据图中的哪些字段已更改：版本、头长度、标志、检查表。 如果这些字段中的任何一个已更改，给出一个理由（在一句话中）说明该字段需要更改的原因。
​		checksum改变,因为源地址发生了改变。
​		3.在NAT_ISP_side跟踪文件中，从 Google 服务器收到的第一个 200 个 OK HTTP 消息在什么时间？ 携带此 HTTP 200 OK 消息的 IP 数据图上的源和目的地 IP 地址以及 TCP 源和目的地端口是什么？
​		一样,除了目的地址
​		4.在NAT_ISP_side跟踪文件中，客户端到服务器 TCP SYN 段和服务器对客户端 TCP ACK 段在什么时间与上述 5 个问题段对应？这两个细分市场的源和目的地 IP 地址以及来源和目的地端口是什么？
​		一样同上
​		3.使用您对上面 1-8 的答案，填写上述问题 1-8 中考虑的 HTTP 连接的 NAT 翻译表条目。
​		一个是内网地址，一个是外网地址
]]></content>
      <categories>
        <category>Wireshark</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>DHCP</title>
    <url>/2021/10/28/2021-10-21-8/</url>
    <content><![CDATA[ 实验八
 DHCP 实验


打开cmd，输入ipconfig/release


启动嗅探器并开始捕获。


cmd输入ipconfig/renew


再输入ipconfig/release


再输入ipconfig/renew


停止捕获
​				
​		1.DHCP 消息是否通过 UDP 或 TCP 发送？
​		UDP
​		2.绘制时间数据图，说明客户端和服务器之间第一个四包发现/提供/请求/ACK DHCP 交换的顺序。对于每个数据包，指示源和目的地端口编号。端口编号与此实验室作业中给出的示例相同吗？
Offer/Request/ACK/release/Discover
​		3.主机的链接层（例如以太网）地址是什么？WIFI无法查看
​		4.DHCP 发现消息中的哪些值将此消息与 DHCP 请求消息区分开来？
​		
​		Type
​		5.前四条（发现/提供/请求/ACK）DHCP 消息中每个邮件中的交易 ID 值是怎样的？ 第二组 （请求/ACK） DHCP 消息中的交易 ID 值是哪些？ 交易 ID 字段的目的是什么？
​		用于确认是哪条请求 类似于TCP IP的序列号
​		6.主机使用 DHCP 获取 IP 地址，除其他外。但主机的 IP 地址直到四消息交换结束才得到确认！ 如果 IP 地址直到四消息交换结束才设置，那么在四消息交换中的 IP 数据图中使用了哪些值？ 对于四个 DHCP 消息（发现/提供/请求/ACK DHCP），指示封装 IP 数据图中携带的源和目的地 IP 地址。
​		7.您的 DHCP 服务器的 IP 地址是哪个？
​		192.168.254.254
​		8.DHCP 服务器在DHCPoffer消息中向主机提供什么IP地址？指示哪个DHCP消息包含提供的 DHCP 地址。
​		
​		9.在此任务中的示例屏幕截图中，主机和 DHCP 服务器之间没有继电器。跟踪中的哪些值表示缺少继电器？ 你的实验中是否有Agent？如果是，代理的 IP 地址是什么？
​		没有Agent
​		10.解释 DHCP 提供消息中路由器和子网掩码的目的。
​		首先告诉路由器IP是因为我们之后得到了路由器IP以后发送一些请求的时候就向我们的路由器发送了等于起到了中间代理的作用
​		告诉我们子网掩码 是告诉我们当前我们获取子网的大小 告诉我们更多的信息便于以后配置。
​		11.在脚注 2 中注明的 DHCP 跟踪文件中，DHCP 服务器向客户端提供了特定的 IP 地址（参见上面的第 8 个问题）。 在客户对第一个服务器 OFFER 消息的响应中，客户端是否接受此 IP 地址？ 客户请求的地址在客户响应中的位置？
​		接受了IP地址因为发出的Request请求我们请求的IP就是DHCP申请出来的OFFE的那个IP如下图客户端的IP地址请求在选项字段
​		
​
​		12.解释租赁时间的目的。实验中的租赁时间有多长？
​		因为DHCP服务器分配是不永久分配的，都是临时分配的且是有时间的如果时间到期就需要重新申请或者续期如果没有重新租赁的话DHCP服务器即自动关闭与其的服务提供
​		实验中的话 即租赁时间为1个小时
​		
​		13.DHCPRelease消息的目的是什么？ DHCP 服务器是否确认收到客户的 DHCP 请求？ 如果客户的 DHCP 发布消息丢失，会发生什么情况？
​		告诉DHCP我要离开，DHCP收到消息后可以把分配出去的资源给回收并重新分配如果丢失的话那么DHCP分配的资源可能需要等到租赁到期的时候才能收获。
​		14.从您的 Wireshark窗口清除引导过滤器。在DHCP数据包交换期间是否发送或接收了 ARP 数据包？如果是这样，解释这些 ARP 包的目的。
​		需要MAC地址DHCP服务器在接受到广播Discover时，如果满足就需要回应，同样需要MAC之后在我们得到了IP地址后同一子网的ARP就会记录我们的IP对应的MAC，ARP就广播给这个子网中的所有主机告诉我们的IP所用的MAC地址。


]]></content>
      <categories>
        <category>Wireshark</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>ICMP</title>
    <url>/2021/10/30/2021-10-21-9/</url>
    <content><![CDATA[ 实验九
 Ping 程序


打开cmd


启动嗅探器，开始捕获


输入“ping –n 10 www.mit.edu”

​	主机上的 ping 程序发送了10 个查询包并收到了 10 响应对于每个响应，源计算往返时间（RTT），数据包平均为 343 毫秒。
4.Ping 程序终止时，停止在 Wireshark 中捕获数据包。		
​		数据包列表显示 20 个数据包，说明源发送的 10 个 Ping 查询和源接收的 10 个 Ping 响应。数据包内容区域可以查看此数据包的信息，该数据包中的 IP 数据报的协议号ICMP 的协议号 01，这表示 IP 数据报的有效载荷是 ICMP 数据包。
​		
​	
​	该 ICMP 包的详情信息，数据包包含校验和，标识符和序列号，该 ICMP 数据包是类型 8 和代码 0，也就是“回应请求”数据包。


源主机的 IP 地址是多少？目标主机的 IP 地址是多少？
源主机：192.168.31.79
目标主机：23.66.153.41


为什么 ICMP 数据包没有源端口号和目的端口号？
因为 ICMP 报文作为 IP 有效载荷承载的，不需要像 TCP 或 UDP 那样需要端口号。


查看任意的请求 ICMP 数据包，ICMP 类型和代码是什么？该 ICMP 数据包还有哪些其他字段？校验和，序列号和标识符字段有多少字节？
类型 8 和代码 0，也就是回应请求报文，还有校验和，序列号和标识符字段，都是 4 字节。


查看任意的响应 ICMP 数据包，ICMP 类型和代码是什么？该 ICMP 数据包还有哪些其他字段？校验和，序列号和标识符字段有多少字节？

类型 0 编码 0 是回显应答报文，还有校验和，序列号和标识符字段，都是 4 字节。
 Traceroute 命令


打开 cmd


启动嗅探器，并开始捕获


输入“tracert www.inria.fr”


tracert 程序终止时，停止在 Wireshark 中捕获数据包。


​		对于每个 TTL 值，源程序发送三个探测包。 Traceroute 显示每个探测包的 RTT，以及返回 ICMP TTL 超出消息的路由器的 IP 地址和名称。




您的主机的 IP 地址是多少？目标目标主机的 IP 地址是多少？
源主机：192.168.31.70
目标主机：128.93.162.83


如果 ICMP 发送了 UDP 数据包（如在 Unix / Linux 中），那么探测数据包的 IP 协议号仍然是 01 吗？ 如果没有，它会是什么？


检查屏幕截图中的 ICMP 响应数据包。这与本实验的前半部分中的 ICMP ping 查询数据包不同吗？如果不同，请解释为什么？

​		不同，这里的 ICMP 报文时TTL 报文(类型 11 编码 0)，这个是在 Traceroute 程序中，路由器检查到 Traceroute 发出的 IP 数据报中 TTL 正好过期，因此路由器就需要丢包并且发送该警告报文返回源主机。这个与 Ping 程序中所要达成的目的不同，Ping 程序是为了请求响应。
4.检查屏幕截图中的 ICMP 错误数据包。它具有比 ICMP 响应数据包更多的字段。这个数据包含哪些内容？
​		
​	比响应数据包多了 ICMP 请求数据包的内容。
5.检查源主机收到的最后三个 ICMP 数据包。这些数据包与 ICMP 错误数据包有何不同？他们为什么不同？
​		
​		这个是目的主机返回的回显应答报文，因为 tracert 程序的原理是发送 TTL 增加的数据包，当 TTL = 1 的包达到路由器，该路由器会将该包丢弃，并且发送 ICMP 错误给请求的机器。而最后一组 3 个数据报时可以到达目的主机的，这时由于是被目的主机接收，目的主机不会丢包，而是确确实实收到的这个探测的数据报并进行了响应。
6.在 tracert 跟踪测量中，是否有一个连接的延迟比其他连接长得多？是否有连接的延迟明显长于其他连接？根据路由器名称，您能猜出这个连接末端的两个路由器的位置吗？
​		在第 8 个节点时延突增，之后的节点时延都达到了 250+ ms。之后的路由器名都是英文名，且目的地是法国，那应该是连接到了亚洲转欧洲的分界路由器了。


]]></content>
      <categories>
        <category>Wireshark</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2021/10/22/2021-10-22-2/</url>
    <content><![CDATA[ 实验二
 基于HTTP获取/响应交互
​		1.启动浏览器，启动资源包嗅探器（尚未开始捕获），显示过滤http，等待一分多钟。
​		2.访问指定网站http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html，
​		显示如图：

​		3.停止嗅探，查看内容：

​		       
​		浏览器提交GET请求。
​		浏览器和服务器的HTTP版本均为1.1
​		浏览器的可接受服务器使用的语言如图所示：

​		我的本地IP地址为：192.168.215.71
​		服务器IP地址为：128.119.245.12
​		服务器返回状态代码为200 OK表示请求成功。
​		
​		可以看见Last-Modified行：Last-Modified: Fri, 22 Oct 2021 05:59:01 GMT\r\n，可以知道服务器检索上次修改的 HTML 文件的时间。
​		以及Content-Length: 128\r\n，可以知道有多少字节的内容被退回到的浏览器。
 GET/response交互
​		1.清空缓存，启动嗅探器，启动浏览器，访问指定网址，再刷新一次，显示如图。
​		
​		2.检查第一个从浏览器到服务器的GET请求，没有If-Modified-Since行
​		
​		3.查看服务器返回内容：

​		返回了一段HTML代码
​		4.检查第二个HTTP GET请求内容：

可见If-Modified-Since: Fri, 22 Oct 2021 05:59:01 GMT\r\n
5.第二次HTTP返回的状态代码是304 Not Modified，没有明确返回文件内容，因为该网页内容在上次访问之后未被修改过，且本地中有上次访问的缓存。
​		
 检索长文件
​		1.操作同上。
​		2.开始数据嗅探，访问指定网站后停止。

​		3.浏览器发送了一个GET请求消息，传输这一个HTTP响应需要4个TCP数据段。

​		4.响应HTTP GET请求的相关的状态码200和短语是OK。
 HTML 带有嵌入对象的文件
​		1.清除缓存，开始捕获，访问网站http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html
​		2.停止捕获，查看内容。
		浏览器发送了3个HTTP GET 请求，浏览器并不是同时下载这两张图片，有先后顺序。GET请求有两个发送给了 128.119.245.12，一个发送到了178.79.137.164。
 HTTP认证
​		1.清楚缓存，开始捕获，访问网站并登录。


未登录时服务器返回401 Unauthorized，登录成功返回200 OK。
当浏览器第二次发送 HTTP GET 消息时，HTTP GET 消息中包含Authorization，
响应消息出现了ETag字段。
​		输入的用户名和密码在客户端的 HTTP GET 消息中虽然可能看起来是加密的，但它们只是以称为 Base64 格式的格式进行编码。用户名和密码未加密！
]]></content>
      <categories>
        <category>Wireshark</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS</title>
    <url>/2021/10/24/2021-10-23-3/</url>
    <content><![CDATA[ 实验三
 什么DNS？
​		域名系统(Domain Name System,DNS)是Internet上解决网上机器命名的一种系统。采用域名系统来管理名字和IP的对应关系。域名可将一个IP地址关联到一组有意义的字符上去。用户访问一个网站的时候，既可以输入该网站的IP地址，也可以输入其域名，对访问而言，两者是等价的。例如：微软公司的Web服务器的IP地址是207.46.230.229，其对应的域名是www.microsoft.com，不管用户在浏览器中输入的是207.46.230.229还是www.microsoft.com，都可以访问其Web网站。
 nslookup
​		nslookup工具允许主机查询任何指定的 DNS 服务器的 DN S记录。DNS 服务器可以是根 DNS 服务器，顶级域 DNS 服务器，权威 DNS 服务器或中间 DNS 服务器。要完成此任务，nslookup 将 DNS 查询发送到指定的 DNS 服务器，然后接收 DNS 回复，并显示结果。
​		（1）现在测试打开cmd输入
nslookup www.baidu.com
​		
​		此命令的响应提供两条信息：
​		1.提供响应的DNS服务器的名称和 IP 地址；
​		2.响应本身，即 www.jmu.edu.cn 的主机名和 IP 地址。本地 DNS 服务器很可能会迭代地联系其他几个DNS服务器来获得结果。
​		（2）获取发送baidu.com的 DNS 主机名,打开cmd输入
nslookup -type=NS baidu.com
​		
​		通过添加选项 &quot;-type=NS &quot;和域名 “baidu.com”。命令的含义为 nslookup 将 NS 记录发送到默认的本地 DNS 服务器，转换为“人话”的含义为“获取发送baidu.com的权威 DNS 的主机名”，当不使用 -type 选项时，nslookup 将使用默认值，即查询 A 类记录。
​		来看看回显数据，首先是提供响应的 DNS 服务器，即默认本地 DNS 服务器。紧随其后是以及 5 个 MIT 域名服务器， nslookup 显示这些是非权威应答，表示着这个响应来自某个服务器的缓存，而不是来自权威 MIT DNS 服务器。
​		(3)接下来想试试不通过默认服务器，而是通过 DNS 服务器 bitsy.mit.edu 看看能不能成功解析百度官网。
​		
​		unknown
 实验
​		（1）获取一个亚洲Web服务器的IP地址，内容如上（百度的例子）
​		（2）运行nslookup 以确定欧洲一所大学的权威 DNS 服务器：
​		
​		查询到了剑桥大学DNS域名服务器
​		（3）运行 nslookup， 以便查询在问题 2 中获得的 DNS 服务器之一，以便查询雅虎邮件的邮件服务器。其 IP 地址是什么？
​			雅虎邮箱的域名为 “mail.yahoo.com”，选择服务器 “auth0.dns.cam.ac.uk” 来找。
​		
​		Unknown
​		简单查找：
​		
 ipconfig

​		IPConfig 实用程序和它的等价图形用户界面—— Windows 95/98 中的 WinIPCfg 可用于显示当前的 TCP/IP 配置的设置值。这些信息一般用来检验人工配置的 TCP/IP 设置是否正确。但是，如果你的计算机和所在的局域网使用了动态主机配置协议，这个程序所显示的信息也许更加实用。——百度百科

​		ipconfig 是主机中最实用的程序之一，调试网络问题时作用很大。ipconfig 可用于显示您当前的TCP/IP信息，包括您的地址，DNS服务器地址，适配器类型等。
ipconfig /all
​		主机可以缓存最近获得的 DNS 记录，使用 ipconfig 可以查看这些缓存记录：
ipconfig /displaydns
​		清除这些缓存，就需要使用这个指令：
ipconfig /flushdns
 使用 Wireshark 追踪 DNS
​		1.使用ipconfig清空主机中的DNS缓存。清空浏览器缓存。
​		2.打开 Wireshark，然后在过滤器中输入:
dns
​		

​		DNS查询和响应消息通过UDP发送
​		DNS查询消息的目的端口是53，DNS响应消息源端口是53
​		DNS查询消息发送到192.168.31.79，和我的本地DNS服务器的IP地址相同
​		DNS 查询的&quot;Type&quot;是A，没有任何“Answers”

​		
​		DNS响应消息提供了 2 个 “answers”，是该域名的 2 个 IPV4 地址。
​		
​		主机发送的后续 TCP SYN 数据包。SYN 数据包的目的地 IP 地址与 DNS 响应邮件中提供的 IP 地址是相对应的。
​		这个网页包含一些图片。在获取每个图片前，主机并不是都发出了新的 DNS 查询，因为本机 DNS 已经被缓存了，因此不需要发起新的 DNS 查询。
 nslookup 的 DNS 查询①
​		1.启动数据包捕获
​		2.使用nslookup查询www.mit.edu,然后停止捕获。
​		

​		DNS查询消息的目标端口和响应消息的源端口都是 53
​		DNS查询消息发送到192.168.31.79，和我的本地DNS服务器的IP地址相同
​		DNS 查询的&quot;Type&quot;是A，没有任何“Answers”

 nslookup 的 DNS 查询②
​		1.准备操作如上
​		2.打开cmd，键入
nslookup -type=NS mit.edu
​		
​		其他内容同上，但是Type 为 “NS”，表示查询权威 DNS 服务器，没有任何 “answers”。
​		
​		检查 DNS 响应消息，响应消息没提供 MIT 的域名的 IP 地址。
 nslookup 的 DNS 查询③
​		重复上一个实验，但换成以下命令：
nslookup www.aiit.or.kr bitsy.mit.edu
​		

​		DNS查询消息发送到的 IP 地址是18.0.72.3，不是我的IP地址
​		DNS查询是什么 “Type” 为 “A”，表示查询 IP 地址，没有任何 “answers”
​		DNS未响应

]]></content>
      <categories>
        <category>Wireshark</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/2021/10/25/2021-10-24-4/</url>
    <content><![CDATA[ 实验四
 TCP是什么？
​		传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。TCP旨在适应支持多网络应用的分层协议层次结构。 连接到不同但互连的计算机通信网络的主计算机中的成对进程之间依靠TCP提供可靠的通信服务。——百度百科
 1.捕获从计算机到远程服务器的批量 TCP 传输
​		1.在电脑上保存ASCII档案文件
​		
​		2. 打开 http://gaia.cs.umass.edu/wireshark-labs/TCP-wireshark-file1.html ：
​		
​		3.开始捕获，上传文件。

​		
​		可以看到计算机和 gaia.cs.umass.edu 的初始三次握手
​		
​		将文件传输到 gaia.cs.umass.edu 的客户计算机使用的 IP 地址是：192.168.84.71
​		TCP 端口号码是：50231
​		gaia.cs.umass.edu 的 IP 地址是：128.119.245.12，在80端口号上发送和接收此连接的 TCP 区段
 TCP Basics
​		我们关注 TCP 而不是 HTTP，因此更改 Wireshark 的“捕获数据包列表”视窗，以显示有关包含 HTTP 讯息的 TCP 区段的信息。Wireshark 执行此操作，选择 Analyze-&gt; Enabled Protocols。

​		用于在客户端计算机和 gaia.cs.umass.edu 之间启动 TCP 连接的 TCP SYN 区段的序列号是 0
​		将区段标识为 SYN 区段的区段功能是开始三次握手，主机发送 SYN 请求服务器建立连接，这是三次握手第一步
​		gaia.cs.umass.edu 发送给客户端计算机以回复 SYN 的 SYNACK 区段的序列号是 0，ACK是 1
​		ACK字段用于表示确认字段中的值是有效的，功能是说明服务器成功接收了我们发出的连接请求，并发送SYN-ACK确认报文
​		
​		包含 HTTP POST 命令的 TCP 区段的序列号是 1，其中 PSH 表示有数据传输

​		将包含 HTTP POST 的 TCP 区段视为 TCP 连接中的第一个区段。前六个 TCP 区段的长度是多少？在这个 TCP 连线中前 6 个 TCP 区段的序列号是什么（包括包含 HTTP POST 的段）？每区段发送的时间是什么时候？收到的每个区段的 ACK 是什么时候？鉴于发送每个 TCP 区段的时间与收到确认的时间之间的差异，六个区段中每个区段的 RTT 值是多少？收到每个 ACK 后，EstimatedRTT 值是什么？假设第一个 EstimatedRTT 的值等于第一个区段的测量 RTT。

EstimatedRTT 运算公式

EstimatedRTT = (1 - a) × EstimatedRTT + a × SampleRTT
1.区段一
​		
​		长度：749
​		序列号：1
​		发送时间：Oct 25, 2021 19:02:29.995963000
​		RTT：
2.区段二

​		长度：1370
​		序列号：16630
​		发送时间：Oct 25, 2021 19:02:31.432825000
​		RTT：
3.区段三

​		长度：1370
​		序列号：32260
​		发送时间：Oct 25, 2021 19:02:32.667493000
​		RTT：
4.区段四

​		长度：1370
​		序列号：48700
​		发送时间：Oct 25, 2021 19:02:33.271935000
​		RTT：
5.区段五

​		长度：1370
​		序列号：65140
​		发送时间：Oct 25, 2021 19:02:33.538223000
​		RTT：
6.区段六

​		长度：1370
​		序列号：81580
​		发送时间：Oct 25, 2021 19:02:33.784999000
​		RTT：
​		
​		对于服务器而言，收到的最小可用缓冲区空间量为 131328
​		对于主机而言，收到的最小可用缓冲区空间量为 29200
​		缺少接收器缓冲区空间会限制发送方传送 TCP 区段，这是因为 TCP 的流量控制服务，能够消除发送方使接收方缓存溢出的可能性，使得发送方的发送速率与接收方应用程序的读取速率相匹配。
​		
​				从中可以看出跟踪文件中有重传的区段。
​		接收器通常在 ACK 中确认多少数据？是否可以识别接收方每隔一个接收到的区段才发送确认的情况？(I don’t know)
​		 TCP 连接的吞吐量（每单位时间传输字节数）是多少？如何计算这个值？
​		平均吞吐量 = 传输数据的比特数 F ÷ 接收方接收所有数据所用时间 T
 TCP拥塞控制
​		
​		每个点代表一个发送的 TCP 区段，绘制区段的序列号与发送的时间，堆叠在一起的一组点表示发送方背靠背发送的一系列数据包。使用时序图（Stevens）查看从客户端发送到 gaia.cs.umass.edu 服务器的区段的序列号与时间关系图。您能否确定 TCP 的慢启动阶段的开始和结束位置，以及拥塞避免接管的位置？
]]></content>
      <categories>
        <category>Wireshark</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层(上)</title>
    <url>/2022/01/30/2022-01-29-%E5%BA%94%E7%94%A8%E5%B1%82(%E4%B8%8A)/</url>
    <content><![CDATA[ 应用层
 1.网络应用的体系结构
​	**网络应用：**百度、QQ、email、迅雷、支付宝、微信、百度云、淘宝网、网易。
 体系结构：
 （1）客户机/服务器结构（Client-Server，C/S）
​		服务器：
​		7*24小时提供服务
​		永久性访问地址/域名
​		利用大量服务器实现可扩展性
​		客户机：
​		与服务器通信，使用服务器提供的服务
​		间歇性的接入网络
​		可能使用动态IP地址
​		不会与其他客户机直接通信
​		例子：Web
   	![image.png](https://i.loli.net/2021/11/12/Wyd5468XE97D3vS.png)

 （2）点对点结构（Peer-to-peer，P2P）
​		没有永远在线的服务器
​		任意端系统/节点之间可以直接通讯
​		节点间歇性接入网络，可能改变IP地址
​		**优点：**高度可伸缩；	**缺点：**难于管理
 （3）混合结构（Hybrid）
​		 利用前两者的优点，规避两者的缺点。
​		 **Napster：**文件传输使用P2P结构；文件的搜索采用C/S结构——集中式
​				
 网络应用进程通信：
​	网络应用的基础：进程间的通信
​		**进程：**主机上运行的程序
​		同一主机的进程之间的通信方式：进程间通信机制，操作系统提供。不同主机：消息交换（报文交换）

​		    客户机进程：发起通信的进程
​			服务器进程：等待通信请求的进程

 套接字：Socket

进程间通信利用socket发送/接收消息实现
​		类似于寄信：
​		发送方将消息送到门外邮箱
​		发送方依赖（门外的）传输基础设施将消息传到接收方所在的主机，并送到接收方的门外
​		接收方从门外获取消息
​		传输基础设施向进程提供API:
​		传输协议的选择；参数的设置
 如何寻址进程
不同主机上的进程间通信，每个进程必须拥有标识符
如何寻址主机——IP地址
Q：主机的IP地址是否足以定位进程？
A：否。同一主机上可能同时有多个进程需要通信。
端口号/Port number


为主机上每个需要通信的进程分配一个端口号


HTTP Server：80


Mail Server：25
进程的标识符=IP地址+端口号


 应用层协议
网络应用需要遵顼应用层协议
公开协议：
​	由RFC（Request For Comments）定义
​	允许互操作
​	HTTP、SMTP…
私有协议：
​	多数P2P文件共享应用
 协议内容
**消息的类型：**请求消息、响应消息。
**消息的语法（Syntax）/格式：**消息中有哪些字段（field）、字段如何描述
**字段的语义（semantics）：**字段中信息的含义
**规则（rules）：**进程何时发送/响应消息
 2.网络应用的服务需求
数据丢失（data loss）/可靠性（reliability）

​	某些网络应用能够容忍一定的数据丢失：网络电话
​	某些网络应用要求100%可靠的数据传输：文件传输，telnet

时间（timing）/延迟（delay）

​	有些应用只有在延迟足够低时才“有效”
​	网络电话/网络游戏

带宽（bandwith）

某些应用只有在带宽达到最低要求时才“有效”：网络视频
某些应用能够适应任何带宽——弹性应用：email

典型网络应用对传输服务的需求：

 3.Internet传输层服务模型
 Internet提供的传输服务

 典型网络应用所使用的传输层服务

 4.特定网络应用及协议
 Web应用
 关于Web
World Wide Web:Tim Berners-Lee

网页
网页互相链接

网页（Web Page）包含多个对象（objects）

​	对象：HTML文件、JPEG图片、视频文件、动态脚本等
​	基本HTML文件：包含对其他对象引用的链接

对象的寻址（addressing）
URL（Uniform Resoure Locator）：统一资源定位器
Scheme：//host：port/path
 HTTP
HTTP协议：万维网应用遵循超文本传输协议（HyperText Transfer Protocol）
C/S结构

客户——Browser：请求、接收、展示Web对象
服务器——Web Server：响应客户的请求，发送对象。（Apache Web Server）

**HTTP版本：**1.0：RFC1945，1.1：RFC2068
使用TCP传输服务：

服务器在80端口等待客户的请求
浏览器发起到服务器的TCP连接（创建套接字Socket）
服务器接受来自浏览器的TCP连接
浏览器（HTTP客户端）与Web服务器（HTTP服务器）交换HTTP消息
关闭TCP连接

**无状态（stateless）：**服务器不维护任何有关客户端过去所发请求的信息
有状态的协议更复杂：需要维护状态（历史信息）、如果客户或服务器失效，会产生状态的不一致，解决这种问题代价高
 HTTP连接
非持久性连接（Nonpersistent HTTP）：每个TCP连接最多允许传输一个对象；HTTP 1.0版本使用非持久性连接。


 响应时间分析与建模
RTT（Round Trip Time）：从客户端发送一个很小的数据包到服务器并返回所经历的时间
响应时间（Response time）
​	发起、建立TCP连接：1个RTT
​	发送HTTP请求消息到HTTP响应消息的前几个字节到达：1个RTT
​	响应消息中所含文件/对象传输时间
​	Total = 2RTT + 文件发送时间
​	
非持久性连接存在一些问题：
​		每个对象需要2个RTT
​		操作系统需要为每个TCP连接开销资源（overhead）
​

持久性连接（persistent HTTP）：每个TCP连接最多允许传输多个对象；HTTP 1.1版本默认使用持久性连接

发送响应后，服务器保持TCP连接的打开
后续的HTTP消息可以通过这个连接发送

无流水（pipelining）的持久性连接

客户端只有收到前一个响应后才发送新的请求
每个被引用的对象耗时1个RTT


带有流水机制的持久性连接

HTTP 1.1的默认选项
客户端只要遇到一个引用对象就尽快发出请求
理想请求下，收到所有的引用对象只需耗时约1个RTT



 HTTP消息格式

请求消息

ASCII码：人直接可读




上传输入的方法：
​		POST方法：网页经常需要填写表格（form）/在请求消息的消息体（entity body）中上传客户端的输入
​		URL方法：使用GET方法/输入信息通过request行的URL字段上传


响应消息


 Cookie技术
HTTP协议无状态，很多应用需要服务器掌握客户端的状态，如：网上购物

某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。

 Cookie的组件

HTTP响应消息的cookie头部行
HTTP请求消息的cookie头部行
保存在客户端主机上的cookie文件，由浏览器管理
Web服务器端的后台数据

 Cookie的原理

 Cookie的作用

身份认证
购物车
推荐
Web e-mail …

Cookie技术存在一定的隐私问题
 Web缓存/代理服务器技术
​	功能：在不访问服务器的前提下满足客户端的HTTP请求
为什么要发明这种技术？

缩短客户请求的响应时间
减少机构。组织的流量
在大范围内(Internet)实现有效的内容分发

 关于该技术


用户设定浏览器通过缓存进行Web访问


浏览器向缓存/代理服务器发送所有的HTTP请求

如果所请求对象在缓存中，缓存返回对象
否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后返回给客户端并保存该对象



缓存既充当客户端，也充当服务器
一般由ISP(Internet服务提供商)假设
 条件性GET方法

 Email应用
 构成组件

邮件客户端（user agent）
邮件服务器
SMTP协议（Simple Mail Transfer Protocol）

 邮件客户端

读、写Email消息
与服务器交互，收、发Email消息
Outlook，Foxmail，Thunderbird
Web客户端

 邮件服务器

邮箱：存储发给该用户的Email
消息队列（message queue）：存储等待发送的Email

 SMTP协议

邮件服务器之间传递消息所使用的协议
客户端：发送消息的服务器
服务器：接受消息的服务器

采取TCP进行email消息的可靠传输
端口25
传输过程的三个阶段：握手-&gt;消息的传输-&gt;关闭
命令/响应交互模式：
命令（command）：ASCII文本
响应（response）：状态代码和语句
Email消息只能包含7位ASCII码

使用持久性连接
消息必须由7位ASCII码构成
SMTP服务器利用CRLF.CRLF确定消息的结束

 SMTP vs HTTP
SMTP：退式（push） HTTP：拉式（pull）
都使用命令/响应交互模式
命令和状态代码都是ASCII码
**HTTP：**每个对象封装在独立的响应消息中
**SMTP：**多个对象在由多个部分构成的消息中发送
 消息格式

 多媒体扩展

 邮件访问协议：从服务器获取邮件
POP：Post Office Protocol

认证/授权（客户端&lt;–&gt;服务器）和下载
…

IMAP：Internet Mail Access Protocol
HTTP：163，QQ Mail等
 DNS应用
DNS（Domain Name System）：解决Internet上主机/路由器的识别问题

IP地址
域名：www.baidu.com

如何解决域名和IP地址之间的映射？

域名解析系统DNS

多层命名服务器构成的分布式数据库
应用层协议：完成名字的解析

internet核心功能，用应用层协议实现
网络边界复杂





 DNS服务

域名向IP地址的翻译
主机别名
邮件服务器别名
负载均衡：Web服务器

为什么不适应集中式的DNS？

单点失败问题
流量问题
距离问题
维护性问题

分布式层次式数据库

 本地域名解析服务器：

不严格属于层级体系
每个ISP有一个本地域名服务器

默认域名解析服务器


当主机进行DNS查询时，查询被发送到本地域名服务器

作为代理（proxy），将查询转发给（层级式）域名服务器解析系统





 DNS记录缓存和更新

只要域名解析服务器获得域名—IP映射，即缓存这一映射

一段时间过后，缓存条目失效（删除）
本地域名服务器一般会缓存顶级域名服务器的映射

因此根域名服务器不会被经常访问





 DNS记录和消息格式

DNS协议

查询（query）和回复（reply）消息
消息格式相同

]]></content>
      <categories>
        <category>计网</category>
      </categories>
  </entry>
  <entry>
    <title>应用层(下)</title>
    <url>/2022/02/17/2022-02-16-%E5%BA%94%E7%94%A8%E5%B1%82(%E4%B8%8B)/</url>
    <content><![CDATA[ 应用层
 P2P应用
 架构

 文件分发：客户机/服务器 vs P2P




实例：BitTorrent
 索引技术
P2P系统的索引：信息到节点位置（IP+端口号）的映射
文件共享（电驴）

利用索引动态跟踪节点所共享的文件的位置
节点需要告诉索引它拥有哪些文件
节点搜索索引，从而获知能够得到哪些文件

即时消息（QQ）

索引负责将用户名映射到位置
当用户开启IM应用时，需要通知索引它的位置
节点检索索引，确定用户的IP地址

 集中式索引


内容和文件传输是分布式的，但是内容定位是高度集中式的。


单点失效问题
性能瓶颈
版权问题

 洪泛式查询：Query flooding

完全分布式架构
Gnutella采用这种架构
每个节点对它共享的文件进行索引，且只对她共享的文件进行索引

覆盖网络

节点X与Y之间如果有TCP连接，那么构成一个边
所有的活动节点和边构成覆盖网络
边：虚拟链路
节点一般邻居数少于10个


 层次式覆盖网络

案例：Skype
 Scoket应用

 应用编程接口API


就是应用进程的控制权和操作系统的控制权进行转换的一个系统调用接口。

几种典型的应用编程接口：

Berkeley UNIX操作系统定义了一种API，称为套接字接口（socket interface），简称套接字（socket）。
微软公司在其操作系统中采用了套接字接口API，形成了一个稍微不同的API，并称之为Windows Socket Interface，WINSOCK。
AT&amp;T为其UNIX系统V定义了一种API，简写为TLI（Transport Layer Interface）。

 Socket API


最初设计

面向BSD UNIX-Berkley
面向TCP/IP协议栈接口



目前

事实上的工业标准
绝大多数操作系统都支持



Internet网络应用最典型的API接口


通信模型

客户/服务器（C/S）



应用进程间通信的抽象机制



 Socket抽象


 Socket API 函数（没听懂）详解
Socket面向TCP/IP的服务类型

 网络字节顺序

TCP/IP定义了标准的用于协议中的二进制整数表示：网络字节顺序（network byte order）
某些Socket API函数的参数需要存储为网络字节顺序（如IP地址、端口号等）
可以实现本地字节顺序与网络字节顺序间转换的函数

htons：本地字节顺序-&gt;网络字节顺序（16bits）
ntohs：网络字节顺序-&gt;本地字节顺序（16bits）
htonl：本地字节顺序-&gt;网络字节顺序（32bits）
ntohl：网络字节顺序-&gt;本地字节顺序（32bits）



网络应用的Socket API（TCP）调用的基本流程

 解析服务器IP地址

解析服务器端口号

解析协议号

 TCP客户端软件流程

 UDP客户端软件流程

 4种类型的基本服务器

循环无连接服务器
循环面向连接服务器
并发无连接服务器
并发面向连接服务器

。。。。。。
]]></content>
      <categories>
        <category>计网</category>
      </categories>
  </entry>
  <entry>
    <title>传输层(上)</title>
    <url>/2022/02/17/2022-02-17-%E4%BC%A0%E8%BE%93%E5%B1%82(%E4%B8%8A)/</url>
    <content><![CDATA[ 传输层服务
 传输层服务和协议

 传输层 VS 网络层

网络层：提供主机之间的逻辑通信机制
传输层：提供应用进程之间的逻辑通信机制

位于网络之上
依赖于网络层服务
对于网络层服务进行（可能的）增强




类比：12个孩子给12个孩子发信

应用进程 = 孩子
应用消息 = 信封里的信
主机 = 房子
传输层协议 = 李雷和韩梅梅
网络层协议 = 邮政服务

 Internet传输层协议

可靠、按序的交付服务（TCP）

拥塞控制
流量控制
连接建立


不可靠的交付服务（UDP）

基于”尽力而为（Best-effort）“的网络层，没有做（可靠性方面的）扩展


两种服务均不保证

延迟
带宽



 复用和分用


Why？
如果某层的一个协议对应直接上层的多个协议/实体，则需要多路复用/分用。



 分用如何工作？

主机接收到IP数据报（datagram）

每个数据报携带源IP地址、目的IP地址
每个数据报携带一个传输层的段（Segment）




每个段携带源端口号和目的端口号


主机收到Segment之后，传输层协议提取IP地址和端口号信息，将Segment导向相应的Socket

TCP做更多处理



 无连接分用


 面向连接的分用



多线程Web服务器


 无连接传输协议—UDP
UDP：User Datagram Protocol

基于IP协议

复用/分用
简单的错误校验


”Best effort“服务，UDP段可能

丢失
非按序到达


无连接

UDP发送方和接受方之间不需要握手
每个UDP的段处理独立于其他段




UDP为什么存在？

无需建立连接（减少延迟）
实现简单：无需维持连接状态
头部开销少
没有拥塞控制：应用可以更好地控制发送时间和速率



常用于流媒体应用

容忍丢失
速率敏感


UDP还用于

DNS
SNMP


在UDP上实现可靠数据传输

在应用层增加可靠性机制
应用特定的错误恢复机制




 UDP校验和（checksum）

 可靠数据传输原理
 可靠数据传输协议
 基本结构：接口

Rdt 2.0 -&gt; Rdt 2.1 -&gt; Rdt3.0
 Rdt 3.0性能

 滑动窗口协议

 GBN（Go-Back-N协议）
 SR（Selective Repeat协议）
]]></content>
      <categories>
        <category>计网</category>
      </categories>
  </entry>
  <entry>
    <title>小程序开发</title>
    <url>/2022/02/21/2022-02-20-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[ 概述
 简介
​		小程序是一种不需要下载的安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念。用户不用关心是否安装太多应用的问题。应用无处不在，随时可用，但又无需安装卸载。——Allenzhang
特点：

速度快：无需下载安装，加载速度快于HTML5，微信登录，随时可用
无需适配：一次开发。多端兼容，免除了对各种手机型的适配
社交分享：支持直接或App分享给微信好友和群聊
出色体验：可以达到近乎原生App的操作体验和流畅度，在离线状态亦可使用
用完即走：通过扫码、长按、微信搜索、公众号、好友推荐等方式快速获取服务，用完即走
低门槛：已有公众号的组织可以快速注册、可快速生成门店小程序

 开发流程
小程序的技术模型：

小程序的程序语言：

渲染层：WXML + WXSS（类似HTML + CSS）
逻辑层：JavaScript
配置：JSON

 设计规范

友好：重点突出；流程明确
清晰：导航明确；减少等待；异常反馈
便捷：减少输入；避免误操作；操作流畅
统一：视觉统一；WeUI

 运营规范
 开发项目
 全局配置
​		小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。
以下是一个包含了部分常用配置选项的 app.json ：
&#123;  &quot;pages&quot;: [    &quot;pages/index/index&quot;,    &quot;pages/logs/index&quot;  ],  &quot;window&quot;: &#123;    &quot;navigationBarTitleText&quot;: &quot;Demo&quot;  &#125;,  &quot;tabBar&quot;: &#123;    &quot;list&quot;: [&#123;      &quot;pagePath&quot;: &quot;pages/index/index&quot;,      &quot;text&quot;: &quot;首页&quot;    &#125;, &#123;      &quot;pagePath&quot;: &quot;pages/logs/index&quot;,      &quot;text&quot;: &quot;日志&quot;    &#125;]  &#125;,  &quot;networkTimeout&quot;: &#123;    &quot;request&quot;: 10000,    &quot;downloadFile&quot;: 10000  &#125;,  &quot;debug&quot;: true&#125;
 页面配置
​		每一个小程序页面也可以使用同名 .json 文件来对本页面的窗口表现进行配置，页面中配置项会覆盖 app.json 的 window 中相同的配置项。
&#123;  &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,  &quot;navigationBarTextStyle&quot;: &quot;black&quot;,  &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,  &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,  &quot;backgroundTextStyle&quot;: &quot;light&quot;&#125;

	图片标记：路径可以使用http或相对路径
	作为容器元素

 应用弹性盒子布局

传统方式布局

目标的实现属性赋值非常分散
严重依赖于页面结构与内容的实际大小



弹性盒子布局（统一，灵活）
盒子属性：
display:flex;flex-direction:column;	//垂直布局justify-content:space-around;	//自上而下放置时素材均匀分布align-items:center;		//元素在水平方向上居中显示
 响应式长度单位rpx
让元素大小适配不同宽度屏幕
.images &#123;	width:375rpx;	height:375rpx;	border-radius:50%;	//圆形图片&#125;
 导航链接
navigator组件
&lt;navigator style=&quot;display:inline&quot; open-type=&quot;redirect&quot; url=&quot;/pages/logs/logs&quot;hover-class=&quot;nav-hover&quot;class=&quot;nav-default&quot;&gt;启动日志&lt;/navigator&gt;//style=&quot;display:inline&quot;	设置为内联元素//open-type=&quot;redirect&quot;	重定向，不可返回；默认为navigate	.nav-hover &#123;	color:red;&#125;	//点击态.nav-default &#123;	color:blue;&#125;	//显示态//交换两者才可实现点击态
 配置tabBar（底部标签栏）
app.json
&quot;tabBar&quot;: &#123;  &quot;list&quot;: [    &#123;      &quot;text&quot;: &quot;启动日志&quot;,      &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,      &quot;iconPath&quot;: &quot;images/icons/person.jpg&quot;,      &quot;selectedIconPath&quot;: &quot;images/icons/iperson.jpg&quot;    &#125;,    &#123;      &quot;text&quot;: &quot;主页&quot;,      &quot;pagePath&quot;: &quot;pages/index/index&quot;,      &quot;iconPath&quot;: &quot;images/icons/home.jpg&quot;,      &quot;selectedIconPath&quot;: &quot;images/icons/ihome.jpg&quot;    &#125;  ],  &quot;color&quot;:&quot;#000&quot;,  &quot;selectedColor&quot;:&quot;#00f&quot;&#125;,
此时navigate失效，需要修改。
&lt;navigator url=&quot;/pages/logs/logs&quot; open-type=&quot;switchTab&quot;&gt;启动日志&lt;/navigator&gt;
 配置全局导航栏样式
app.json
&quot;window&quot;: &#123;    &quot;backgroundTextStyle&quot;: &quot;light&quot;,    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,    &quot;navigationBarTitleText&quot;: &quot;关于&quot;,       &quot;navigationBarTextStyle&quot;: &quot;black&quot;,    &quot;enablePullDownRefresh&quot;: true  &#125;,
 数据绑定
weather.js
Page(&#123;  data: &#123;    todayweather:&#123;      city:&quot;武汉&quot;,      weather:&quot;晴&quot;,      temperature:&quot;2℃&quot;    &#125;  &#125;&#125;)
 小程序的运行环境与基本架构
​		每个小程序都是运行在它的微信客户端上的，通过微信客户端给它提供的运行环境，小程序可以直接获取微信客户端的原生体验和原生能力。
 条件渲染
在框架中，使用 wx:if=&quot;&quot; 来判断是否需要渲染该代码块：
&lt;view wx:if=&quot;&#123;&#123;condition&#125;&#125;&quot;&gt; True &lt;/view&gt;
也可以用 wx:elif 和 wx:else 来添加一个 else 块：
&lt;view wx:if=&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;&gt; 1 &lt;/view&gt;&lt;view wx:elif=&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt;
因为 wx:if 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 &lt;block/&gt; 标签将多个组件包装起来，并在上边使用 wx:if 控制属性。
&lt;block wx:if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt;  &lt;view&gt; view1 &lt;/view&gt;  &lt;view&gt; view2 &lt;/view&gt;&lt;/block&gt;
&lt;block/&gt; 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。
wx:if vs hidden
因为 wx:if 之中的模板也可能包含数据绑定，所以当 wx:if 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。同时 wx:if 也是惰性的，如果在初始渲染条件为 false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。
相比之下，hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。
一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好。
 列表渲染
 swiper组件
幻灯片轮播展示
 页面的生命周期函数
&lt;swiper&gt;&lt;/swiper&gt;添加属性
current=&quot;&#123;&#123; array.length - 1 &#125;&#125;&quot;	//切换到最后一张幻灯片(有缺陷)
js文件
current=&quot;&#123;&#123; currentIndex &#125;&#125;&quot;//初始化数据//生命周期函数onload:function(options) &#123;	this.setData(&#123;		currentIndex:this.data.array.length - 1	&#125;)&#125;//还包括其他的生命周期函数
 更新数据
&lt;button bindtap=&quot;f0&quot;&gt;按钮&lt;button&gt;//更新数据不能直接赋值f0:function(event)&#123;	console.log(this.data.count)	//读取	this.setData(&#123;    	count:this.data.count + 1    &#125;)&#125;//this.serData可以动态设置变量
 事件机制
&lt;button bindtap=&quot;f0&quot;&gt;按钮&lt;button&gt;		//会向上冒泡传递，父元素函数会被调用&lt;button catchtap=&quot;f1&quot;&gt;按钮&lt;button&gt;	//不会向上冒泡传递，父元素函数不会被调用
 组件自定义数据属性
f1:function(event)&#123;	wx.navigateTo(&#123;		url:&#x27;/pages/index/index&#x27;	&#125;)&#125;	//点击页面相同f1:function(event)&#123;	wx.navigateTo(&#123;		url:&#x27;/pages/index/index?id=77&#x27;	&#125;)&#125;	//点击页面相同
 动态导航栏
index.js
onShareAppMessage: function()&#123;	return &#123;		title:&quot;向你推荐&quot; + this.data.movie.title	&#125;&#125;
 组件化开发
 自定义组件item.js
item.json将组件属性设置true
&#123;    &quot;component&quot;: true&#125;
item.js
Component(&#123;    options: &#123; // 组件配置        addGlobalClass: true,        // 指定所有 _ 开头的数据字段为纯数据字段        // 纯数据字段是一些不用于界面渲染的 data 字段，可以用于提升页面更新性能        pureDataPattern: /^_/,         multipleSlots: true // 在组件定义时的选项中启用多slot支持    &#125;,    properties: &#123;        vtabs: &#123;type: Array, value: []&#125;,    &#125;,    data: &#123;        currentView: 0,    &#125;,    observers: &#123; // 监测        activeTab: function(activeTab) &#123;            this.scrollTabBar(activeTab);        &#125;    &#125;,     relations: &#123;  // 关联的子/父组件        &#x27;../vtabs-content/index&#x27;: &#123;            type: &#x27;child&#x27;, // 关联的目标节点应为子节点            linked: function(target) &#123;                this.calcVtabsCotentHeight(target);            &#125;,            unlinked: function(target) &#123;                delete this.data._contentHeight[target.data.tabIndex];            &#125;        &#125;    &#125;,    lifetimes: &#123; // 组件声明周期        created: function() &#123;            // 组件实例刚刚被创建好时        &#125;,        attached: function() &#123;            // 在组件实例进入页面节点树时执行        &#125;,        detached: function() &#123;            // 在组件实例被从页面节点树移除时执行        &#125;,    &#125;,    methods: &#123; // 组件方法        calcVtabsCotentHeight(target) &#123;&#125;    &#125; &#125;);
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>传输层(下)</title>
    <url>/2022/07/13/2022-07-07-%E4%BC%A0%E8%BE%93%E5%B1%82(%E4%B8%8B)/</url>
    <content><![CDATA[ TCP概述

点对点

一个发送方，一个接收方


可靠的、按序的字节流
流水线机制

TCP拥塞控制和流量控制机制设置窗口尺寸


发送方/接收方缓存
全双工（full-duplex）

同一连接中能够传输双向数据流


面向连接

通信双方在发送数据之前必须建立连接
连接状态只在连接的两端中维护，在沿途节点中并不维护状态
TCP连接包括：两台主机上的缓存、连接状态变量、socket等


流量控制机制

 TCP段结构

 序列号

序列号指的是segment中第一个字节的编号，而不是segment的编号
建立TCP连接时，双方随机选择序列号

 ACKs

希望接收到的下一个字节的序列号
累计确认：该序列号之前的所有字节均已被正确接收到

 可靠数据传输

TCP在IP层提供的不可靠服务基础上实现可靠数据传输服务
流水线机制
累计确认
TCP使用单一重传定时器
触发重传的事件

超时
收到重复ACK


渐进式

 RTT和超时
 TCP发送方事件

从应用层收到数据

创建Segment
序列号是Segment第一个字节的编号
开启计时器
设置超时时间：Timeout


超时

重传引起超时的Segment
重启计时器


收到ACK

如果确认此前未确认的Segment

更新SendBase
如果窗口中还有未被确认的分组，重启定时器






图例

 快速重传机制
 TCP流量控制
 TCP连接管理

一次握手：客户端发送带有 SYN 标志的连接请求数据包给服务端
二次握手：服务端发送带有 SYN+ACK 标志的连接请求和应答数据包给客户端
三次握手：客户端发送带有 ACK 标志的应答数据包给服务端(可以携带数据了)


 拥塞控制原理

拥塞（Congestion）


表现

分组丢失（路由器缓存溢出）
分组延迟过大（在路由器缓存中排队）


拥塞控制 vs 流量控制

 方法

端到端拥塞控制

网络层不需要显式的提供支持
端系统通过观察loss、delay等网络行为判断是否发生拥塞
TCP采用这种方法


网络辅助的拥塞控制

路由器向发送方显式地反馈网络拥塞信息
简单的拥塞指示
指示发送方应该采取何种速率
案例：ATM ABR拥塞控制



 TCP拥塞控制
]]></content>
      <categories>
        <category>计网</category>
      </categories>
  </entry>
  <entry>
    <title>云开发</title>
    <url>/2022/07/15/2022-07-15-%E4%BA%91%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[ 云开发基础

云开发是微信团队联合腾讯云提供的原生 Serverless 云服务，致力于帮助更多的开发者快速实现小程序业务的开发，怏速迭代。

 云开发 VS 传统开发
 传统模式
产品经理 → 后端开发 → 部署上线 → 前端开发 → 正式发布
 云开发
产品经理 → 前端开发 → 正式发布



 云开发能力


存储：在小程序端直接上传/下载云端文件，可视化管理


云函数：在云端运行的代码，微信私有天然鉴权，开发者只需编写自身业务逻辑代码


云数据库：一个既可在小程序前端操作，也能在云函数中读写的JSON数据库


音视频服务：提供互通高品质实时音视频通话服务，支持互动白板，美颜滤镜，高清视频通话等，基于云开发快速接入


智能图像服务：集成智能鉴黄、人脸识别、人脸识别、人脸核身等AI视觉能力，基于云开发怏速接入。


 数据存储能力
 一行代码创建数据

 一行代码查询数据

 云开发 API
 初始化
小程序

服务端


初始化选项 env 支持传入一个 Object，指定服务使用的默认环境

 注意事项

云开发 API 同时支持callback 风格和promise 风格
云开发 API 初始化时如果没有设置 ID，默认使用先创建的那个
在服务端可以借助云开发 SDK 内置的 getWXContext 来获取到用户的身份信息

 数组查询

 字段查询

 正则查询

 地理位置索引
减少开发压力，只需要一个字段。
 文件存储
存储于云端，可以生成临时链接。
 云函数定时触发器
&#123;   &quot;Type&quot;:&quot;Timer&quot;,   &quot;TriggerName&quot;:&quot;EveryDay&quot;,   &quot;Time&quot;:&quot;2019-02-21T11:49:00Z&quot;,   &quot;Message&quot;:&quot;user define msg body&quot;&#125;
 Todo项目实战
 Vant UI
导入Vant UI
//安装npm i vant//初始化npm init -y//安装组件npm i @vant/weapp@1.3.3 -S --production
​		删除app.json中的&quot;style&quot;:&quot;v2&quot;。防止微信中的样式与 vant 中的样式发生冲突。
在project.config.json中的setting节点中修改以下两项：
&quot;packNpmManually&quot;: true,&quot;packNpmRelationList&quot;: [      &#123;        &quot;packageJsonPath&quot;: &quot;./package.json&quot;,        &quot;miniprogramNpmDistDir&quot;: &quot;./&quot;      &#125;]
构建 npm
&quot;usingComponents&quot;: &#123;  &quot;van-button&quot;: &quot;@vant/weapp/button/index&quot;&#125;

 组件引入
&quot;usingComponents&quot;: &#123;    &quot;vant-button&quot; : &quot;@vant/weapp/button&quot;,    &quot;van-cell&quot; : &quot;@vant/weapp/cell&quot;,    &quot;van-cell-group&quot; : &quot;@vant/weapp/cell-group&quot;  &#125;
 下拉刷新
index.json
&quot;enablePullDownRefresh&quot;: true
index.js
onPullDownRefresh:function()&#123;    this.getdata();    wx.stopPullDownRefresh()  &#125;,
 选择位置
app.json
&quot;requiredPrivateInfos&quot;: [    &quot;chooseLocation&quot;  ],  &quot;permission&quot;: &#123;    &quot;scope.userLocation&quot;: &#123;      &quot;desc&quot;: &quot;你的位置信息将用于小程序位置接口&quot;    &#125;  &#125;
addtodo.js
chooseLocation:function()&#123;  wx.chooseLocation(&#123;    latitude: 0,    longitude: 0,    success: res =&gt; &#123;      console.log(res)      let LocationObj = &#123;        latitude:res.latitude,        longitude:res.longitude,        name:res.name,        address:res.address      &#125;      this.pagedata.LocationObj = LocationObj    &#125;,    fail: (res) =&gt; &#123;      console.log(res)    &#125;,    complete: (res) =&gt; &#123;      console.log(res)    &#125;,  &#125;)&#125;
 导航
todoInfo.js
viewLocation:function()&#123;    wx.openLocation(&#123;      latitude: this.data.task.location.latitude,      longitude: this.data.task.location.longitude,      address: this.data.task.location.address,      name: this.data.task.location.name,      scale: 0,      success: (res) =&gt; &#123;&#125;,      fail: (res) =&gt; &#123;&#125;,      complete: (res) =&gt; &#123;&#125;,    &#125;)  &#125;
注意传送LocationObj对象
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>局域网</title>
    <url>/2022/07/30/2022-07-29-%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    <content><![CDATA[ ARP协议
 MAC地址
MAC（或称LAN地址，物理地址，以太网地址）

作用：用于局域网内标识一个帧从哪个接口出发，到达哪个物理相连的其他接口
48为MAC地址（用于大部分LANs）,固化在网卡的ROM中，有时也可以软件设置
例子：1A-2F-BB-76-09-AD（16进制）

 ARP协议
地址解析协议
ARP表：LAN中的每个IP结点（主机/路由器）维护一个表

存储某些LAN结点的IP/MAC地址映射关系 &lt;IP地址；MAC地址；TTL&gt;
TTL（Time To Live）经过这个时间以后该映射关系会被遗弃

ARP是“即插即用”协议：结点自主创建ARP表，无需干预
 以太网
“统治地位”的有线LAN技术：

造价低廉
应用最广泛的LAN技术
比令牌局域网和ATM等简单
满足网络速率需求：10 Mbps~10 Gbps

…
 交换机
网络设备对比

…
 虚拟局域网
…
 PPP协议
 802.11无线局域网
802.11b

2.4-2.5GHz频段
最高速率：11 Mbps
物理层采用直接序列扩频技术（DSSS）技术

802.11a

5-6GHz频段
最高速率：54 Mbps

802.11g

2.4-2.5GHz频段
最高速率：54 Mbps

802.11n：多天线（MIMO）

2.4-2.5GHz频段
最高速率：600 Mbps


均使用CSMA/CA多路访问控制协议
均有基础设施（基站）网络模式和特定网（自组网）网络模式

]]></content>
      <categories>
        <category>计网</category>
      </categories>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2022/07/19/2022-07-18-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[ 网络层概述
**主要任务：**实现网络互联，进而实现数据包在各个网络之间的传输
主要问题：

网络层向传输层提供怎样的服务（可靠or不可靠）
网络层寻址问题

 核心功能

转发（forwarding）：将分组从路由器的输出端口转移到合适的输出端口

路由器转发表（确定在本路由器如何转发分组）


路由（routing）：确定分组从源到目的经过的路径

路由算法（协议）（routing algorithms）：确定通过网络的端到端路径


连接建立（ATM、帧中继、X.25）

数据分组传输之前两端主机需要首先建立虚拟/逻辑连接

网络设备（如路由器）参与连接的建立





 服务模型

无连接服务（connecting-less service）

不事先为系列分组的传输确定传输路径
每个分组独立确定传输路径
不同分组可能传输路径不同
数据报网络（datagram network）


连接服务

首先为系列分组的传输确定从源到目的经过的路径
然后沿该路径（连接）传输系列分组
系列分组传输路径相同
传输结束后拆除连接
虚电路网络（virtual-circuit network）



 虚电路网络
 虚电路
虚电路：一条从源主机到目的主机。类似于电路的路径（逻辑连接）

分组交换
每个分组的传输利用链路的全部带宽
源到目的路径经过的网络层设备共同完成虚电路功能

 数据报网络

网络层无连接
每个分组携带目的地址
路由器根据分组的目的地址转发分组

基于路由协议/算法构建转发表
检索转发表
每个分组独立选路



 转发表

最长前缀匹配优先

 IPv4协议
 Internet网络层

 IP数据报


版本号：IP协议的版本号
首部长度：IP分组首部长度
服务类型（TOS）：指示期望获得哪种类型的服务

1998年改名为区分服务
只有网络提供区分服务（DiffServ）时使用
一般情况下不使用，通常IP分组的该字段的值为00H


总长度：IP分组的总字节数（首部+数据）

最大IP分组的总长度：65535B
最小的IP分组首部：20B
IP分组可以封装的最大数据：65535 - 20 = 65515B



生存时间（TTL）：IP分组在网络中可以通过的路由器数（或跳步数）

路由器转发一次分组，TTL减一
如果TTL = 0，路由器则丢弃该IP分组


协议：指示IP分组封装的是哪个协议的数据包

实现复用/分解
6——TCP
17——UDP


首部校验和：实现对IP分组首部的差错检验

计算校验和时，该字段置全0
采用反码算数运算求和，和的反码作为首部校验和字段


源IP地址、目的IP地址：分别标识发送分组的源主机/路由器（网络接口）和接收分组的目的主机/路由器（网络接口）的IP地址
选项字段：携带安全、源选路径、时间戳和路有记录等内容（很少使用）
填充：补齐首部（32位）


 IP数据分片
最大传输单元（MTU）：网络链路层存在MTU——链路层数据帧可封装数据的上限
 IP分片与重组

大IP分组向较小MTU链路转发时，可以被“分片”

一个IP分组分为多片IP分组
IP分片到达目的主机后进行“重组”

IP首部的相关字段用于标识分片以及确定分片的相对顺序

总长度、标识、标志位和片偏移




标识：标识一个IP分组

IP协议利用一个计数器，每产生IP分组计数器加1，作为该IP分组的标识



标志位：



保留
DF（Don’t Fragment）
MF（More Fragment）





DF = 1：禁止分片；DF = 0：允许分片
MF = 1：非最后一片；MF = 0：最后一片（或未分片）





片偏移：一个IP分组分片封装原IP分组数据的相对偏移量

片偏移字段以8字节为单位



 IP编址
 接口
interface：主机/路由器与物理链路的连接

实现网络层功能
路由器通常有多个接口
主机通常只有一个或两个接口（如：有线的以太网接口，无线的802.11接口）

 IP地址

32比特（IPv4）：编号标识主机、路由器的接口


IP地址与每个接口关联

网络号（NetID）——高位比特
主机号（HostID）——低位比特



 有类IP地址

 IP子网

IP地址具有相同网络号的设备接口
不跨越路由器（第三及以上层网络设备）可以彼此物理联通的接口

 子网划分

网络号（NetID）——高位比特
子网号（SubID）——原网络主机号部分比特
主机号（HostID）——低位比特

 子网掩码

形如IP地址

32位
点分十进制形式


取值

NetID、SubID位全取1
HostID全取0


例如

A网的默认子网掩码为：255.0.0.0
B网的默认子网掩码为：255.255.0.0
C网的默认子网掩码为：255.255.255.0
借用3比特划分子网的B网的子网掩码为：255.255.224.0




子网地址+子网掩码-&gt;准确确定子网大小

 应用
将IP分组的目的IP地址与子网掩码按位与运算，提取子网地址

 CIDR
无类域间路由（Classless InterDomain Routing）

消除传统的A、B、C类地址界限

NetID+SubID→Network Prefix 可以任意长度


融合子网地址与子网掩码，方便子网划分

无类地址格式：a.b.c.d/x	，其中x为前缀长度


提高IPv4地址空间分配效率
提高路由效率

将多个子网聚合为一个较大的子网
构造超网（supernetting）
路由聚合（route aggregation）



 DHCP协议
获取IP地址

静态配置
DHCP

DHCP（Dynamic Host Configuration Protocol）动态主机配置协议

从服务器动态获取：

IP地址
子网掩码
默认网关地址
DNS服务器名称与IP地址


“即插即用”
允许地址重用
支持在用地址续租
支持移动用户加入网络

 工作过程

 NAT
NAT（Network Address Translate）网络地址转换


只需从ISP申请一个IP地址

IPv4地址耗尽


本地网络设备IP地址的变更，无需通告外界网络
变更ISP时，无需修改内部网络设备IP地址
内部网络设备对外界网络不可见，即不可直接寻址（安全）

实现：

替换

利用（NAT IP地址，新端口号）替换每个外出IP数据报的（源IP地址，源端口号）


记录

将每对（NAT IP地址，新端口号）与（源IP地址，源端口号）的替换信息存储到NAT转换表中


替换

根据NAT转换表，利用（源IP地址，源端口号）替换每进入内网IP数据报的（目的IP地址，目的端口号），即（NAT IP地址，新端口号）



关于NAT穿透的技术
 ICMP协议
ICMP（Internet Control Message Protocol）互联网控制报文协议
支持主机或路由器：

差错（或异常）报告
网络探询

两类ICMP报文

差错报告报文：

目的不可达
源抑制（Source Quench）
超时/超期
参数问题
重定向


网络探询报文

回声（Echo）请求与应答报文（Reply）
时间戳请求与应答报文



ICMP报文：类型+编码（查表）

 报文格式

 差错报告报文

 IPv6协议
最初动机：IPv4地址空间已经分配殆尽
其他动机：

快速处理/转发数据报
支持QoS

IPv6数据报格式：

固定长度的40字节基本首部
不允许分片

对比IPv4

校验和：彻底移除，以减少每跳处理时间
选项：允许，但是从基本首部移出，定义多个选项首部，通过“下一个字段首部”字段指示
ICMPv6：新版ICMP

附加报文类型
多播组管理功能



…
]]></content>
      <categories>
        <category>计网</category>
      </categories>
  </entry>
  <entry>
    <title>刷题笔记</title>
    <url>/2022/10/05/2022-10-04-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[ 洛谷
 P1059 [NOIP2006 普及组] 明明的随机数

数组去重排序

#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;using namespace std;int main()&#123;    int m;cin &gt;&gt; m;    int a[m];    for(int i = 0;i &lt; m;i++)  cin &gt;&gt; a[i];    sort(a, a + m);  // 排序    int n = unique(a, a + m) - a;  //去重    cout &lt;&lt; n &lt;&lt; endl;    for(int i = 0;i &lt; n;i++)        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;&#125;//unique(a, a+m)的返回值是a[m]的地址

 牛客
 BM1 反转链表
class Solution &#123;public:    ListNode* ReverseList(ListNode* pHead) &#123;    if(!pHead || !pHead-&gt;next)        return pHead;    else&#123;        ListNode *p = pHead,*r = pHead-&gt;next, *q = p;        while(r-&gt;next)&#123;            p-&gt;next = r-&gt;next;            r-&gt;next = q;            q = r;            r = p-&gt;next;        &#125;        r-&gt;next = q;        p-&gt;next = NULL;        pHead = r;    &#125;        return pHead;    &#125;&#125;;

 二分查找/排序
 BM17 二分查找
class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int high = nums.size(), mid = high / 2, left = 0;        if(!high)  return -1;        while(left &lt;= high)&#123;            mid = (left + high)/2;            if(nums[mid] == target)                return mid;            else if(nums[mid] &lt; target)                left = mid + 1;            else                high = mid-1;        &#125;        return -1;    &#125;&#125;;

 BM18 二维数组中的查找
​		在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
[[1,2,8,9],
[2,4,9,12],
[4,7,10,13],
[6,8,11,15]]
给定 target = 7，返回 true；给定 target = 3，返回 false。
class Solution &#123;public:    bool Find(vector&lt;vector&lt;int&gt; &gt; array,int target) &#123;        int m, n, x, y;        m = array.size();	//行数        n = array[0].size();	//列数        x = m-1;y = 0;	//坐标定在左下角        while(x &gt;= 0 &amp;&amp; y &lt;= n-1)&#123;          if(target &lt; array[x][y])                   x--;	//遇小上移          else if(target &gt; array[x][y])                   y++;	//遇大右移          else               return true;      &#125;       return false;     &#125;&#125;;

 BM19 寻找峰值
​		给定一个长度为n的数组nums，请找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。
1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于
2.假设 nums[-1] = nums[n] = -\infty−∞
3.对于所有有效的 i 都有 nums[i] != nums[i + 1]
4.你可以使用O(logN)的时间复杂度实现此问题吗？
输入[2,4,1,2,7,8,4]时，会形成两个山峰，一个是索引为1，峰值为4的山峰，另一个是索引为5，峰值为8的山峰。
二分查找
class Solution &#123;public:    int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;        int left = 0;        int right = nums.size() - 1;        //二分法 fast-template        while(left &lt; right)&#123;            int mid = (left + right) / 2;            //右边是往下，不一定有坡峰            if(nums[mid] &gt; nums[mid + 1])                right = mid;            //右边是往上，一定能找到波峰            else                left = mid + 1;        &#125;        //其中一个波峰        return right;&#125;&#125;;

 BM20 数组中的逆序对
描述：
数组中两个数，如果前一个数字大于后面的数字，则这两数组成一个逆序对。
输入一个数组,求出这个数组中的逆序对的总数P。输出P mod 1000000007的结果。
要求：空间复杂度 O(n)，时间复杂度 O(nlogn)
输入描述：题目保证输入的数组中没有的相同的数字



输入示例
返回值




[1,2,3,4,5,6,7,0]
7


[1,2,3]
0




归并排序


class Solution &#123;private:    const int kmod = 1000000007;public:    int InversePairs(vector&lt;int&gt; data) &#123;        int ret = 0;        // 在最外层开辟数组        vector&lt;int&gt; tmp(data.size());        merge_sort__(data, tmp, 0, data.size() - 1, ret);        return ret;    &#125;    void merge_sort__(vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;tmp, int l, int r, int &amp;ret) &#123;        if (l &gt;= r)             return;        int mid = l + ((r - l) &gt;&gt; 1);        merge_sort__(arr, tmp, l, mid, ret);        merge_sort__(arr, tmp, mid + 1, r, ret);        merge__(arr, tmp, l, mid, r, ret);    &#125;    void merge__(vector&lt;int&gt; &amp;arr, vector&lt;int&gt; &amp;tmp, int l, int mid, int r, int &amp;ret) &#123;        int i = l, j = mid + 1, k = 0;        while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;            if (arr[i] &gt; arr[j]) &#123;                tmp[k++] = arr[j++];                ret += (mid - i + 1);                ret %= kmod;            &#125;            else                tmp[k++] = arr[i++];        &#125;        while (i &lt;= mid)            tmp[k++] = arr[i++];        while (j &lt;= r)            tmp[k++] = arr[j++];        for (k = 0, i = l; i &lt;= r; ++i, ++k)            arr[i] = tmp[k];    &#125;&#125;;
 BM21 旋转数组的最小数字
描述
有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。
要求：空间复杂度：O(1)，时间复杂度：O(logn)
输入：[3,4,5,1,2]	返回值：1
输入：[3,100,200,3]	返回值：3
//二分法class Solution &#123;public:    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;        int left = 0;        int right = rotateArray.size() - 1;        while(left &lt; right)&#123;            int mid = (left + right) / 2;            //最小的数字在mid右边            if(rotateArray[mid] &gt; rotateArray[right])                 left = mid + 1;            //无法判断，一个一个试            else if(rotateArray[mid] == rotateArray[right])                 right--;            //最小数字要么是mid要么在mid左边            else                 right = mid;        &#125;        return rotateArray[left];    &#125;&#125;;
//遍历class Solution &#123;public:    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;        int res = INT_MAX;        //遍历数组        for(int i = 0; i &lt; rotateArray.size(); i++)             //每次维护最小值            res = min(res, rotateArray[i]);         return res;    &#125;&#125;;
 BM22 比较版本号
描述:
版本号是由修订号组成，修订号与修订号之间由一个&quot;.&quot;连接。1个修订号可能有多位数字组成，修订号可能包含前导0，且是合法的。例如，1.02.11，0.1，0.2都是合法的版本号。每个版本号至少包含1个修订号。修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。
比较规则：


比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如&quot;0.1&quot;和&quot;0.01&quot;的版本号是相等的


如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，“1.1&quot;的版本号小于&quot;1.1.1”。因为&quot;1.1&quot;的版本号相当于&quot;1.1.0&quot;，第3位修订号的下标为0，小于1


version1 &gt; version2 返回1，如果 version1 &lt; version2 返回-1，不然返回0.


输入：&quot;1.1&quot;,&quot;1.01&quot;		返回值：0说明：version2忽略前导0，为&quot;1.1&quot;，和version相同，返回0 
class Solution &#123;public:    int compare(string version1, string version2) &#123;        int n1 = version1.size();        int n2 = version2.size();        int i = 0, j = 0;        //直到某个字符串结束        while(i &lt; n1 || j &lt; n2)&#123;            long long num1 = 0;            //从下一个点前截取数字            while(i &lt; n1 &amp;&amp; version1[i] != &#x27;.&#x27;)&#123;                 num1 = num1 * 10 + (version1[i] - &#x27;0&#x27;);                i++;            &#125;            //跳过点            i++;             long long num2 = 0;            //从下一个点前截取数字            while(j &lt; n2 &amp;&amp; version2[j] != &#x27;.&#x27;)&#123;                 num2 = num2 * 10 + (version2[j] - &#x27;0&#x27;);                j++;            &#125;            //跳过点            j++;             //比较数字大小            if(num1 &gt; num2)                 return 1;            if(num1 &lt; num2)                return -1;        &#125;        //版本号相同        return 0;     &#125;&#125;;
 二叉树
 BM27 按之字形顺序打印二叉树
翻转数组！！！
if(flag)        reverse(row.begin(), row.end());
栈方法
class Solution &#123;  public:    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;        vector&lt;vector&lt;int&gt; &gt; res;        if (pRoot == NULL)   //如果是空，则直接返回空vector            return res;        stack&lt;TreeNode*&gt; q, q2;     //队列存储，进行层次遍历        q.push(pRoot);        TreeNode* cur;        int tag = 1;        while (!q.empty() || !q2.empty()) &#123;            //记录二叉树的某一行            vector&lt;int&gt; row;            int n = tag ? q.size() : q2.size();            //因先进入的是根节点，故每层节点多少，队列大小就是多少            for (int i = 0; i &lt; n; i++) &#123;                cur = (tag) ? q.top() : q2.top();                if (tag)  q.pop();                else  q2.pop();                row.push_back(cur-&gt;val);                //若是左右孩子存在，则存入左右孩子作为下一个层次                if (tag) &#123;                    if (cur-&gt;left)                        q2.push(cur-&gt;left);                    if (cur-&gt;right)                        q2.push(cur-&gt;right);                &#125; else &#123;                    if (cur-&gt;right)                        q.push(cur-&gt;right);                    if (cur-&gt;left)                        q.push(cur-&gt;left);                &#125;            &#125;            tag = !tag;            //每一层加入输出            res.push_back(row);        &#125;        return res;    &#125;&#125;;
 BM28 二叉树的最大深度
求给定二叉树的最大深度，深度是指树的根节点到任一叶子节点路径上节点的数量。
最大深度是所有叶子节点的深度的最大值。
class Solution &#123;  public:    /**     *     * @param root TreeNode类     * @return int整型     */    int maxDepth(TreeNode* root) &#123;        // write code here        if (!root) &#123;            return 0;        &#125;        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;    &#125;&#125;;
 BM29 二叉树中和为某一值的路径(一)
给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。


该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点


叶子节点是指没有子节点的节点


路径只能从父节点到子节点，不能从子节点到父节点


总节点数目为n


递归
class Solution &#123;public:    bool hasPathSum(TreeNode* root, int sum) &#123;        //空节点找不到路径        if(root == NULL)             return false;        //叶子节点，且路径和为sum        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL &amp;&amp; sum - root-&gt;val == 0)             return true;        //递归进入子节点        return hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);    &#125;&#125;;
 堆/栈/队列
 BM42 用两个栈实现队列
保证操作合法，即保证pop操作时队列内已有元素。
class Solution&#123;public:    void push(int node) &#123;        stack1.push(node);    &#125;    int pop() &#123;        if(stack2.empty())&#123;            while(!stack1.empty())&#123;                stack2.push(stack1.top());                stack1.pop();        &#125;        &#125;        int node = stack2.top();        stack2.pop();        return node;    &#125;private:    stack&lt;int&gt; stack1;    stack&lt;int&gt; stack2;&#125;;
 BM43 包含min函数的栈
class Solution &#123;public:    stack&lt;int&gt; s1;    stack&lt;int&gt; s2;    void push(int value) &#123;        s1.push(value);        if(s2.empty() || s2.top() &gt; value)&#123;            s2.push(value);        &#125;        else&#123;            s2.push(s2.top());        &#125;    &#125;    void pop() &#123;        s1.pop();        s2.pop();    &#125;    int top() &#123;        return s1.top();    &#125;    int min() &#123;        return s2.top();    &#125;&#125;;
 BM44 有效括号序列
给出一个仅包含字符’(‘,’)‘,’{‘,’}‘,’[‘和’]',的字符串，判断给出的字符串是否是合法的括号序列
括号必须以正确的顺序关闭，&quot;()“和”()[]{}“都是合法的括号序列，但”(]“和”([)]&quot;不合法。
class Solution &#123;public:    bool isValid(string s) &#123;        //辅助栈        stack&lt;char&gt; st;         //遍历字符串        for(int i = 0; i &lt; s.length(); i++)&#123;             //遇到左小括号            if(s[i] == &#x27;(&#x27;)                 //期待遇到右小括号                st.push(&#x27;)&#x27;);             //遇到左中括号            else if(s[i] == &#x27;[&#x27;)                 //期待遇到右中括号                st.push(&#x27;]&#x27;);             //遇到左打括号            else if(s[i] == &#x27;&#123;&#x27;)                //期待遇到右打括号                 st.push(&#x27;&#125;&#x27;);             //必须有左括号的情况下才能遇到右括号            else if(st.empty())                 return false;            //右括号匹配则弹出            else if(st.top() == s[i])                 st.pop();        &#125;        //栈中是否还有元素        return st.empty();     &#125;&#125;;
 BM45 滑动窗口的最大值

遍历数组的每一个元素，
如果容器为空，则直接将当前元素加入到容器中。
如果容器不为空，则让当前元素和容器的最后一个元素比较，如果大于，则将容器的最后一个元素删除，然后继续将当前元素和容器的最后一个元素比较
如果当前元素小于容器的最后一个元素，则直接将当前元素加入到容器的末尾
如果容器头部的元素已经不属于当前窗口的边界，则应该将头部元素删除

class Solution &#123;public:    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)    &#123;        vector&lt;int&gt; ret;        if (num.size() == 0 || size &lt; 1 || num.size() &lt; size) return ret;        int n = num.size();           deque&lt;int&gt; dq;           for (int i = 0; i &lt; n; ++i) &#123;               while (!dq.empty() &amp;&amp; num[dq.back()] &lt; num[i]) &#123;                   dq.pop_back();               &#125;               dq.push_back(i);               // 判断队列的头部的下标是否过期               if (dq.front() + size &lt;= i) &#123;                   dq.pop_front();            &#125;            // 判断是否形成了窗口               if (i + 1 &gt;= size) &#123;                   ret.push_back(num[dq.front()]);               &#125;           &#125;           return ret;     &#125;&#125;;
 BM46 最小的K个数
给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。
方法一：直接排序
直接排序，取前k个元素。
class Solution &#123;public:    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;        vector&lt;int&gt; ret;        if (k==0 || k&gt;input.size()) return ret;        sort(input.begin(), input.end());        return vector&lt;int&gt;(&#123;input.begin(), input.begin()+k&#125;);       &#125;&#125;;
方法二：堆排序
建立一个容量为k的大根堆的优先队列。遍历一遍元素，如果队列大小&lt;k，就直接入队，否则，让当前元素与队顶元素相比，如果队顶元素大，则出队，将当前元素入队
优先队列 优先队列 - 知乎

优先队列中，队列中的数据被赋予了优先级。当访问元素时，优先级最高的会先被删除。

class Solution &#123;public:    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;        vector&lt;int&gt; ret;        if (k==0 || k &gt; input.size()) return ret;        priority_queue&lt;int, vector&lt;int&gt;&gt; pq;        for (const int val : input) &#123;            if (pq.size() &lt; k) &#123;                pq.push(val);            &#125;            else &#123;                if (val &lt; pq.top()) &#123;                    pq.pop();                    pq.push(val);                &#125;            &#125;        &#125;        while (!pq.empty()) &#123;            ret.push_back(pq.top());            pq.pop();        &#125;        return ret;    &#125;&#125;;
方法三：快排思想
快速排序  视频讲解

分治法思想

对数组[l, r]一次快排partition过程可得到，[l, p), p, [p+1, r)三个区间,[l,p)为小于等于p的值
[p+1,r)为大于等于p的值。然后再判断p，利用二分法

如果[l,p), p，也就是p+1个元素（因为下标从0开始），如果p+1 == k, 找到答案
如果p+1 &lt; k, 说明答案在[p+1, r)区间内，
如果p+1 &gt; k , 说明答案在[l, p)内

class Solution &#123;public:    int partition(vector&lt;int&gt; &amp;input, int l, int r) &#123;        int pivot = input[r-1];        int i = l;        for (int j=l; j&lt;r-1; ++j) &#123;            if (input[j] &lt; pivot) &#123;                swap(input[i++], input[j]);            &#125;        &#125;        swap(input[i], input[r-1]);        return i;    &#125;    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;        vector&lt;int&gt; ret;        if (k==0 || k &gt; input.size()) return ret;         int l = 0, r = input.size();        while (l &lt; r) &#123;            int p = partition(input, l, r);            if (p+1 == k) &#123;                return vector&lt;int&gt;(&#123;input.begin(), input.begin()+k&#125;);            &#125;            if (p+1 &lt; k) &#123;                l = p + 1;            &#125;               else &#123;                r = p;            &#125;        &#125;c        return ret;    &#125;&#125;;
 寻找第K大
有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。
给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)
class Solution &#123;public:    int partion(vector&lt;int&gt;&amp; a, int low, int high)&#123; //常规的快排划分，但这次是大数在左        int temp = a[low];        while(low &lt; high)&#123;            while(low &lt; high &amp;&amp; a[high] &lt;= temp)                high--;            if(low == high)                break;            else                a[low] = a[high];            while(low &lt; high &amp;&amp; a[low] &gt;= temp)                low++;            if(low == high)                break;            else                a[high] = a[low];        &#125;        a[low] = temp;        return low;    &#125;        int quickSort(vector&lt;int&gt;&amp; a, int low, int high, int K)&#123;        int p = partion(a, low, high); //先进行一轮划分，p下标左边的都比它大，下标右边都比它小        if(K == p - low + 1)  //若p刚好是第K个点，则找到            return a[p];        else if(p - low + 1 &gt; K)  //从头到p超过k个数组，则目标在左边            return quickSort(a, low, p - 1, K);  //递归左边        else              return quickSort(a, p + 1, high, K - (p - low + 1));  //否则，在右边,递归右边,但是需要减去左边更大的数字的数量    &#125;        int findKth(vector&lt;int&gt; a, int n, int K) &#123;        return quickSort(a, 0, n - 1, K);    &#125;&#125;;
 BM48 数据流中的中位数
如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

插入排序

class Solution &#123;public:    //记录输入流    vector&lt;int&gt; val;    void Insert(int num) &#123;        if(val.empty())            //val中没有数据，直接加入            val.push_back(num);         //val中有数据，需要插入排序        else&#123;            int i = 0;            //遍历找到插入点            for(; i &lt; val.size(); i++)&#123;                if(num &lt;= val[i])&#123;                   break;                &#125;            &#125;            val.insert(val.begin() + i, num);        &#125;    &#125;    double GetMedian() &#123;        int n = val.size();        //奇数个数字        if(n % 2 == 1)&#123;             //类型转换            return double(val[n / 2]);         &#125;        //偶数个数字        else&#123;             double a = val[n / 2];            double b = val[n / 2 - 1];            return (a + b) / 2;        &#125;    &#125;&#125;;


堆排序（优先队列）


一个大根堆，存中位数左边的数据，
一个小根堆，存中位数右边的数据，
动态维护两个数据结构的大小，即最多只相差一个。

//版本一class Solution &#123;public:    //大顶堆，元素数值较小    priority_queue&lt;int&gt; min;     //小顶堆，元素数值都比大顶堆大    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; max;    //维护两个堆，取两个堆顶部即可    void Insert(int num) &#123;               //先加入较小部分         min.push(num);        //将较小部分的最大值取出，送入到较大部分        max.push(min.top());          min.pop();        //平衡两个堆的数量        if(min.size() &lt; max.size())&#123;              min.push(max.top());            max.pop();        &#125;            &#125;    double GetMedian() &#123;        //奇数个        if(min.size() &gt; max.size())              return (double)min.top();        else            //偶数个            return (double)(min.top() + max.top()) / 2;     &#125;&#125;;
 BM49 表达式求值
请写一个整数计算器，支持加减乘三种运算和括号。
class Solution &#123;public:    vector&lt;int&gt; function(string s, int index)&#123;        stack&lt;int&gt; stack;         int num = 0;        char op = &#x27;+&#x27;;        int i;        for(i = index; i &lt; s.length(); i++)&#123;            //数字转换成int数字            if(isdigit(s[i]))&#123;                num = num * 10 + s[i] - &#x27;0&#x27;;                if(i != s.length() - 1)                    continue;            &#125;            //碰到&#x27;(&#x27;时，把整个括号内的当成一个数字处理            if(s[i] == &#x27;(&#x27;)&#123;                //递归处理括号                vector&lt;int&gt; res = function(s, i + 1);                num = res[0];                i = res[1];                if(i != s.length() - 1)                    continue;            &#125;                       switch(op)&#123;            //加减号先入栈            case &#x27;+&#x27;:                 stack.push(num);                break;            case &#x27;-&#x27;:                //相反数                stack.push(-num);                break;            //优先计算乘号            case &#x27;*&#x27;:                  int temp = stack.top();                stack.pop();                stack.push(temp * num);                break;            &#125;            num = 0;            //右括号结束递归            if(s[i] == &#x27;)&#x27;)                break;             else                 op = s[i];        &#125;        int sum = 0;        //栈中元素相加        while(!stack.empty())&#123;              sum += stack.top();            stack.pop();        &#125;        return vector&lt;int&gt; &#123;sum, i&#125;;     &#125;        int solve(string s) &#123;        return function(s, 0)[0];    &#125;&#125;;
 哈希
 BM 50 两数之和
哈希表
class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;        int n = numbers.size();         vector &lt;int&gt; res;        if (!n) 	return res;        // unordered_map是用哈希表实现的，复杂度为O(1)，而map是用红黑树实现的        unordered_map&lt;int, int&gt; hashmap;         for (int i = 0; i &lt; n; i ++) &#123;            if (hashmap.find(target - numbers[i]) != hashmap.end()) &#123;                 // find函数返回hashmap.end()代表未找到，否则代表找到                // 将结果存入数组                res.push_back(hashmap[target - numbers[i]] + 1);                 res.push_back(i + 1);                break;            &#125; else &#123;                hashmap[numbers[i]] = i; // 将未找到的值插入哈希表中，继续遍历            &#125;        &#125;        return res;    &#125;&#125;;
 BM51 数组中出现次数超过一半的数字
哈希表
class Solution &#123;public:    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;        unordered_map&lt;int,int&gt; mp;        for (const int val : numbers) ++mp[val];        for (const int val : numbers) &#123;            if (mp[val] &gt; numbers.size() / 2 ) return val;        &#125;        return 0;    &#125;&#125;;//时间复杂度：O(n)//空间复杂度：O(n)
排序法
class Solution &#123;public:    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;        sort(numbers.begin(), numbers.end());        int cond = numbers[numbers.size() / 2];        int cnt = 0;        for (const int k :numbers) &#123;            if (cond == k) ++cnt;        &#125;        if (cnt &gt; numbers.size() / 2) return cond;        return 0;    &#125;&#125;;//时间复杂度：O(nlongn)//空间复杂度：O(1)
候选法
class Solution &#123;public:    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;        int cond = -1;        int cnt = 0;        for (int i=0; i&lt;numbers.size(); ++i) &#123;            if (cnt == 0) &#123;                cond = numbers[i];                ++cnt;            &#125;            else &#123;                if (cond == numbers[i]) ++cnt;                else --cnt;            &#125;        &#125;        cnt = 0;        for (const int k :numbers) &#123;            if (cond == k) ++cnt;        &#125;        if (cnt &gt; numbers.size() / 2) return cond;        return 0;    &#125;&#125;;//时间复杂度：O(n)//空间复杂度：O(1)
 BM52 数组中只出现一次的两个数字
哈希表
class Solution &#123;public:    vector&lt;int&gt; FindNumsAppearOnce(vector&lt;int&gt;&amp; array) &#123;        unordered_map&lt;int, int&gt; mp;        vector&lt;int&gt; res;        //遍历数组        for(int i = 0; i &lt; array.size(); i++)             //统计每个数出现的频率            mp[array[i]]++;         //再次遍历数组        for(int i = 0; i &lt; array.size(); i++)             //找到频率为1的两个数            if(mp[array[i]] == 1)                 res.push_back(array[i]);        //整理次序        if(res[0] &lt; res[1])             return res;        else            return &#123;res[1], res[0]&#125;;    &#125;&#125;;//时间复杂度：O(n)，其中n为数组长度，两次单独的遍历数组每个元素//空间复杂度：O(n)，哈希表的长度应该为(n−2)/2
异或运算
​		异或运算满足交换率，且相同的数字作异或会被抵消掉，比如：a⊕b⊕c⊕b⊕c=a，且任何数字与0异或还是原数字，该题目里面所有数字异或运算就会得到a⊕b，也即得到了两个只出现一次的数字的异或和。
//遍历数组得到a^bfor(int i = 0; i &lt; array.length; i++)     temp ^= array[i];//
class Solution &#123;public:    vector&lt;int&gt; FindNumsAppearOnce(vector&lt;int&gt;&amp; array) &#123;        vector&lt;int&gt; res(2, 0);        int temp = 0;        //遍历数组得到a^b        for(int i = 0; i &lt; array.size(); i++)             temp ^= array[i];        int k = 1;        //找到两个数不相同的第一位        while((k &amp; temp) == 0)             k &lt;&lt;= 1;        for(int i = 0; i &lt; array.size(); i++)&#123;            //遍历数组，对每个数分类            if((k &amp; array[i]) == 0)                 res[0] ^= array[i];            else                res[1] ^= array[i];        &#125;        //整理次序        if(res[0] &lt; res[1])             return res;        else            return &#123;res[1], res[0]&#125;;    &#125;&#125;;//时间复杂度：O(n)，遍历两次数组，找到两个数不相同的第一位循环为常数次//空间复杂度：O(1)，常数级变量使用，无额外辅助空间
 BM53 缺失的第一个正整数
class Solution &#123;public:    int minNumberDisappeared(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        unordered_map&lt;int, int&gt; mp;        //哈希表记录数组中出现的每个数字        for(int i = 0; i &lt; n; i++)             mp[nums[i]]++;        int res = 1;        //从1开始找到哈希表中第一个没有出现的正整数        while(mp.find(res) != mp.end())             res++;        return res;    &#125;&#125;;//时间复杂度：O(n)//空间复杂度：O(n)
原地哈希

step 1：我们可以先遍历数组将所有的负数都修改成n+1。
step 2：然后再遍历数组，每当遇到一个元素绝对值不超过n时，则表示这个元素是1～n中出现的元素，我们可以将这个数值对应的下标里的元素改成负数，相当于每个出现过的正整数，我们把与它值相等的下标都指向一个负数，这就是类似哈希表的实现原理的操作。
step 3：最后遍历数组的时候碰到的第一个非负数，它的下标就是没有出现的第一个正整数，因为它在之前的过程中没有被修改，说明它这个下标对应的正整数没有出现过。

class Solution &#123;public:    int minNumberDisappeared(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        //遍历数组        for(int i = 0; i &lt; n; i++)             //负数全部记为n+1            if(nums[i] &lt;= 0)                 nums[i] = n + 1;        for(int i = 0; i &lt; n; i++)            //对于1-n中的数字            if(abs(nums[i]) &lt;= n)                 //这个数字的下标标记为负数                nums[abs(nums[i]) - 1] = -1 * abs(nums[abs(nums[i]) - 1]);         for(int i = 0; i &lt; n; i++)            //找到第一个元素不为负数的下标            if(nums[i] &gt; 0)                return i + 1;        return n + 1;    &#125;&#125;;//时间复杂度：O(n)//空间复杂度：O(1)
 三数之和
class Solution &#123;public:    vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123;        vector&lt;vector&lt;int&gt;&gt;ans;        if(num.size()&lt;3)return ans;        sort(num.begin(),num.end());                for(int i = 0; i &lt; num.size() - 2; i++)&#123;            if(num[i] == num[i-1] &amp;&amp; i)	continue;            int l = i + 1,r = num.size() - 1;            while(l &lt; r)&#123;                if(num[l] + num[r] == -num[i])&#123;                    //若指针i 加指针j 等于当前数x 则答案为x 和指针i 与j 的三元组                    ans.push_back(&#123;num[i],num[l],num[r]&#125;);                    while(num[l]==num[l+1] &amp;&amp; l + 1&lt;r)	l++;                    while(num[r]==num[r-1] &amp;&amp; r-1 &gt; l)	r--;                    l++;                    r--;                &#125;                else if(num[l]+num[r]&gt;-num[i])&#123;                    r--;	//若指针l 加指针r 大于当前数-num[i]则指针r--                &#125;                else l++;	//若指针l 加指针r 小于当前数-num[i]则指针l++，            &#125;        &#125;        return ans;    &#125;&#125;;



 递归/回溯
 BM55 没有重复项数字的全排列
给出一组数字，返回该组数字的所有排列：
例如：
[1,2,3]的所有排列如下
[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2], [3,2,1].
（以数字在数组中的位置靠前为优先级，按字典序排列输出。）
class Solution &#123;public:    void recursion(vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;num, int index)&#123;        //分枝进入结尾，找到一种排列        if(index == num.size() - 1)             res.push_back(num);        else&#123;            //遍历后续的元素            for(int i = index; i &lt; num.size(); i++)&#123;                 //交换二者                swap(num[i], num[index]);                 //继续往后找                recursion(res, num, index + 1);                 //回溯                swap(num[i], num[index]);             &#125;        &#125;    &#125;        vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123;        //先按字典序排序        sort(num.begin(), num.end());         vector&lt;vector&lt;int&gt; &gt; res;        //递归获取        recursion(res, num, 0);         return res;    &#125;&#125;;



 BM56 有重复项数字的全排列
class Solution &#123;public:    void recursion(vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;num, vector&lt;int&gt; &amp;temp, vector&lt;int&gt; &amp;vis)&#123;        //临时数组满了加入输出        if(temp.size() == num.size())&#123;             res.push_back(temp);            return;        &#125;        //遍历所有元素选取一个加入        for(int i = 0; i &lt; num.size(); i++)&#123;             //如果该元素已经被加入了则不需要再加入了            if(vis[i]) 	continue;            if(i &gt; 0 &amp;&amp; num[i - 1] == num[i] &amp;&amp; !vis[i - 1])                 //当前的元素num[i]与同一层的前一个元素num[i-1]相同且num[i-1]已经用过了                continue;              //标记为使用过            vis[i] = 1;              //加入数组            temp.push_back(num[i]);             recursion(res, num, temp, vis);            //回溯            vis[i] = 0;             temp.pop_back();        &#125;    &#125;        vector&lt;vector&lt;int&gt; &gt; permuteUnique(vector&lt;int&gt; &amp;num) &#123;        //先按字典序排序        sort(num.begin(), num.end());         //标记每个位置的元素是否被使用过        vector&lt;int&gt; vis(num.size(), 0);         vector&lt;vector&lt;int&gt; &gt; res;        vector&lt;int&gt; temp;         //递归获取        recursion(res, num, temp, vis);         return res;    &#125;&#125;;



 BM57 岛屿数量
给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。
例如：输入	(注：存储的01数据其实是字符’0’,‘1’)
[[1,1,0,0,0],
[0,1,0,1,1],
[0,0,0,1,1],
[0,0,0,0,0],
[0,0,1,1,1]]
对应的输出为3
class Solution &#123;public:    //深度优先遍历与i，j相邻的所有1    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j) &#123;         int n = grid.size();	//行        int m = grid[0].size();		//列        grid[i][j] = &#x27;0&#x27;; 	 //置为0                //后续四个方向遍历        if(i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == &#x27;1&#x27;)             dfs(grid, i - 1, j);        if(i + 1 &lt; n &amp;&amp; grid[i + 1][j] == &#x27;1&#x27;)             dfs(grid, i + 1,j);        if(j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == &#x27;1&#x27;)             dfs(grid, i, j - 1);        if(j + 1 &lt; m &amp;&amp; grid[i][j + 1] == &#x27;1&#x27;)             dfs(grid, i, j + 1);    &#125;        int solve(vector&lt;vector&lt;char&gt; &gt;&amp; grid) &#123;        int n = grid.size();        //空矩阵的情况        if (n == 0)              return 0;        int m = grid[0].size();        //记录岛屿数        int count = 0;         //遍历矩阵        for(int i = 0; i &lt; n; i++)&#123;             for(int j = 0; j &lt; m; j++)&#123;                //遍历到1的情况                if(grid[i][j] == &#x27;1&#x27;)&#123;                     //计数                    count++;                    dfs(grid, i, j); 	//将与这个1相邻的所有1置为0                &#125;            &#125;        &#125;        return count;    &#125;&#125;;



 BM58 字符串的排列
输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。
例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。

class Solution &#123;public:    void recursion(vector&lt;string&gt; &amp;res, string &amp;str, string &amp;temp, vector&lt;int&gt; &amp;vis)&#123;        //临时字符串满了加入输出        if(temp.length() == str.length())&#123;             res.push_back(temp);            return;        &#125;        //遍历所有元素选取一个加入        for(int i = 0; i &lt; str.length(); i++)&#123;             //如果该元素已经被加入了则不需要再加入了            if(vis[i])                 continue;            if(i &gt; 0 &amp;&amp; str[i - 1] == str[i] &amp;&amp; !vis[i - 1])                //当前的元素str[i]与同一层的前一个元素str[i-1]相同且str[i-1]已经用过了                continue;            //标记为使用过              vis[i] = 1;              //加入临时字符串            temp.push_back(str[i]);             recursion(res, str, temp, vis);            //回溯            vis[i] = 0;             temp.pop_back();        &#125;    &#125;        vector&lt;string&gt; Permutation(string str) &#123;        //先按字典序排序，使重复字符串相邻        sort(str.begin(), str.end());         //标记每个位置的字符是否被使用过s        vector&lt;int&gt; vis(str.size(), 0);         vector&lt;string&gt; res;        string temp;        //递归获取        recursion(res, str, temp, vis);         return res;    &#125;&#125;;
 BM59 N皇后问题
N皇后问题是指在 n * n 的棋盘上要摆 n 个皇后，要求：任何两个皇后不同行，不同列也不在同一条斜线上，求给一个整数 n ，返回 n 皇后的摆法数。
常规代码
class Solution &#123;public:    //判断皇后是否符合条件    bool isValid(vector&lt;int&gt; &amp;pos, int row, int col)&#123;         //遍历所有已经记录的行        for(int i = 0; i &lt; row; i++)&#123;             //不能同行同列同一斜线            if(row == i || col == pos[i] || abs(row - i) == abs(col - pos[i]))                 return false;        &#125;        return true;    &#125;        //递归查找皇后种类    void recursion(int n, int row, vector&lt;int&gt; &amp; pos, int &amp;res)&#123;         //完成全部行都选择了位置        if(row == n)&#123;             res++;             return;        &#125;        //遍历所有列        for(int i = 0; i &lt; n; i++)&#123;             //检查该位置是否符合条件            if(isValid(pos, row, i))&#123;                 //加入位置                pos[row] = i;                 //递归继续查找                recursion(n, row + 1, pos, res);             &#125;        &#125;    &#125;        int Nqueen(int n) &#123;        int res = 0;        vector&lt;int&gt; pos(n, 0); 	//下标为行号，元素为列号，记录皇后位置         recursion(n, 0, pos, res); 	 //递归        return res;    &#125;&#125;;

位运算

如对 col = 0100 对应第二列已有皇后，那么下一行的第一列和第三列都不能选
对应 pos = 0010，也就是col右移一位；对应neg = 1000，也就是col左移一位
pre = ~ (col | pos | neg) &amp; ((1 &lt;&lt; n) - 1) 代表可以放皇后的位置
~ (col | pos | neg)：col、pos、neg取或运算后0表示可以放皇后的位置，取反后1表示可以放皇后的位置((1 &lt;&lt; n) - 1) ：是为了保证pre不大于n位
然后对pre中所有的1进行遍历，从最后一个1开始往前遍历，在当前行放置了一个皇后之后进入下一行，对col、pos、neg做出相应的处理，其余操作与上一个方法相同

import java.util.*;public class Solution &#123;    int res;    public int Nqueen (int n) &#123;        limit = (1 &lt;&lt; n) - 1;        backtrack(0, 0, 0, 0, limit);        return res;    &#125;        public void backtrack(int i, int col, int pos, int neg, int limit)&#123;        if(i == n)&#123;            res++;            return;        &#125;         //标记放皇后的位置        int pre = ~(col | pos | neg) &amp; (limit);        //遍历pre        while(pre &gt; 0)&#123;            int cur = pre &amp; (-pre);            //当前行放置了一个皇后之后进入下一行            backtrack(i + 1, col | cur, (pos | cur) &gt;&gt; 1, (neg | cur) &lt;&lt; 1, limit);            pre &amp;= pre - 1;        &#125;    &#125;&#125;



 BM60 括号生成
给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。
例如，给出n=3，解集为：“((()))”, “(()())”, “(())()”, “()()()”, “()(())”
class Solution &#123;public:    void recursion(int left, int right, string temp, vector&lt;string&gt; &amp;res, int n)&#123;        //左右括号都用完了，就加入结果        if(left == n &amp;&amp; right == n)&#123;             res.push_back(temp);            return;        &#125;        //使用一次左括号        if(left &lt; n)             recursion(left + 1, right, temp + &quot;(&quot;, res, n);        //使用右括号个数必须少于左括号        if(right &lt; n &amp;&amp; left &gt; right)             recursion(left, right + 1, temp + &quot;)&quot;, res, n);    &#125;        vector&lt;string&gt; generateParenthesis(int n) &#123;        //记录结果        vector&lt;string&gt; res;         //记录每次组装的字符串        string temp;         //递归        recursion(0, 0, temp, res, n);         return res;    &#125;&#125;;



 BM61 矩阵最长递增路径
给定一个 n 行 m 列矩阵 matrix ，矩阵内所有数均为非负整数。 你需要在矩阵中找到一条最长路径，使这条路径上的元素是递增的。并输出这条最长路径的长度。
这个路径必须满足以下条件：
1.每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。
2.你不能走重复的单元格。即每个格子最多只能走一次。
***思路：***既然是查找最长的递增路径长度，那我们首先要找到这个路径的起点，起点不好直接找到，就从上到下从左到右遍历矩阵的每个元素。然后以每个元素都可以作为起点查找它能到达的最长递增路径。
如何查找以某个点为起点的最长递增路径呢？我们可以考虑深度优先搜索，因为我们查找递增路径的时候，每次选中路径一个点，然后找到与该点相邻的递增位置，相当于进入这个相邻的点，继续查找递增路径，这就是递归的子问题。因此递归过程如下：

终止条件 进入路径最后一个点后，四个方向要么是矩阵边界，要么没有递增的位置，路径不能再增长，返回上一级。
返回值 每次返回的就是本级之后的子问题中查找到的路径长度加上本级的长度。
本级任务 每次进入一级子问题，先初始化后续路径长度为0，然后遍历四个方向（可以用数组表示，下标对数组元素的加减表示去往四个方向），进入符合不是边界且在递增的邻近位置作为子问题，查找子问题中的递增路径长度。因为有四个方向，所以最多有四种递增路径情况，因此要维护当级子问题的最大值。

具体做法

使用一个dp数组记录i，j处的单元格拥有的最长递增路径，这样在递归过程中如果访问到就不需要重复访问。
遍历矩阵每个位置，都可以作为起点，并维护一个最大的路径长度的值。
对于每个起点，使用dfs查找最长的递增路径：只要下一个位置比当前的位置数字大，就可以深入，同时累加路径长度。

//DFSclass Solution &#123;public:    int dirs[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;	//记录四个方向    int n, m;    //深度优先搜索，返回最大单元格数        int dfs(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, vector&lt;vector&lt;int&gt; &gt; &amp;dp, int i, int j) &#123;        if(dp[i][j] != 0)	return dp[i][j];        dp[i][j]++;        for(int k = 0; k &lt; 4; k++)&#123;            int nexti = i + dirs[k][0];            int nextj = j + dirs[k][1];            //判断条件            if (nexti &gt;= 0 &amp;&amp; nexti &lt; n &amp;&amp; nextj &gt;= 0 &amp;&amp; nextj &lt; m &amp;&amp; matrix[nexti][nextj] &gt; matrix[i][j])                 dp[i][j] = max(dp[i][j], dfs(matrix, dp, nexti, nextj) + 1);        &#125;        return dp[i][j];    &#125;        int solve(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;        //矩阵不为空        if(matrix.size() == 0 || matrix[0].size() == 0)             return 0;        int res = 0;        n = matrix.size();        m = matrix[0].size();                //i，j处的单元格拥有的最长递增路径        vector&lt;vector&lt;int&gt; &gt; dp (n, vector &lt;int&gt; (m));          for(int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++)                //更新最大值                res = max(res, dfs(matrix, dp, i, j));         return res;    &#125;&#125;;



BFS → 有向图的最长路径 → 拓扑排序
思路将矩阵看成一个有向图，一个元素到另一个元素递增，代表有向图的箭头。这样我们可以根据有向图的出度入度找到最长的路径，且这个路径在矩阵中就是递增的。
具体做法

计算每个单元格所对应的出度（符合边界条件且递增），作为边界条件的单元格的出度都为0。利用一个二维矩阵记录每个单元格的出度
利用拓扑排序的思想，从所有出度为0的单元格开始进行广度优先搜索。
用队列进行bfs，队列中每次加入出度为0的点，即路径最远点，每次从A点到B点，便将A点出度减一。
每次搜索都会遍历当前层所有单元格，更新其余单元格出度，将出度变为0的单元格加入下一层搜索。
搜索结束时，搜索的总层数即为矩阵中的最长递增路径的长度，因为bfs的层数就是路径增长的层数。

class Solution &#123;public:    //记录四个方向    int dirs[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;	//以单元格建立坐标系    int n, m;    int solve(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;        //空矩阵        if (matrix.size() == 0 || matrix[0].size() == 0)              return 0;        n = matrix.size();	//行        m = matrix[0].size();	//列                //记录每个单元的出度        vector&lt;vector&lt;int&gt; &gt; outdegrees(n, vector&lt;int&gt; (m));         for (int i = 0; i &lt; n; i++) &#123;            for (int j = 0; j &lt; m; j++) &#123;                for (int k = 0; k &lt; 4; k++) &#123;                    int nexti = i + dirs[k][0];                    int nextj = j + dirs[k][1];                    if (nexti &gt;= 0 &amp;&amp; nexti &lt; n &amp;&amp; nextj &gt;= 0 &amp;&amp; nextj &lt; m &amp;&amp; matrix[nexti][nextj] &gt; matrix[i][j]) &#123;                        //符合条件，记录出度                        outdegrees[i][j]++;                    &#125;                &#125;            &#125;        &#125;                queue &lt;pair&lt;int, int&gt; &gt; q;        for (int i = 0; i &lt; n; i++)             for (int j = 0; j &lt; m; j++)                 if (outdegrees[i][j] == 0)                    //找到出度为0的入队列                    q.push(&#123;i, j&#125;);                int res = 0;        while (!q.empty()) &#123;            res++;            int size = q.size();            for (int x = 0; x &lt; size; x++) &#123;                pair&lt;int, int&gt; temp = q.front();                 q.pop();                int i = temp.first;                int j = temp.second;                //四个方向                for (int k = 0; k &lt; 4; k++) &#123;                     int nexti = i + dirs[k][0];                    int nextj = j + dirs[k][1];                    //逆向搜索，所以下一步是小于                    if (nexti &gt;= 0 &amp;&amp; nexti &lt; n &amp;&amp; nextj &gt;= 0 &amp;&amp; nextj &lt; m &amp;&amp; matrix[nexti][nextj] &lt; matrix[i][j]) &#123;                        //符合条件，出度递减                        outdegrees[nexti][nextj]--;                         if (outdegrees[nexti][nextj] == 0) &#123;                            q.push(&#123;nexti, nextj&#125;);                        &#125;                    &#125;                &#125;            &#125;        &#125;        return res;    &#125;&#125;;



 动态规划
 BM62 斐波那契数列
描述	斐波那契数列，输入一个正整数 n ，输出斐波那契数列的第 n 项。
fib(x)={1if x=0 or x=2fib(x−1)+fib(x−2)if x&gt;2fib(x) = \begin{cases} 1 &amp; \text{if } x=0 \text{ or } x=2 \\ fib(x-1)+fib(x-2) &amp; \text{if } x&gt;2 \end{cases}fib(x)={1fib(x−1)+fib(x−2)​if x=0 or x=2if x&gt;2​
要求：空间复杂度 O(1)，时间复杂度 O(n)，本题也有时间复杂度 O(logn)的解法
//递归算法class Solution &#123;public:    int Fibonacci(int n) &#123;        if(n &lt;= 2)	return 1;        else            return Fibonacci(n - 1) + Fibonacci(n - 2);    &#125;&#125;;//记忆化搜索class Solution &#123;public:    int f[50]&#123;0&#125;;    int Fibonacci(int n) &#123;        if (n &lt;= 2)	     return 1;        if (f[n] &gt; 0)	return f[n];        return f[n] = (Fibonacci(n-1)+Fibonacci(n-2));    &#125;&#125;;//动态规划1class Solution &#123;public:    int dp[50]&#123;0&#125;;    int Fibonacci(int n) &#123;        dp[1] = 1, dp[2] =1;        for (int i = 3 ; i &lt;= n ; i ++) dp[i] = dp[i-1]+dp[i-2];        return dp[n];    &#125;&#125;;//动态规划2class Solution &#123;public:    int Fibonacci(int n) &#123;        int a = 1 , b = 1 , c = 1;        for (int i = 3 ; i &lt;= n ; i ++) &#123;            c = a+b , a = b , b = c;        &#125;        return c;    &#125;&#125;;
 BM63 跳台阶
描述	同斐波那契数列
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
要求：时间复杂度：O(n)，空间复杂度： O(1)
class Solution &#123;public:    int jumpFloor(int number) &#123;        int a = 1 , b = 1 , c = 1;        for (int i = 2 ; i &lt;= number ; i ++) &#123;            c = a+b , a = b , b = c;        &#125;        return c;    &#125;&#125;;
 BM64 最小花费爬楼梯
描述	给定一个整数数组 cost，其中 cost[i]是从楼梯第i个台阶向上爬需要支付的费用，下标从0开始。
一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。
class Solution &#123;public:    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;        //dp[i]表示爬到第i阶楼梯需要的最小花费        vector&lt;int&gt; dp(cost.size() + 1, 0);         for(int i = 2; i &lt;= cost.size(); i++)            //每次选取最小的方案            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);         return dp[cost.size()];    &#125;&#125;;
 BM65 最长公共子序列
描述	给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回&quot;-1&quot;。目前给出的数据，仅仅会存在一个最长的公共子序列
输入：“1A2C3D4B56”,“B1D23A456A”
输出：“123456”
class Solution &#123;public:    string LCS(string s1, string s2) &#123;        if(s1.empty() || s2.empty()) return &quot;-1&quot;;        int dp[s1.size()+1][s2.size()+1];        for(int i = 0; i &lt;= s1.size(); i++)             dp[i][0] = 0;        for(int j = 0; j &lt;= s2.size(); j++)             dp[0][j] = 0;        for(int i = 1; i &lt;= s1.size(); i++) &#123;            for(int j = 1; j &lt;= s2.size(); j++)                 dp[i][j] = (s1[i-1] == s2[j-1]) ? dp[i-1][j-1] + 1: max(dp[i-1][j], dp[i][j-1]);         &#125;        string res = &quot;&quot;;        for(int i = s1.size(), j = s2.size(); dp[i][j] &gt;= 1;) &#123;            if(s1[i-1] == s2[j-1]) &#123;                res += s1[i-1];                i--;j--;            &#125;            else if(dp[i-1][j] &gt;= dp[i][j-1]) i--;            else j--;        &#125;        reverse(res.begin(), res.end());        return res.empty() ? &quot;-1&quot; : res;    &#125;&#125;;
 BM66 最长公共子串
给定两个字符串str1和str2,输出两个字符串的最长公共子串
class Solution &#123;public:    string LCS(string str1, string str2) &#123;        //dp[i][j]表示到str1第i个个到str2第j个为止的公共子串长度        vector&lt;vector&lt;int&gt; &gt; dp(str1.length() + 1, vector&lt;int&gt;(str2.length() + 1, 0));         int max = 0;        int pos = 0;        for(int i = 1; i &lt;= str1.length(); i++)&#123;            for(int j = 1; j &lt;= str2.length(); j++)&#123;                //如果该两位相同                if(str1[i - 1] == str2[j - 1])&#123;                     //则增加长度                    dp[i][j] = dp[i - 1][j - 1] + 1;                 &#125;                else&#123;                     //该位置为0                    dp[i][j] = 0;                 &#125;                //更新最大长度                if(dp[i][j] &gt; max)&#123;                     max = dp[i][j];                    pos = i - 1;                &#125;            &#125;        &#125;        return str1.substr(pos - max + 1, max);    &#125;&#125;;
 BM67 不同路径的数目(一)
一个机器人在m×n大小的地图的左上角（起点）。
机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。
可以有多少种不同的路径从起点走到终点？



起点


























终点



要求：空间复杂度 O(nm)，时间复杂度 O(nm)
进阶：空间复杂度 O(1)，时间复杂度 O(min(n,m))



int uniquePaths(int m, int n) &#123;       vector&lt;vector&lt;int&gt;&gt;dp(m,vector&lt;int&gt;(n,0));       //第一行初始化，只有一条路径       for(int i=0;i&lt;n;i++)&#123;           dp[0][i] = 1;       &#125;       //第一列初始化，只有一条路径       for(int i=0;i&lt;m;i++)&#123;           dp[i][0] =1;       &#125;       for(int i=1;i&lt;m;i++)&#123;           for(int j=1;j&lt;n;j++)&#123;               //转移方程               dp[i][j] = dp[i-1][j]+dp[i][j-1];           &#125;       &#125;       return dp[m-1][n-1];
 //数学求解    int uniquePaths(int m, int n) &#123;    long long ret = 1;    for (int x = n, y = 1; y &lt; m; ++x, ++y) &#123;        //组合公式的循环求解        ret = ret * x / y;    &#125;    return ret;&#125;
 BM68 矩阵的最小路径和
描述	给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。
要求：时间复杂度 O(nm)
例如：当输入[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]时，对应的返回值为12，
所选择的最小累加和路径如下图所示：

class Solution &#123;public:    int minPathSum(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;        int n = matrix.size();        int m = matrix[0].size();          //dp[i][j]表示以当前i，j位置为终点的最短路径长度        vector&lt;vector&lt;int&gt; &gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0));        dp[0][0] = matrix[0][0];        //处理第一列        for(int i = 1; i &lt; n; i++)            dp[i][0] = matrix[i][0] + dp[i - 1][0];        //处理第一行        for(int j = 1; j &lt; m; j++)            dp[0][j] = matrix[0][j] + dp[0][j - 1];        //其他按照公式来        for(int i = 1; i &lt; n; i++)&#123;           for(int j = 1; j &lt; m; j++)&#123;              dp[i][j] = matrix[i][j] + (dp[i - 1][j] &gt; dp[i][j - 1] ? dp[i][j - 1] : dp[i - 1][j]);          &#125;      &#125;       return dp[n - 1][m - 1];    &#125;&#125;;
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据链路层</title>
    <url>/2022/07/29/2022-07-29-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[ 概述
相关术语：

主机和路由器：结点（nodes）
连接相邻结点的通信信道：链路（links）

有线链路（wired links）
无线链路（wireless links）
局域网（LANs）


链路层（第二层）数据分组：帧（frame），封装网络层数据报

数据链路层负责通过一条链路从一个节点向另一个物理链路直接相连的相邻结点传送数据报

 链路层服务


组帧（framing）

封装数据报构成数据帧，加首部和尾部
帧同步



链路接入（link access）

如果是共享介质们需要解决信道接入（channel access）
帧首部中的“MAC”地址，用于表示帧的源和目的

不同于IP地址





相邻结点间的可靠交付

在低误码率的有线链路上很少采用（如：光纤）
无线链路，需要可靠交付



流量控制

协调（pacing）相邻的发送结点和接收



差错检测

信号衰减和噪声会引起差错
接收端检测到差错：

通知发送端重传或者直接丢弃帧





差错纠正

接收端直接纠正比特差错



全双工和半双工通信控制

全双工：链路两端结点同时双向传输
半双工：链路两端结点交替双向传输



 差错编码
 多路访问协议
 MAC
两个或以上结点同时传输时→冲突：结点同时接收两个或多个信号（接受失败）
MAC（mulitple access control protocol）多路访问控制协议


点对点链路

拨号接入PPP
以太网交换机与主机间的点对点链路



广播链路（共享介质）

早期的总线以太网
HFC的上行链路
802.11无线局域网



MAC分类


信道划分（channel partitioning）MAC协议

多路复用技术
TDMA、FDMA、CDMA、WDMA等



随机访问（random access）MAC协议


信道不划分，允许冲突

采用冲突“恢复”机制



轮转MAC协议


结点轮流使用信道




]]></content>
      <categories>
        <category>计网</category>
      </categories>
  </entry>
  <entry>
    <title>Effectivate C++</title>
    <url>/2024/01/16/2024-01-15-C++%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[ Effectivate C++
 习惯C++
 01
视C++为一个语言联邦
次语言:

C语言：以C语言为基础。
Object-Oriented C++：面向对象程序设计
Template C++：泛型编程
STL：程序库

 02
尽量以const, enum, inline替代 #define
#define ASPECT_RATIO 1.653 //避免这种写法const double AspectRatio = 1.653 //替换

对于单纯常量，最好以const对象或enums替换#defines
对于形似函数的宏（macros），最好改用inline函数替换#defines

 03
尽可能使用const
 04
确定对象在被使用前已先被初始化
 C++资源管理
 堆(heap)
在内存管理的语境下，堆——动态分配内存的区域，有别于数据结构的堆
此内存被分配后需要手动释放，否则造成内存泄漏。
自由存储区——free store

特指用new和delete来分配和释放内存区域
new和delete的底层通常使用malloc和free实现

malloc和free的操作区域是heap
 栈(stack)
在内存管理的语境下，栈——函数调用过程中产生的本地变量和调用数据的区域，和数据结构的栈高度类似，满足FIFO。
 RALL
Resource Acquisition Is Initialization——C++是主流编程语言中唯一依赖RALL做资源管理，依托栈和析构函数
在包括 x86 在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。
 重新认识C++
 程序的生命周期
编码(Coding)→预处理(Pre-processing)→编译(Compiling)→运行(Running)
 编码
OpenResty® C 代码风格指南
最基本的要求是遵循语言规范和设计文档，再者还有代码规范、注释规范、设计模式、编程惯用法等
代码风格

空格和空行

留白的艺术——像‘写诗’一样去写代码


起个好名字

变量、函数名和名字空间用 snake_case，全局变量加“g_”前缀；
自定义类名用 CamelCase，成员函数用 snake_case，成员变量加“m_”前缀；
宏和常量应当全大写，单词之间用下划线连接；
尽量不要用下划线作为变量的前缀或者后缀（比如 _local、name_），很难识别;


注释

 预处理
C/C++程序独有。预处理器（Pro-processer）起作用。“预处理”的目的是文字替换，即各种预处理指令，比如 #include、#define、#if 等，实现“预处理编程”。
预处理阶段编程的操作目标是“源码”，用各种指令控制预处理器，把源码
改造成另一种形式，就像是捏橡皮泥一样。

预处理指令都以符号“#”开头
单独的一个“#”也是一个预处理指令，叫“空指令”
“#include”，它的作用是“包含文件”，可以包含任意的文件
使用“#if 1”“#if 0”来显式启用或者禁用大段代码，比“/* …*/”的注释方式安全

 编译
编译和链接。经过编译器和链接器的“锤炼”，生成可在计算机上运行的二进制机器码。编译的过程中，编译器还会根据 C++ 语言规则检查程序的语法、语义是否正确，发现错误就会产生“编译失败”。这是最基本的 C++“静态检查”。
 属性
C++11，标准委员会认识到了“编译指令”的好处，把“民间”用法升级为“官方版本”，起名叫“属性”。可以理解为给变量、函数、类等“贴”上一个编译阶段的“标签”，方便编译器识别处理。
“属性”没有新增关键字，而是用两对方括号形式“[[…]]”，方括号的中间就是属性标签。
[[noreturn]] 	// 属性标签int func(bool flag) // 函数绝不会返回任何值&#123;	throw_std::runtime_error(&quot;XXX&quot;);&#125;
C11 里只定义了两个属性：“noreturn”和“carries_dependency”，它们
基本上没什么大用处。C14 增加了一个比较实用的属性“deprecated”，用来标记不推
荐使用的变量、函数或者类，也就是被“废弃”。
比如，原来写了一个函数 old_func()，后来觉得不够好，就另外重写了一个完全不同的新函数。但是，那个老函数已经发布出去被不少人用了，立即删除不太可能，该怎么办呢？
这个时候，可以让“属性”发挥威力了。你可以给函数加上一个“deprecated”的编译期标签，再加上一些说明文字：
[[deprecated(&quot;deadline:2020-12-31&quot;)]]int old_func();
于是，任何用到这个函数的程序都会在编译时看到这个标签，报出一条警告：
warning: ‘int old_func()’ is deprecated: deadline:2020-12-31 [-Wdeprecated-decl
程序能够正常编译，但这种强制的警告形式会“提醒”用户旧接口已经被废弃了，应该尽快迁移到新接口。这种形式比毫无约束力的文档或者注释要好得多。
 静态断言（static_assert）
static_assert 运行在编译阶段，只能看到编译时的常数和类型，看不到运行时的变量、指针、内存数据等，是“静态”的。
编程范式
编程范式（Paradigm）。“编程范式”是一种“方法论”，就是指导你编写代码的一些思路、规则、习惯、定式和常用语。
 运行
CPU 利用率通常是评价程序运行的好坏最直观、最容易获取的指标，优化它是提升系统性能最快速的手段。
 系统级工具
四个“高性价比”的工具：top、pstack、strace 和 perf。它们用起来很简单，而且实用性很强，可以观测到程序的很多外部参数和内部函数调用，由内而外、由表及里地分析程序性能。
某个进程 CPU 使用率太高，怀疑有问题，那我就要深入进程内部，看看到底是哪些操作消耗了 CPU。这时，我们可以选用两个工具：pstack 和 strace。
pstack 可以打印出进程的调用栈信息，有点像是给正在运行的进程拍了个快照，你能看到某个时刻的进程里调用的函数和关系，对进程的运行有个初步的印象。
pstack 显示的只是进程的一个“静态截面”，信息量还是有点少，而 strace 可以显示出进程的正在运行的系统调用，实时查看进程与系统内核交换了哪些信息。
perf 可以说是 pstack 和 strace 的“高级版”，它按照固定的频率去“采样”，相当于连续执行多次的 pstack，然后再统计函数的调用次数，算出百分比。只要采样的频率足够大，把这些“瞬时截面”组合在一起，就可以得到进程运行时的可信数据，比较全面地描述出 CPU 使用情况。
常用的 perf 命令是“perf top -K -p xxx”，按 CPU 使用率排序，只看用户空间的调用。
 源码级工具
推荐一个专业的源码级性能分析工具：Google Performance Tools，简称为 gperftools。它是一个 C++ 工具集，包含了几个专门的性能分析工具（还有一个高效的内存分配器 tcmalloc），分析效果直观、友好、易理解，被广泛地应用于很多系统，经过了充分的实际验证。
编译运行后会得到一个“case1.perf”的文件，里面就是 gperftools 的分析数据，但它是
二进制的，不能直接查看，如果想要获得可读的信息，需要另外一个工具脚本 pprof。但是，pprof 脚本并不含在 apt-get 的安装包里，所以，你还要从GitHub上下载源码，然后用“–text”选项，就可以输出文本形式的分析报告。pprof 也能输出图形化的分析报告，支持有向图和火焰图，需要你提前安装 Graphviz和 FlameGraph。
 怎样写出“好”的类
 设计思想
抽象（Abstraction）和封装（Encapsulation）
 实现原则

在设计类的时候尽量少用继承和虚函数。
使用特殊标识符“final”可以禁止类被继承，简化类的层次关系。

 编码准则
在必须使用继承的场合，建议你只使用 public 继承，避免使用 virtual、protected
 常用技巧

“委托构造”（delegating constructor）

class DemoDelegating final&#123;private:	int a;	// 成员变量public:	DemoDelegating(int x) : a(x)	// 基本的构造函数&#123;&#125;DemoDelegating() :	// 无参数的构造函数DemoDelegating(0)	// 给出默认值，委托给第一个构造函数&#123;&#125;DemoDelegating(const string&amp; s) : 	// 字符串参数构造函数DemoDelegating(stoi(s))	// 转换成整数，再委托给第一个构造函数&#123;&#125;&#125;;

“成员变量初始化”（In-class member initializer）

class DemoInit final&#123;private:        int	a = 0;        string	s =	&quot;        vector&lt;int&gt;	v&#123;1, 2, 3&#125;; public:	DemoInit() = default;	~DemoInit() = default;public:	DemoInit(int x) : a(x) &#123;&#125;&#125;;

“类型别名”（Type Alias）

using uint_t = unsigned int;	// using别名typedef unsigned int uint_t；    // 等价的typedef
 语言特性
 自动类型推导
关键字 auto

auto 总是推导出“值类型”，绝不会是“引用”；
auto 可以附加上 const、volatile、*、&amp; 这样的类型修饰符，得到新的类型。

auto x = 0L; 	// 自动推导为longauto y = &amp;x; 	// 自动推导为long*auto z &#123;&amp;x&#125;;	 // 自动推导为long*auto err;	// 错误，没有赋值表达式，不知道是什么类型
C++ 的“自动类型推导”还有另外一个关键字：decltype
int x = 0;	// 整型变量decltype(x) x1;	// 推导为int，x1是intdecltype(x)&amp; x2 = x;	 // 推导为int，x2是int&amp;，引用必须赋值decltype(x)* x3;	// 推导为int，x3是int*decltype(&amp;x) x4;	// 推导为int*，x4是int*decltype(&amp;x)* x5;	// 推导为int*，x5是int**decltype(x2) x6 = x2; // 推导为int&amp;，x6是int&amp;，引用必须赋值
decltype 不仅能够推导出值类型，还能够推导出引用类型，也就是表达式的“原始类
型”。
C++14 增加了一个“decltype(auto)”的形式，既可以精确推导类型，又能像
auto 一样方便使用。
int x = 0;	// 整型变量decltype(auto) x1 = (x);	 // 推导为int&amp;，因为(expr)是引用类型decltype(auto) x2 = &amp;x;		 // 推导为int*decltype(auto) x3 = x1; 	// 推导为int&amp;
auto 还有一个“最佳实践”，就是“range-based for”，不需要关心容器元素类型、迭
代器返回值和首末位置，就能非常轻松地完成遍历操作。不过，为了保证效率，最好使
用“const auto&amp;”或者“auto&amp;”。
vector&lt;int&gt; v = &#123;2,3,5,7,11&#125;; 	// vector顺序容器for(const auto&amp; i : v) &#123; 	// 常引用方式访问元素，避免拷贝代价	cout &lt;&lt; i &lt;&lt; &quot;,&quot;;	// 常引用不会改变元素的值&#125;for(auto&amp; i : v) &#123;	// 引用方式访问元素	i++;	// 可以改变元素的值	cout &lt;&lt; i &lt;&lt; &quot;,&quot;;&#125;
 常量/变量
const/volatile/mutable

const

// 需要加上volatile修饰，运行时才能看到效果const volatile int MAX_LEN = 1024;auto ptr = (int*)(&amp;MAX_LEN);*ptr = 2048;cout &lt;&lt; MAXLEN &lt;&lt; endl;	// 输出2048
我从来不用“* const”的形式，也建议你最好不要用，而且这种形式在实际开发时也确实没有多大作用（除非你想“炫技”）。


mutable

用来修饰成员变量，允许 const 成员函数修改，mutable 变量的变化不影响对象的常量性，但要小心不要误用损坏对象。你今后再写类的时候，就要认真想一想，哪些操作改变了内部状态，哪些操作没改变内部状态，对于只读的函数，就要加上 const 修饰。写错了也不用怕，编译器会帮你检查出来。

volatile

它表示变量可能会被“不被察觉”地修改，禁止编译器优化，影响性能，应当少用。
尽可能多用 const，让代码更安全

 智能指针
常用的有两种智能指针，分别是 unique_ptr 和 shared_ptr

unique_ptr

unique_ptr 是最简单、最容易使用的一个智能指针，在声明的时候必须用模板参数指定类型：
unique_ptr&lt;int&gt; ptr1(new int(10));	// int智能指针assert(*ptr1 = 10);	// 可以使用*取内容assert(ptr1 != nullptr);	// 可以判断是否为空指针unique_ptr&lt;string&gt; ptr2(new string(&quot;hello&quot;)); // string智能指针assert(*ptr2 == &quot;hello&quot;);	// 可以使用*取内容assert(ptr2-&gt;size() == 5);	// 可以使用-&gt;调用成员函数
unique_ptr 虽然名字叫指针，用起来也很像，但它实际上并不是指针，而是一个对象。所以，不要企图对它调用 delete，它会自动管理初始化时的指针，在离开作用域时析构释放内存。
它也没有定义加减运算，不能随意移动指针地址，完全避免了指针越界等危险。
未初始化的 unique_ptr 表示空指针，这样就相当于直接操作了空指针，运行时就会产生致命的错误。
为了避免这种低级错误，可以调用工厂函数 make_unique()，强制创建智能指针的时候必须初始化。同时还可以利用自动类型推导 auto，少写一些代码：
auto ptr3 = make_unique&lt;int&gt;(42);	// 工厂函数创建智能指针assert(ptr3 &amp;&amp; *ptr3 == 42);auto ptr4 = make_unique&lt;string&gt;(&quot;god of war&quot;); // 工厂函数创建智能指针assert(!ptr4-&gt;empty());
尽量不要对 unique_ptr 执行赋值操作

shared_ptr

shared_ptr&lt;int&gt; ptr1(new int(10)); 	// int智能指针assert(*ptr1 = 10);// 可以使用*取内容shared_ptr&lt;string&gt; ptr2(new string(&quot;hello&quot;)); 	// string智能指针assert(*ptr2 == &quot;hello&quot;);// 可以使用*取内容auto ptr3 = make_shared&lt;int&gt;(42);	 // 工厂函数创建智能指针assert(ptr3 &amp;&amp; *ptr3 == 42);// 可以判断是否为空指针auto ptr4 = make_shared&lt;string&gt;(&quot;zelda&quot;);	 // 工厂函数创建智能指针assert(!ptr4-&gt;empty());	// 可以使用-&gt;调用成员函数
它的所有权是可以被安全共享的，也就是说支持拷贝赋值。
 Exception

异常的处理流程是完全独立的，throw 抛出异常后就可以不用管了，错误处理代码都集中在专门的 catch 块里。这样就彻底分离了业务逻辑与错误逻辑，看起来更清楚。
异常是绝对不能被忽略的，必须被处理。如果你有意或者无意不写 catch 捕获异常，那么它会一直向上传播出去，直至找到一个能够处理的 catch 块。如果实在没有，那就会导致程序立即停止运行，明白地提示你发生了错误，而不会“坚持带病工作”。
异常可以用在错误码无法使用的场合，这也算是 C++ 的“私人原因”。因为它比 C 语言多了构造 / 析构函数、操作符重载等新特性，有的函数根本就没有返回值，或者返回值无法表示错误，而全局的 errno 实在是“太不优雅”了，与 C++ 的理念不符，所以也必须使用异常来报告错误。

 函数式编程 lambda
auto func = [](int x)	// 定义一个lambda表达式&#123;	cout &lt;&lt; x*x &lt;&lt; endl;	// lambda表达式的具体内容&#125;;func(3);// 调用lambda表达式
lambda 表达式除了可以像普通函数那样被调用，还有一个普通函数所不具备的特殊本领，就是可以“捕获”外部变量，在内部的代码里直接操作。
int n = 10;	// 一个外部变量auto func = [=](int x)	// lambda表达式，用“=”值捕获&#123;	cout &lt;&lt; x*n &lt;&lt; endl;	// 直接操作外部变量&#125;;func(3);	// 调用lambda表达式
C++ 没有为 lambda 表达式引入新的关键字，并没有“lambda”这样的词汇，而是用了一个特殊的形式“[]”，术语叫“lambda 引出符”（lambda introducer）。在 lambda 引出符后面，就可以像普通函数那样，用圆括号声明入口参数，用花括号定义函数体。
 标准库
 字符串


字面量后缀
using namespace std::literals::string_literals; 	//必须打开名字空间auto str = &quot;std string&quot;s;	// 后缀s，表示是标准字符串，直接类型推导


原始字符串
auto str = R&quot;(nier:automata)&quot;; 	// 原始字符串：nier:automata


字符串转换函数
assert(stoi(&quot;42&quot;) == 42);	// 字符串转整数assert(stol(&quot;253&quot;) == 253L);	// 字符串转长整数assert(stod(&quot;2.0&quot;) == 2.0);	// 字符串转浮点数


字符串视图类


正则表达式
C++ 正则表达式主要有两个类。

regex：表示一个正则表达式，是 basic_regex 的特化形式；
smatch：表示正则表达式的匹配结果，是 match_results 的特化形式。

C++ 正则匹配有三个算法，注意它们都是“只读”的，不会变动原字符串。

regex_match()：完全匹配一个字符串；
regex_search()：在字符串里查找一个正则匹配；
regex_replace()：正则查找再做替换。

 容器
容器，就是能够“容纳”“存放”元素的一些数据结构。
容器里存储的是元素的拷贝、副本，而不是引用。

顺序容器

即数据结构里的线性表，一共有 5 种：array、vector、deque、list、forward_list
连续存储的数组：array、vector 和 deque。

array 和 vector 直接对应 C 的内置数组，内存布局与 C 完全兼容，所以是开销最低、速度最快的容器。区别在于，array 是静态数组，而 vector 是动态数组。
deque 也是动态数组，它可以在两端高效地插入删除元素，这也是它的名字double-end queue 的来历，而 vector 则只能用 push_back 在末端追加元素。


指针结构的链表：list 和 forward_list

list 是双向链表，而 forward_list是单向链表。




有序容器

C++ 的有序容器使用的是树结构，通常是红黑树——有着最好查找性能的二叉树。
标准库里一共有四种有序容器：set/multiset 和 map/multimap。set 是集合，map 是关联数组（在其他语言里也叫“字典”）。
有 multi 前缀的容器表示可以容纳重复的 key，内部结构与无前缀的相同，所以也可以认为只有两种有序容器。
集合关系就用 set，关联数组就用 map。


无序容器

unordered_set/unordered_multiset、unordered_map/unordered_multimap。
内部数据结构不是红黑树，而是散列表（也叫哈希表，hash table）
如果只想要单纯的集合、字典，没有排序需求，就应该用无序容器，没有比较排序的成本，它的速度就会非常快。



 算法
迭代器
array&lt;int, 5&gt; arr = &#123;0,1,2,3,4&#125;; 	// array静态数组容器auto b = begin(arr);	// 全局函数获取迭代器，首端auto e = end(arr);	// 全局函数获取迭代器，末端assert(distance(b, e) == 5);	 // 迭代器的距离auto p = next(b);	// 获取“下一个”位置assert(distance(b, p) == 1);	 // 迭代器的距离assert(distance(p, b) == -1);	 // 反向计算迭代器的距离advance(p, 2);	// 迭代器前进两个位置，指向元素&#x27;3&#x27;assert(*p == 3);assert(p == prev(e, 2)); 	// 是末端迭代器的前两个位置
for_each()
vector&lt;int&gt; v = &#123;3,5,1,7,10&#125;; 	// vector容器for(const auto&amp; x : v) &#123;	// range for循环	cout &lt;&lt; x &lt;&lt; &quot;,&quot;;&#125;auto print = [](const auto&amp; x) 	// 定义一个lambda表达式&#123;	cout &lt;&lt; x &lt;&lt; &quot;,&quot;;&#125;;for_each(cbegin(v), cend(v), print);	// for_each算法for_each(	// for_each算法，内部定义lambda表达式	cbegin(v), cend(v),	// 获取常量迭代器	[](const auto&amp; x)	// 匿名lambda表达式	&#123;		cout &lt;&lt; x &lt;&lt; &quot;,&quot;;	&#125;);
排序

常见问题对应的算法：

要求排序后仍然保持元素的相对顺序，应该用 stable_sort，它是稳定的；
选出前几名（TopN），应该用 partial_sort；
选出前几名，但不要求再排出名次（BestN），应该用 nth_element；
中位数（Median）、百分位数（Percentile），还是用 nth_element；
按照某种规则把元素划分成两组，用 partition；
第一名和最后一名，用 minmax_element。




查找
 并发
“读而不写”就不会有数据竞争。

多线程是并发最常用的实现方式，好处是任务并行、避免阻塞，坏处是开发难度高，有数据竞争、死锁等很多“坑”；
call_once() 实现了仅调用一次的功能，避免多线程初始化时的冲突；
thread_local 实现了线程局部存储，让每个线程都独立访问数据，互不干扰；
atomic 实现了原子化变量，可以用作线程安全的计数器，也可以实现无锁数据结构；
async() 启动一个异步任务，相当于开了一个线程，但内部通常会有优化，比直接使用线程更好。

 技能进阶
 序列化/反序列化
 JSON
JSON 是一种轻量级的数据交换格式，采用纯文本表示，所以是“human readable”，阅
读和修改都很方便。
JSON for Modern C++ 可能不是最小最快的 JSON 解析工具，但功能足够完善，而且使
用方便，仅需要包含一个头文件“json.hpp”，没有外部依赖，也不需要额外的安装、编
译、链接工作，适合快速上手开发。
git clone git@github.com:nlohmann/json.git # git clonewget https://github.com/nlohmann/json/releases/download/v3.7.3/json.hpp
 MessagePack
它也是一种轻量级的数据交换格式，与 JSON 的不同之处在于它不是纯文本，而是二进制。由于二进制这个特点，MessagePack 也得到了广泛的应用，著名的有 Redis、Pinterest。
git clone git@github.com:msgpack/msgpack-c.gitg++ msgpack.cpp -std=c++14 -I../common/include -o a.out
 ProtoBuffer
通常简称为 PB，由 Google 出品。PB 也是一种二进制的数据格式，但毕竟是工业级产品，所以没有 JSON 和 MessagePack那么“轻”，相关的东西比较多，要安装一个预处理器和开发库，编译时还要链接动态库（-lprotobuf）：
apt-get install protobuf-compilerapt-get install libprotobuf-devg++ protobuf.cpp -std=c++14 -lprotobuf -o a.out
PB 的另一个特点是数据有“模式”（schema），必须要先写一个 IDL（Interface Description Language）文件，定义好数据结构，只有预先定义了的数据结构，才能被序列化和反序列化。
 网络通信
libcurl：高可移植、功能丰富的通信库
cpr：更现代、更易用的通信库
cpr 是对 libcurl 的一个 C11 封装，使用了很多现代 C 的高级特性，对外的接口模仿了 Python 的 requests 库，非常简单易用。
git clone git@github.com:whoshuu/cpr.gitcmake . -DUSE_SYSTEM_CURL=ON -DBUILD_CPRmake &amp;&amp; make install
ZMQ：高效、快速、多功能的通信库
作为消息队列，ZMQ 的另一大特点是零配置零维护零成本，不需要搭建额外的代理服务器，只要安装了开发库就能够直接使用，相当于把消息队列功能直接嵌入到你的应用程序里：
apt-get install libzmq3-dev
ZMQ 是一个高级的网络通信库，支持多种通信模式，可以把消息队列功能直接嵌入应用程序，搭建出高效、灵活、免管理的分布式系统。
 脚本语言
 Python
pybind11 完全基于现代 C++ 开发（C11 以上），所以没有兼容旧系统的负担。它使用了大量的现代 C 特性，不仅代码干净整齐，运行效率也更高。
pybind11 支持 Python2.7、Python3 和 PyPy，这里我用的是 Python3：
apt-get install python3-devapt-get install python3-pippip3 install pybind11
 Lua
第二个脚本语言是小巧高效的 Lua，号称是“最快的脚本语言”。
git clone git@github.com:openresty/luajit2.gitmake &amp;&amp; make install
 总结
 设计模式
常用有 5 个原则，也就是常说的“SOLID”。

SRP，单一职责（Single ResponsibilityPrinciple）；
OCP，开闭（Open Closed Principle）；
LSP，里氏替换（Liskov Substitution Principle）；
ISP，接口隔离（Interface-Segregation Principle）；
DIP，依赖反转，有的时候也叫依赖倒置（Dependency Inversion Principle）。

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2023/06/06/2023-06-06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[ 数据结构
 线性表
 链表
// define element typetypedef int ElemType;// define struct of linked listtypedef struct LNode &#123;    ElemType data;    struct LNode *next;&#125; LNode, *LinkList;// define Statustypedef enum Status &#123;    ERROR,    SUCCESS&#125; Status;LinkList CreateList_Head(LinkList &amp;L)&#123;    LNode *s;    int x;    L = (LinkList)malloc(sizeof(LNode));     //创建头结点    L-&gt;next  =NULL;    scanf(&quot;%d&quot;,&amp;x);    while(x!=9999)&#123;        s=(LNode*)malloc(sizeof(LNode));        s-&gt;data=x;        s-&gt;next=L-&gt;next;        L-&gt;next=s;                          //插入结点        scanf(&quot;%d&quot;,&amp;x);    &#125;    return L;&#125;void TraverseList(LinkList L)&#123;    LNode *p = L-&gt;next;    while(p)&#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot; ;        p = p-&gt;next;    &#125;&#125;int main()&#123;    LinkList L;    L = new LNode;    CreateList_Head(L);    TraverseList(L);    return 0;&#125;
 栈
#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1#define STACKSIZE 10;              //存储空间分配增量#define STACK_INIT_SIZE 100;    //存储空间初始分配量typedef int ElemType;typedef int Status;typedef struct&#123;    ElemType* base;    //栈底    ElemType* top;     //栈顶    int stacksize;          //当前已分配的空间&#125;SqStack;//初始化栈Status initStack(SqStack &amp;S)&#123;    S.base = (ElemType *)malloc(100 * sizeof(ElemType));    if (!S.base)&#123;        exit(0);    &#125;    S.top = S.base;    S.stacksize = 100;    return OK;&#125;//入栈Status Push(SqStack&amp; S, ElemType e)&#123;    if (S.top - S.base &gt;= S.stacksize)   //如果栈满就追加空间    &#123;                           //新增内存空间        S.base = (ElemType*)realloc(S.base, (S.stacksize + 10) * sizeof(ElemType));        if (!S.base) exit(0);        S.top = S.base + S.stacksize;        S.stacksize += 10;    &#125;    *S.top++ = e;    return OK;&#125;//出栈Status Pop(SqStack&amp; S, ElemType &amp;e)&#123;    if (S.top == S.base) return ERROR;    e = *--S.top;    return OK;&#125;
 队列

根据存储结构划分：1.链式队列	2.循环队列	3.单向队列	4.双端队列

 顺序队列
#define MAXSIZE 1000typedef struct &#123;    int data[MAXSIZE];    int front,rear;&#125;Sequeue;void SequeueInit(Sequeue &amp;Top)&#123;//队列的初始化    Top.front=0;    Top.rear=0;&#125;void SequeueEmpty(Sequeue &amp;Top)&#123;//判队列为空    if(Top.rear==Top.front)    &#123;        printf(&quot;队列为空\n&quot;);    &#125;    else  printf(&quot;队列不为空\n&quot;);&#125;void SequeuePush(Sequeue &amp;Top,int m)&#123;//循环入队列   if((Top.rear+1)%MAXSIZE==Top.front)        &#123;printf(&quot;队列已满&quot;);&#125;   else&#123;       Top.data[Top.rear]=m;       printf(&quot;%d已入队\n&quot;,m);       Top.rear=(Top.rear+1)%MAXSIZE;&#125;&#125;void SequeueTop(Sequeue &amp;Top)//求队列头部元素&#123;    printf(&quot;队列头部元素为%d\n&quot;,Top.data[Top.front]);&#125;void SequeuePop(Sequeue &amp;Top)&#123;//循环出队列    int i=0;    if(Top.rear==Top.front)     &#123;printf(&quot;队列为空&quot;);&#125;    else&#123;        while (Top.rear!=Top.front) &#123;            i++;            printf(&quot;队第%d元素为%d\n&quot;,i,Top.data[Top.front]);            Top.front=(Top.front+1)%MAXSIZE;        &#125;    &#125;&#125;int SequeueTopp(Sequeue &amp;Top)//求队列头部元素( 返回值)&#123;    return Top.data[Top.front];&#125;void SequeuePushh(Sequeue &amp;Top,int m)&#123;//不循环入队列    Top.data[Top.rear]=m;    Top.rear++;&#125;int  SequeuePopp(Sequeue &amp;Top)&#123;//不循环出队列    int m=Top.data[Top.front];        Top.front++;        return m;&#125;
 循环队列
 数组
 动态数组
 树和二叉树
 二叉树

C++：nullptr 专用于初始化空类型指针

#include&lt;iostream&gt;using namespace std;template&lt;typename DataType&gt;struct BiNode&#123;    DataType data;    BiNode *lchild, *rchild;&#125;;template&lt;typename DataType&gt;class BiTree&#123;public:    BiTree( )&#123;        root = Creat(root);	//构造函数，建立二叉树    &#125;    ~BiTree( )&#123;        Release(root);   //析构函数，释放各结点的存储空间    &#125;    void PreOrder( )&#123;        PreOrder(root);   //前序遍历二叉树    &#125;    void InOrder( )&#123;        InOrder(root);   //中序遍历二叉树    &#125;    void PostOrder( )&#123;        PostOrder(root);   //后序遍历二叉树    &#125;    void LeverOrder( ); //层序遍历二叉树private:    BiNode &lt;DataType&gt;*Creat(BiNode&lt;DataType&gt; *bt); //构造函数    void Release(BiNode&lt;DataType&gt; *bt); 		  //析构函数调用    void PreOrder(BiNode&lt;DataType&gt; *bt); 		  //前序遍历函数    void InOrder(BiNode&lt;DataType&gt; *bt); 		  //中序遍历函数    void PostOrder(BiNode&lt;DataType&gt; *bt); 		  //后序遍历函数    BiNode&lt;DataType&gt; *root;					     //指向根结点的头指针&#125;;template&lt;typename DataType&gt;BiNode&lt;DataType&gt; *BiTree &lt;DataType&gt;:: Creat(BiNode&lt;DataType&gt; *bt)&#123;    char ch;    cout &lt;&lt; &quot;请输入扩展二叉树的前序遍历序列，每次输入一个字符:&quot;;    cin &gt;&gt; ch; //输入结点的数据信息，假设为字符    if (ch == &#x27;#&#x27;) bt = nullptr; //建立一棵空树    else    &#123;        bt = new BiNode&lt;DataType&gt;;        bt-&gt;data = ch;        bt-&gt;lchild = Creat(bt-&gt;lchild); //递归建立左子树        bt-&gt;rchild = Creat(bt-&gt;rchild); //递归建立右子树    &#125;    return bt;&#125;template&lt;typename DataType&gt;	//前序遍历void BiTree&lt;DataType&gt;:: PreOrder(BiNode&lt;DataType&gt; *bt)&#123;    if (bt == nullptr) return;     cout &lt;&lt; bt-&gt;data; 	      PreOrder(bt-&gt;lchild);     PreOrder(bt-&gt;rchild); &#125;template&lt;typename DataType&gt;	//中序遍历void BiTree&lt;DataType&gt;:: InOrder(BiNode&lt;DataType&gt; *bt)&#123;    if (bt == nullptr) return;     else    &#123;        InOrder(bt-&gt;lchild);         cout &lt;&lt; bt-&gt;data;         InOrder(bt-&gt;rchild);    &#125;&#125;template&lt;typename DataType&gt;	//后序遍历void BiTree&lt;DataType&gt;:: PostOrder(BiNode&lt;DataType&gt; *bt)&#123;    if (bt == nullptr) return;    else    &#123;        InOrder(bt-&gt;lchild);        InOrder(bt-&gt;rchild);        cout &lt;&lt; bt-&gt;data;    &#125;&#125;template&lt;typename DataType&gt;	//层次遍历void BiTree&lt;DataType&gt;:: LeverOrder( )&#123;    BiNode&lt;DataType&gt; *Q[100], *q = nullptr; //顺序队列    int front = -1, rear = -1; //队列初始化    if (root == nullptr) return; //二叉树为空，算法结束    Q[++rear] = root; //根指针入队    while (front != rear) //当队列非空时    &#123;        q = Q[++front]; //出队        cout &lt;&lt; q-&gt;data;        if (q-&gt;lchild != nullptr) Q[++rear] = q-&gt;lchild;        if (q-&gt;rchild != nullptr) Q[++rear] = q-&gt;rchild;    &#125;&#125;template&lt;typename DataType&gt;void BiTree&lt;DataType&gt;:: Release(BiNode&lt;DataType&gt; *bt)&#123;    if (bt == nullptr) return;    else    &#123;        Release(bt-&gt;lchild); //释放左子树        Release(bt-&gt;rchild); //释放右子树        delete bt; //释放根结点    &#125;&#125;
 层序遍历
class Solution &#123;public:    vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt; &gt; res;        if(root == NULL)	//如果是空，则直接返回空vector            return res;         queue&lt;TreeNode*&gt; q; 	//队列存储，进行层次遍历        q.push(root);        TreeNode* cur;        while(!q.empty())&#123;            //记录二叉树的某一行            vector&lt;int&gt; row;              int n = q.size();            //因先进入的是根节点，故每层节点多少，队列大小就是多少            for(int i = 0; i &lt; n; i++)&#123;                cur = q.front();                q.pop();                row.push_back(cur-&gt;val);                //若是左右孩子存在，则存入左右孩子作为下一个层次                if(cur-&gt;left)                    q.push(cur-&gt;left);                if(cur-&gt;right)                    q.push(cur-&gt;right);            &#125;            //每一层加入输出            res.push_back(row);         &#125;        return res;    &#125;&#125;;
 AVL Tree

AVL树（Adelson-Velsky and Landis Tree）是CS中最早被发明的自平衡二叉查找树。

一棵AVL树有如下必要条件：

必须是二叉查找树
每个节点的左子树和右子树的高度差至多为1

AVL Tree Visualzation 可视化演示
struct AVLnode&#123;    int key;    //值    struct AVLnode *left;    struct AVLnode *right;    int height;     //高度&#125;;void printAVL(avlNode *node, int level)	//树尖向左打印&#123;    int i;    if (node != NULL)    &#123;        printAVL(node-&gt;right, level + 1);        printf(&quot;\n\n&quot;);        for (i = 0; i &lt; level; i++) printf(&quot;\t&quot;);        printf(&quot;%d&quot;, node-&gt;key);        printAVL(node-&gt;left, level + 1);    &#125;&#125;
 平衡化操作
平衡二叉树 — 优雅的进行旋转
 LL型

avlNode *rightRotate(avlNode *T)&#123;    avlNode *L = T-&gt;left;    avlNode *T3 = L-&gt;right;    L-&gt;right = T;    T-&gt;left = T3;    T-&gt;height = (Max(nodeHeight(T-&gt;left), nodeHeight(T-&gt;right)) + 1);    L-&gt;height = (Max(nodeHeight(L-&gt;left), nodeHeight(L-&gt;right)) + 1);    return L;&#125;
 RR型

avlNode *leftRotate(avlNode *T)&#123;    avlNode *R= T-&gt;right;    avlNode *T3 = R-&gt;left;    R-&gt;left = z;    T-&gt;right = T3;    T-&gt;height = (Max(nodeHeight(T-&gt;left), nodeHeight(T-&gt;right)) + 1);    R-&gt;height = (Max(nodeHeight(R-&gt;left), nodeHeight(R-&gt;right)) + 1);    return R;&#125;
 LR型

avlNode *LeftRightRotate(avlNode *z)&#123;    T-&gt;left = leftRotate(T-&gt;left);    return (rightRotate(T));&#125;
 RL型

avlNode *RightLeftRotate(avlNode *T)&#123;    T-&gt;right = rightRotate(T-&gt;right);    return (leftRotate(T));&#125;
 二叉查找树

​		二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree）。

一棵空树或者具有下列性质的二叉树：

若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若任意结点的右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
任意结点的左、右子树也分别为二叉查找树

typedef struct node&#123;     int data;    struct node *left;    struct node *right;&#125; node;
 红黑树

红黑树（Red Black Tree） 是一种自平衡二叉查找树

红黑树满足以下特征：

节点分为红色或者黑色；
根节点必为黑色；
叶子节点都为黑色，且为null；
连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）；
从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点；
新加入到红黑树的节点为红色节点；(推断)

类比234树——4阶B树
 图
 邻接表
#include&lt;iostream&gt;using namespace std;struct EdgeNode //定义边表结点&#123;    int adjvex; //邻接点域    EdgeNode *next;&#125;;template &lt;typename DataType&gt;struct VertexNode //定义顶点表结点&#123;    DataType vertex;    EdgeNode *firstEdge;&#125;;const int MaxSize = 10; //图的最多顶点数int visited[MaxSize] = &#123;0&#125;;template  &lt;typename DataType&gt;class ALGraph&#123;public:    ALGraph(DataType a[ ], int n, int e); //构造函数，建立n个顶点e条边的图    ~ALGraph( ); //析构函数，释放邻接表各边表结点的存储空间    void DFTraverse(int v); //深度优先遍历图    void BFTraverse(int v); //广度优先遍历图private:    VertexNode&lt;DataType&gt; adjlist[MaxSize]; //存放顶点表的数组    int vertexNum, edgeNum; //图的顶点数和边数&#125;;template &lt;typename DataType&gt;ALGraph&lt;DataType&gt; :: ALGraph(DataType a[ ], int n, int e)&#123;    int i, j, k;    EdgeNode *s = nullptr;    vertexNum = n;    edgeNum = e;    for (i = 0; i &lt; vertexNum; i++) //输入顶点信息，初始化顶点表    &#123;        adjlist[i].vertex = a[i];        adjlist[i].firstEdge = NULL;    &#125;    for (k = 0; k &lt; edgeNum; k++) //依次输入每一条边    &#123;        cout &lt;&lt; &quot;输入边所依附的两个顶点的编号：&quot;;        cin &gt;&gt; i &gt;&gt; j; //输入边所依附的两个顶点的编号        s = new EdgeNode;        s-&gt;adjvex = j; //生成一个边表结点s        s-&gt;next = adjlist[i].firstEdge; //将结点s插入到第i个边表的表头        adjlist[i].firstEdge = s;    &#125;&#125;template &lt;typename DataType&gt;ALGraph&lt;DataType&gt;  :: ~ALGraph( )&#123;    EdgeNode *p = NULL, *q = NULL;    for (int i = 0; i &lt; vertexNum; i++)    &#123;        p = q = adjlist[i].firstEdge;        while (p != NULL)        &#123;            p = p-&gt;next;            delete q;            q = p;        &#125;    &#125;&#125;template  &lt;typename DataType&gt;void ALGraph&lt;DataType&gt;  :: DFTraverse(int v)&#123;    int j;    EdgeNode *p = NULL;    cout &lt;&lt; adjlist[v].vertex;    visited[v] = 1;    p = adjlist[v].firstEdge; //工作指针p指向顶点v的边表    while (p != NULL) //依次搜索顶点v的邻接点    &#123;        j = p-&gt;adjvex;        if (visited[j] == 0) DFTraverse(j);        p = p-&gt;next;    &#125;&#125;template &lt;typename DataType&gt;void ALGraph&lt;DataType&gt; :: BFTraverse(int v)&#123;    int w, j, Q[MaxSize]; //采用顺序队列    int front = -1, rear = -1; //初始化队列    EdgeNode *p = nullptr;    cout &lt;&lt; adjlist[v].vertex;    visited[v] = 1;    Q[++rear] = v; //被访问顶点入队    while (front != rear) //当队列非空时    &#123;        w = Q[++front];        p = adjlist[w].firstEdge; //工作指针p指向顶点v的边表        while (p != NULL)        &#123;            j = p-&gt;adjvex;            if (visited[j] == 0)            &#123;                cout &lt;&lt; adjlist[j].vertex;                visited[j] = 1;                Q[++rear] = j;            &#125;            p = p-&gt;next;        &#125;    &#125;&#125;int main( )&#123;//测试数据是图6-20(a)，边是(0 1)(0 3)(0 4)(1 2)(2 4)(3 2)(3 4)    char ch[ ] = &#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;&#125;;    int i;    ALGraph&lt;char&gt; ALG(ch, 5, 6); //建立具有5个顶点6条边的有向图    for (i = 0; i &lt; MaxSize; i++)        visited[i] = 0;    cout &lt;&lt; &quot;深度优先遍历序列是：&quot;;    ALG.DFTraverse(0); //从顶点0出发进行深度优先遍历    for (i = 0; i &lt; MaxSize; i++)        visited[i] = 0;    cout &lt;&lt; &quot;广度优先遍历序列是：&quot;;    ALG.BFTraverse(0); //从顶点0出发进行广度优先遍历    return 0;&#125;
 邻接矩阵
/************************************************邻接矩阵类MGraph的使用范例*************************************************/#include&lt;iostream&gt;using namespace std;const int MaxSize = 10; //图中最多顶点个数int visited[MaxSize] = &#123;0&#125;; //全局数组变量visited初始化template &lt;typename DataType&gt;class MGraph&#123;public:    MGraph(DataType a[ ], int n, int e); //构造函数，建立具有n个顶点e条边的图    ~MGraph( ) &#123; &#125;; //析构函数    void DFTraverse(int v); //深度优先遍历图    void BFTraverse(int v); //广度优先遍历图private:    DataType vertex[MaxSize]; //存放图中顶点的数组    int edge[MaxSize][MaxSize]; //存放图中边的数组    int vertexNum, edgeNum; //图的顶点数和边数&#125;;template&lt;typename DataType&gt;MGraph &lt;DataType&gt;:: MGraph(DataType a[ ], int n, int e)&#123;    int i, j, k;    vertexNum = n;    edgeNum = e;    for (i = 0; i &lt; vertexNum; i++) //存储顶点        vertex[i] = a[i];    for (i = 0; i &lt; vertexNum; i++) //初始化邻接矩阵        for (j = 0; j &lt; vertexNum; j++)            edge[i][j] = 0;    for (k = 0; k &lt; edgeNum; k++) //依次输入每一条边    &#123;        cout &lt;&lt; &quot;请输入边依附的两个顶点的编号：&quot;;        cin &gt;&gt; i &gt;&gt; j; //输入边依附的两个顶点的编号        edge[i][j] = 1;        edge[j][i] = 1; //置有边标志    &#125;&#125;template&lt;typename DataType&gt;void MGraph &lt;DataType&gt;:: DFTraverse(int v)&#123;    cout &lt;&lt; vertex[v];    visited[v] = 1;    for (int j = 0; j &lt; vertexNum; j++)        if (edge[v][j] == 1 &amp;&amp; visited[j] == 0) DFTraverse( j );&#125;template&lt;typename DataType&gt;void MGraph &lt;DataType&gt;:: BFTraverse(int v)&#123;    int w, j, Q[MaxSize]; //采用顺序队列    int front = -1, rear = -1; //初始化队列    cout &lt;&lt; vertex[v];    visited[v] = 1;    Q[++rear] = v; //被访问顶点入队    while (front != rear) //当队列非空时    &#123;        w = Q[++front]; //将队头元素出队并送到v中        for (j = 0; j &lt; vertexNum; j++)            if (edge[w][j] == 1 &amp;&amp; visited[j] == 0 )            &#123;                cout &lt;&lt; vertex[j];                visited[j] = 1;                Q[++rear] = j;            &#125;    &#125;&#125;int main( )&#123;    int i;    char ch[ ]= &#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;&#125;;    /* 测试数据六条边是：(0 1)(0 2)(0 3)(0 4)(1 2)(2 4) */    MGraph&lt;char&gt; MG&#123;ch, 5, 6&#125;; //建立具有5个顶点6条边的无向图    for (i = 0; i &lt; MaxSize; i++)        visited[i] = 0;    cout &lt;&lt; &quot;深度优先遍历序列是：&quot; &lt;&lt; endl;    MG.DFTraverse(0); //从顶点0出发进行深度优先遍历    for (i = 0; i &lt; MaxSize; i++)        visited[i] = 0;    cout &lt;&lt; &quot;广度优先遍历序列是：&quot; &lt;&lt; endl;    MG.BFTraverse(0); //从顶点0出发进行广度优先遍历    return 0;&#125;
 字典
 排序
经典排序算法

 Bubble sort
include &lt;iostream&gt;using namespace std;template&lt;typename T&gt; //整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符void bubble_sort(T arr[], int len) &#123;        int i, j;        for (i = 0; i &lt; len - 1; i++)                for (j = 0; j &lt; len - 1 - i; j++)                        if (arr[j] &gt; arr[j + 1])                                swap(arr[j], arr[j + 1]);&#125;int main() &#123;        int arr[] = &#123; 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 &#125;;        int len = (int) sizeof(arr) / sizeof(*arr);        bubble_sort(arr, len);        for (int i = 0; i &lt; len; i++)                cout &lt;&lt; arr[i] &lt;&lt; &#x27; &#x27;;        cout &lt;&lt; endl;        float arrf[] = &#123; 17.5, 19.1, 0.6, 1.9, 10.5, 12.4, 3.8, 19.7, 1.5, 25.4, 28.6, 4.4, 23.8, 5.4 &#125;;        len = (float) sizeof(arrf) / sizeof(*arrf);        bubble_sort(arrf, len);        for (int i = 0; i &lt; len; i++)                cout &lt;&lt; arrf[i] &lt;&lt; &#x27; &#x27;&lt;&lt;endl;        return 0;&#125;
 Selection sort
Selection sort is a simple and intuitive sorting algorithm that is O(n²) time complex no matter what data goes in. So when using it, the smaller the data size, the better. The only advantage is that it doesn’t take up extra memory space.
算法步骤

First, find the smallest (large) element in the unsorted sequence and store it at the beginning of the sorted sequence.
Then find the smallest (large) element from the remaining unsorted elements and put it at the end of the sorted sequence.
Repeat the second step until all elements are sorted.

template&lt;typename T&gt;void selection_sort(vector&lt;T&gt;&amp; arr) &#123;    for (int i = 0; i &lt; arr.size() - 1; i++) &#123;        int min = i;        for (int j = i + 1; j &lt; arr.size(); j++)            if (arr[j] &lt; arr[min])                min = j;        swap(arr[i], arr[min]);    &#125;&#125;
 Insertion sort
The code implementation of insertion sort is not as simple and brutal as bubble sort and selection sort, but its principle should be the easiest to understand, because anyone who has played poker should be able to understand it in seconds. Insertion sort is one of the simplest and most intuitive sorting algorithms. It works by constructing an ordered sequence, and for unsorted data, scanning backward and forward in the sorted sequence to find the appropriate position and insert it.
Insertion sort, like bubble sort, also has an optimization algorithm called split-half insertion.
void insertion_sort(int arr[],int len)&#123;    for(int i=1;i&lt;len;i++)&#123;        int key=arr[i];        int j=i-1;        while((j&gt;=0) &amp;&amp; (key&lt;arr[j]))&#123;            arr[j+1]=arr[j];            j--;        &#125;        arr[j+1]=key;    &#125;&#125;
 Shell sort
template&lt;typename T&gt;void shell_sort(T array[], int length) &#123;    int h = 1;    while (h &lt; length / 3) &#123;        h = 3 * h + 1;    &#125;    while (h &gt;= 1) &#123;        for (int i = h; i &lt; length; i++) &#123;            for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123;                swap(array[j], array[j - h]);            &#125;        &#125;        h = h / 3;    &#125;&#125;
 Merge sort
// 迭代版template&lt;typename T&gt;void merge_sort(T arr[], int len) &#123;    T *a = arr;    T *b = new T[len];    for (int seg = 1; seg &lt; len; seg += seg) &#123;        for (int start = 0; start &lt; len; start += seg + seg) &#123;            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);            int k = low;            int start1 = low, end1 = mid;            int start2 = mid, end2 = high;            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            while (start1 &lt; end1)                b[k++] = a[start1++];            while (start2 &lt; end2)                b[k++] = a[start2++];        &#125;        T *temp = a;        a = b;        b = temp;    &#125;    if (a != arr) &#123;        for (int i = 0; i &lt; len; i++)            b[i] = a[i];        b = a;    &#125;    delete[] b;&#125;//递归版void Merge(vector&lt;int&gt; &amp;Array, int front, int mid, int end) &#123;    // preconditions:    // Array[front...mid] is sorted    // Array[mid+1 ... end] is sorted    // Copy Array[front ... mid] to LeftSubArray    // Copy Array[mid+1 ... end] to RightSubArray    vector&lt;int&gt; LeftSubArray(Array.begin() + front, Array.begin() + mid + 1);    vector&lt;int&gt; RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);    int idxLeft = 0, idxRight = 0;    LeftSubArray.insert(LeftSubArray.end(), numeric_limits&lt;int&gt;::max());    RightSubArray.insert(RightSubArray.end(), numeric_limits&lt;int&gt;::max());    // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]    for (int i = front; i &lt;= end; i++) &#123;        if (LeftSubArray[idxLeft] &lt; RightSubArray[idxRight]) &#123;            Array[i] = LeftSubArray[idxLeft];            idxLeft++;        &#125; else &#123;            Array[i] = RightSubArray[idxRight];            idxRight++;        &#125;    &#125;&#125;void MergeSort(vector&lt;int&gt; &amp;Array, int front, int end) &#123;    if (front &gt;= end)        return;    int mid = (front + end) / 2;    MergeSort(Array, front, mid);    MergeSort(Array, mid + 1, end);    Merge(Array, front, mid, end);&#125;
 Quick sort
template &lt;typename T&gt;void quick_sort_recursive(T arr[], int start, int end) &#123;    if (start &gt;= end)        return;    T mid = arr[end];    int left = start, right = end - 1;    while (left &lt; right) &#123; //在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换        while (arr[left] &lt; mid &amp;&amp; left &lt; right) //试图在左侧找到一个比枢纽元更大的元素            left++;        while (arr[right] &gt;= mid &amp;&amp; left &lt; right) //试图在右侧找到一个比枢纽元更小的元素            right--;        std::swap(arr[left], arr[right]); //交换元素    &#125;    if (arr[left] &gt;= arr[end])        std::swap(arr[left], arr[end]);    else        left++;    quick_sort_recursive(arr, start, left - 1);    quick_sort_recursive(arr, left + 1, end);&#125;template &lt;typename T&gt;void quick_sort(T arr[], int len) &#123;    quick_sort_recursive(arr, 0, len - 1);&#125;
 Time complexity
​		During the partition process, both the head and tail pointers are scanned cyclically to the last position where the base value was placed. Thus, the head and tail pointer scans together are equivalent to scanning the entire region of the array to be sorted. Therefore, we can conclude that the time complexity of a single partition operation is O(n). The formula for the overall time complexity: T(n) = n + T(L) + T®.

Time complexity：O(nlog⁡2n)O(n\log_{2}{n})O(nlog2​n)
 Optimization
 One-sided recursive optimization
​		Mode：when this layer has finished the partition operation, let this layer continue to complete the partition operation to the left of the base value, while the sorting work to the right of the base value is left to the next layer of recursive functions to handle.

function is called 4 times.
Without the method, the actual number is 7.
void quick_sort(int *arr, int l, int r) &#123;    while (l &lt; r) &#123;        // 进行一轮 partition 操作        // 获得基准值的位置        int ind = partition(arr, l, r);        // 右侧正常调用递归函数         quick_sort(arr, ind + 1, r);        // 用本层处理左侧的排序        r = ind - 1;    &#125;    return ;&#125;
 Optimization of benchmark value selection
three-point middle method is to take the three values of the head, tail and middle elements of the sorting interval in each round, and then use the middle value after they are sorted as the base value for the current round.For example, suppose the three values of this round are 2, 9 and 7, and the middle value is 7, so the base value of this round is 7.
 Partition Operation Optimization

Let the head pointer look backward for red elements and the tail pointer look forward for green elements, then swap the elements pointed by the head and tail pointers and repeat the process until the head and tail pointers are interleaved and stop.
 Heapsort
经典问题：蚂蚁问题
假设现在有一个水平面，上面有 8 只蚂蚁排成一排。方便起见，我们给所有的蚂蚁从左到右依次编号，编号为 1 到 8。从 0 秒开始，红色蚂蚁向左爬，蓝色蚂蚁向右爬，爬行的速度都是 1m/s。如果有 2 只蚂蚁迎面碰到以后，这 2 只蚂蚁不会做任何的感情交流，而会立刻掉头向相反方向继续爬行。而爬行到桌子边沿的蚂蚁，会从桌子上掉下去。问：有哪些蚂蚁会从左边掉下去，又有哪些蚂蚁会从右边掉下去？

 大顶堆

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>手册</tag>
      </tags>
  </entry>
  <entry>
    <title>なんでもないや-RADWIMPS</title>
    <url>/2024/10/25/2024-10-24-%E6%B2%A1%E4%BB%80%E4%B9%88%E5%A4%A7%E4%B8%8D%E4%BA%86_Lyrics/</url>
    <content><![CDATA[
    なんでもないや
	Album: 你的名字。
    Lyricist & Composer : 野田洋次郎 (Yojiro Noda)



    .line {
      text-align: center; 
      display: block;
      width: 100%;
      font-size: 1.4em;
    }
    rt {
      color: blue;
      font-size: 0.6em;
    }

二人(ふたり)の間(あいだ) 通(とお)り過(す)ぎた風(かぜ)はどこから寂(さび)しさを運(はこ)んできたの泣(な)いたりしたそのあとの空(そら)はやけに透(す)き通(とお)っていたりしたんだいつもは尖(とが)ってた父(ちち)の言葉(ことば)が今日(きょう)は暖(あたた)かく感(かん)じました優(やさ)しさも笑顔(えがお)も夢(ゆめ)の語(かた)り方(かた)も知(し)らなくて全部(ぜんぶ) 君(きみ)を真似(まね)たよもう少(すこ)しだけでいいあと少(すこ)しだけでいいもう少(すこ)しだけでいいからもう少(すこ)しだけでいいあと少(すこ)しだけでいいもう少(すこ)しだけくっついていようか僕(ぼく)らタイムフライヤー時(じ)を駆(か)け上(あ)がるクライマー時(じ)のかくれんぼはぐれっこはもういやなんだ嬉(うれ)しくて泣(な)くのは悲(かな)しくて笑(わら)うのは君(くん)の心(こころ)が 君(きみ)を追(お)い越(こ)したんだよ星(ほし)にまで願(ねが)って手(て)にいれたオモチャも部屋(べや)の隅(すみ)っこに今(いま) 転(ころ)がってる叶(かな)えたい夢(ゆめ)も今日(きょう)で１００個(こ)できたよたった一(ひと)つといつか交換(こうかん)こしよういつもは喋(しゃべ)らないあの子(こ)に今日(きょう)は放課(ほうか)後(ご)「また明日(あした)」と声(こえ)をかけた慣(な)れないこともたまにならいいね特(とく)にあなたが 隣(となり)にいたらもう少(すこ)しだけでいいあと少(すこ)しだけでいいもう少(すこ)しだけでいいからもう少(すこ)しだけでいいあと少(すこ)しだけでいいもう少(すこ)しだけくっついていようよ僕(ぼく)らタイムフライヤー君(くん)を知(し)っていたんだ僕(ぼく)が 僕(ぼく)の名前(なまえ)を覚(おぼ)えるよりずっと前(まえ)に君(くん)のいない 世界(せかい)にも何(なに)かの意味(いみ)はきっとあってでも君(きみ)のいない 世界(せかい)など夏休(なつやす)みのない 八月(がつ)のよう君(くん)のいない 世界(せかい)など笑(わら)うことない サンタのよう君(くん)のいない 世界(せかい)など僕(ぼく)らタイムフライヤー時(じ)を駆(か)け上(あ)がるクライマー時(じ)のかくれんぼはぐれっこはもういやなんだなんでもないややっぱりなんでもないや今(いま)から行(い)くよ僕(ぼく)らタイムフライヤー時(じ)を駆(か)け上(あ)がるクライマー時(じ)のかくれんぼはぐれっこ はもういいよ君(くん)は派手(はで)なクライヤーその涙(なみだ) 止(と)めてみたいなだけど 君(きみ)は拒(こば)んだ零(こぼ)れるままの涙(なみだ)を見(み)てわかった嬉(うれ)しくて泣(な)くのは悲(かな)しくて 笑(わら)うのは僕(ぼく)の心(こころ)が 僕(ぼく)を追(お)い越(こ)したんだよ

]]></content>
      <categories>
        <category>歌词</category>
      </categories>
      <tags>
        <tag>RADWIMPS</tag>
      </tags>
  </entry>
  <entry>
    <title>告白-RADWIMPS</title>
    <url>/2025/04/28/2025-04-27-%E5%91%8A%E7%99%BD_Lyrics/</url>
    <content><![CDATA[
    告白
	Album: 人間開花 (Ningen kaika)
    Lyricist & Composer : 野田洋次郎 (Yojiro Noda)



    .line {
      text-align: center; 
      display: block;
      width: 100%;
      font-size: 1.4em;
    }
    rt {
      color: blue;
      font-size: 0.6em;
    }
  君(きみ)の未来(みらい)に　僕(ぼく)の姿(すがた)を　見(み)るようになったのはいつからだったでしょう君(くん)の未来(みらい)と　僕(ぼく)の未来(みらい)が　一(ひと)つになればいいななんて思(おも)ったのはいつからでしょう　照(て)れくさいから言(い)わないけど今日(きょう)から一(ひと)つの　未来(みらい)になろう笑顔(えがお)ひとつを作(つく)るのさえも　汗(あせ)かきあたり見渡(みわた)す僕(ぼく)だけれど見渡(みわた)した人(ひと)のその群(む)れの中(なか)に　ふとひとつだけ場違(ばちが)いなほど美(うつく)しい色(しょく)の魂(たましい)　それがつまりあなたでした「大事(だいじ)なものを　見(み)つけたよ」そんな声(こえ)がしたんだ　僕(ぼく)の奥(おく)の方(ほう)からこれほど誰(だれ)かが僕(ぼく)の真(ま)ん中(なか)を　一人占(ひとりじ)めにしてくれるとはこの世界(せかい)が言(い)うには絶対(ぜったい)なんてないけど　内緒(ないしょ)で今(いま)　作(つく)ろうよ生(い)きる強(つよ)さも　涙脆(なみだもろ)さも　少(すこ)し目立(めだ)ちすぎだよこの星(ほし)では持(も)て余(あま)しすぎた　この世(よ)の神々(かみがみ)が　キミを僕(ぼく)のとこに送(おく)り込(こ)んだとしたらほんとにありがとう　何度(なんど)も言(い)うよどうもありがとう大事(だいじ)なことを言(い)わせてよいまだ未(み)開封(かいふう)の勇気(ゆうき)を　ここで使(つか)うからこれほど誰(だれ)かで僕(ぼく)の真(ま)ん中(なか)が　いっぱいに満(み)たされるとはこの世界(せかい)が言(い)うには絶対(ぜったい)なんてないけど　ねぇここに一(ひと)つあるよふたりで一緒(いっしょ)に　風邪(かぜ)をひこうよ午前(ごぜん)3時(じ)の　夢(ゆめ)を抜(ぬ)け駆(が)けしよう僕(ぼく)の未来(みらい)に　君(きみ)の姿(すがた)を　見(み)るようになったのはいつからだったでしょう君(くん)の未来(みらい)と　僕(ぼく)の未来(みらい)を　ひとつの意味(いみ)としようよ今日(きょう)この場(ば)でこれほど誰(だれ)かが僕(ぼく)の真(ま)ん中(なか)を　一人占(ひとりじ)めにしてくれるとはこの世界(せかい)が言(い)うには絶対(ぜったい)なんてないけど　内緒(ないしょ)で今(いま)　作(つく)ろうよこれほど誰(だれ)かで僕(ぼく)が真(ま)ん中(なか)を　いっぱいにしてくれるとはこの世界(せかい)が言(い)うには絶対(ぜったい)なんてないけど　ねぇここに一(ひと)つあるよ

]]></content>
      <categories>
        <category>歌词</category>
      </categories>
      <tags>
        <tag>RADWIMPS</tag>
      </tags>
  </entry>
  <entry>
    <title>スパークル-RADWIMPS</title>
    <url>/2024/12/13/2024-12-12-Spark_Lyrics/</url>
    <content><![CDATA[
    スパークル
	Album: 人間開花
    Lyricist & Composer : 野田洋次郎


    
        .line {
            text-align: center;
            display: block;
            width: 100%;
            font-size: 1.4em;
        }
        rt {
            color: blue;
            font-size: 0.6em;
        }
    
    まだこの世界
                (
                せかい
                )
            は　僕
                (
                ぼく
                )
            を飼(
                か
                )
            いならしてたいみたいだ
    望(
                のぞ
                )
            み通(
                どお
                )
            りいいだろう　美(
                うつく
                )
            しくもがくよ
    
    互(
                たが
                )
            いの砂時計
                (
                すなどけい
                )
            　眺(
                なが
                )
            めながらキスをしようよ
    「さよなら」から一番(
                ばん
                )
            　遠(
                とお
                )
            い　場所
                (
                ばしょ
                )
            で待(
                ま
                )
            ち合(
                あ
                )
            わせよう
    
    ついに時(
                とき
                )
            はきた　昨日(
                きのう
                )
            までは序章
                (
                じょしょう
                )
            の序章(
                じょしょう
                )
            で
    飛(
                と
                )
            ばし読(
                よ
                )
            みでいいから　ここからが僕(
                ぼく
                )
            だよ
    経験(
                けいけん
                )
            と知識(
                ちしき
                )
            と　カビの生(
                は
                )
            えかかった勇気(
                ゆうき
                )
            を持(
                も
                )
            って
    いまだかつてないスピードで　君(
                きみ
                )
            のもとへダイブを
    
    まどろみの中
                (
                なか
                )
            で　生温
                (
                なまぬる
                )
            いコーラに
    ここでないどこかを　夢見(
                ゆめみ
                )
            たよ
    教室(
                きょうしつ
                )
            の窓(
                まど
                )
            の外(
                そと
                )
            に
    電車(
                でんしゃ
                )
            に揺(
                ゆ
                )
            られ　運
                (
                はこ
                )
            ばれる朝
                (
                あさ
                )
            に
    
    運命(
                うんめい
                )
            だとか未来
                (
                みらい
                )
            とかって　言葉(
                ことば
                )
            がどれだけ手(
                て
                )
            を
    伸(
                の
                )
            ばそうと届(
                とど
                )
            かない　場所(
                ばしょ
                )
            で僕(
                ぼく
                )
            ら恋(
                こい
                )
            をする
    時計(
                とけい
                )
            の針(
                はり
                )
            も二人(
                ふたり
                )
            を　横目
                (
                よこめ
                )
            に見(
                み
                )
            ながら進(
                すす
                )
            む
    こんな世界(
                せかい
                )
            を二人(
                ふたり
                )
            で　一生
                (
                いっしょう
                )
            　いや、何章(
                なんしょう
                )
            でも
    生(
                い
                )
            き抜(
                ぬ
                )
            いていこう
    
    「はじめまして」なんてさ　遥(
                はる
                )
            か彼方(
                かなた
                )
            へと追
                (
                お
                )
            いやって
    1000年(
                ねん
                )
            周期(
                しゅうき
                )
            を　一日(
                にち
                )
            で息(
                いき
                )
            しよう
    
    辞書(
                じしょ
                )
            にある言葉
                (
                ことば
                )
            で　出来上
                (
                できあ
                )
            がった世界
                (
                せかい
                )
            を憎(
                にく
                )
            んだ
    万華鏡(
                まんげきょう
                )
            の中(
                なか
                )
            で　八月(
                がつ
                )
            のある朝
                (
                あさ
                )
            
    
    君(
                きみ
                )
            は僕(
                ぼく
                )
            の前(
                まえ
                )
            で　ハニかんでは澄(
                す
                )
            ましてみせた
    この世界(
                せかい
                )
            の教科書(
                きょうかしょ
                )
            のような笑顔(
                えがお
                )
            で
    
    嘘(
                うそ
                )
            みたいな日々(
                ひび
                )
            を　規格
                (
                きかく
                )
            外(
                がい
                )
            の意味(
                いみ
                )
            を
    悲劇(
                ひげき
                )
            だっていいから望(
                のぞ
                )
            んだよ
    
    そしたらドアの外(
                そと
                )
            に
    君(
                きみ
                )
            が全部(
                ぜんぶ
                )
            抱(
                かか
                )
            えて立
                (
                た
                )
            っていたよ
    
    運命(
                うんめい
                )
            だとか未来
                (
                みらい
                )
            とかって　言葉(
                ことば
                )
            がどれだけ手(
                て
                )
            を
    伸(
                の
                )
            ばそうと届(
                とど
                )
            かない　場所(
                ばしょ
                )
            で　僕
                (
                ぼく
                )
            ら遊(
                あそ
                )
            ぼうか
    
    
    愛(
                あい
                )
            し方(
                かた
                )
            さえも　君(
                きみ
                )
            の匂(
                にお
                )
            いがした
    歩(
                ある
                )
            き方(
                かた
                )
            さえも　その笑(
                わら
                )
            い声(
                ごえ
                )
            がした
    
    
    いつか消(
                き
                )
            えてなくなる　君(
                きみ
                )
            のすべてを
    この眼(
                め
                )
            に焼(
                や
                )
            き付(
                つ
                )
            けておくことは
    もう権利(
                けんり
                )
            なんかじゃない　義務(
                ぎむ
                )
            だと思
                (
                おも
                )
            うんだ
    
    
    運命(
                うんめい
                )
            だとか未来
                (
                みらい
                )
            とかって　言葉(
                ことば
                )
            がどれだけ手(
                て
                )
            を
    伸(
                の
                )
            ばそうと届(
                とど
                )
            かない　場所(
                ばしょ
                )
            で僕(
                ぼく
                )
            ら恋(
                こい
                )
            をする
    時計(
                とけい
                )
            の針(
                はり
                )
            も二人(
                ふたり
                )
            を　横目
                (
                よこめ
                )
            に見(
                み
                )
            ながら進(
                すす
                )
            む
    そんな世界(
                せかい
                )
            を二人(
                ふたり
                )
            で　一生
                (
                いっしょう
                )
            　いや、何章(
                なんしょう
                )
            でも
    
    生(
                い
                )
            き抜(
                ぬ
                )
            いていこう
    終(
                お
                )
            わり


]]></content>
      <categories>
        <category>歌词</category>
      </categories>
      <tags>
        <tag>RADWIMPS</tag>
      </tags>
  </entry>
  <entry>
    <title>总有一天你会出现在我身边</title>
    <url>/2025/05/24/2025-05-24-%E6%80%BB%E6%9C%89%E4%B8%80%E5%A4%A9%E4%BD%A0%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%9C%A8%E6%88%91%E8%BA%AB%E8%BE%B9_Lyrics/</url>
    <content><![CDATA[ 总有一天你会出现在我身边
从前我的另一边
通往凌晨的街
空无一人的世界
行影匆匆这些年
期望从未破灭
默不作响的时间
最好的人注定会到身边
孤注一掷的执念
我终将看到你身影逆光 出现
等这一切 都被你了解 十指错落相牵
跨越时间 再没有分别 携手走过明天
雨后路人化鱼鲔
欢愉游跃摇曳
灿烂一抱的世界
光芒捧起你的脸
我飞在云层间
狂奔向你不停歇
你说最好的人会到身边
此刻我也这样想
你终将看到我最美模样 出现
等这一切 都被你了解 十指错落相牵
跨越时间 再没有分别 携手走过明天
总会有些 幸运会出现 我等待这一天
总有艰险 哪怕是谎言 我等待你出现
等这一切 都被你了解 十指错落相牵
跨越时间 再没有分别 携手走过明天
等这一切 都被你了解 十指错落相牵
跨越时间 总会有一天 你出现我身边
]]></content>
      <categories>
        <category>歌词</category>
      </categories>
      <tags>
        <tag>棱镜乐队</tag>
      </tags>
  </entry>
</search>
